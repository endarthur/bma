<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BMA — Block Model Atelier</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='8' fill='%232d2d2d'/%3E%3Ccircle cx='32' cy='32' r='27' stroke='%23a0a0a0' fill='none' opacity='.4' transform='rotate(15,32,32)'/%3E%3Ctext x='32' y='43' font-family='Georgia,serif' font-size='24' font-weight='bold' fill='%23b87333' text-anchor='middle'%3EBMA%3C/text%3E%3C/svg%3E">
<meta name="theme-color" content="#08090a">
<meta name="description" content="Client-side CSV block model analyzer for mining and geostatistics">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #08090a;
  --bg1: #0f1114;
  --bg2: #161a1e;
  --bg3: #1e2328;
  --fg: #c8cdd3;
  --fg-dim: #6b7280;
  --fg-bright: #e8ecf0;
  --amber: #e8a317;
  --amber-dim: #b07a0e;
  --amber-glow: #e8a31730;
  --blue: #4a9eff;
  --green: #34d399;
  --red: #f87171;
  --border: #252a30;
  --mono: 'IBM Plex Mono', 'JetBrains Mono', monospace;
  --hl-keyword: #c678dd;
  --hl-string: #98c379;
  --hl-number: #d19a66;
  --hl-comment: #5c6370;
  --hl-function: #61afef;
  --hl-operator: #56b6c2;
  --hl-punct: #abb2bf;
}

/* ─── Built-in Themes ─────────────────────────────────────────────── */
[data-theme="teal"] {
  --bg: #070b0c; --bg1: #0c1315; --bg2: #13191d; --bg3: #1a2226;
  --fg: #c2d1d6; --fg-dim: #5f7a80; --fg-bright: #e0eff4;
  --amber: #2dd4bf; --amber-dim: #14b8a6; --amber-glow: #2dd4bf30;
  --border: #1e2e32;
}
[data-theme="blue"] {
  --bg: #080a0f; --bg1: #0c1019; --bg2: #131825; --bg3: #1a2130;
  --fg: #c4ccdb; --fg-dim: #6878a0; --fg-bright: #e2e8f5;
  --amber: #4a9eff; --amber-dim: #2d7ad4; --amber-glow: #4a9eff30;
  --border: #202840;
}
[data-theme="mocha"] {
  --bg: #1e1e2e; --bg1: #181825; --bg2: #252540; --bg3: #313244;
  --fg: #cdd6f4; --fg-dim: #6c7086; --fg-bright: #f5e0dc;
  --amber: #f9e2af; --amber-dim: #e2c88c; --amber-glow: #f9e2af30;
  --border: #45475a;
  --hl-keyword: #cba6f7; --hl-string: #a6e3a1; --hl-number: #fab387;
  --hl-comment: #6c7086; --hl-function: #89b4fa; --hl-operator: #94e2d5; --hl-punct: #9399b2;
}
[data-theme="light"] {
  --bg: #f5f5f0; --bg1: #eaeae5; --bg2: #ddddd8; --bg3: #d0d0cb;
  --fg: #2c2c2c; --fg-dim: #808080; --fg-bright: #1a1a1a;
  --amber: #c07800; --amber-dim: #996000; --amber-glow: #c0780020;
  --border: #c8c8c0; --blue: #2563eb; --green: #059669; --red: #dc2626;
  --hl-keyword: #a626a4; --hl-string: #50a14f; --hl-number: #c76b29;
  --hl-comment: #a0a1a7; --hl-function: #2563eb; --hl-operator: #0184bc; --hl-punct: #5a5a5a;
}
[data-theme="cream"] {
  --bg: #ece8e0; --bg1: #e2ded6; --bg2: #d8d4cc; --bg3: #cecac2;
  --fg: #3a3530; --fg-dim: #8a8278; --fg-bright: #22201c;
  --amber: #9a7320; --amber-dim: #7a5b18; --amber-glow: #9a732025;
  --border: #c4bfb5; --blue: #2d6abf; --green: #1a7a52; --red: #c43030;
  --hl-keyword: #8b5e1a; --hl-string: #3a7a3a; --hl-number: #a85d20;
  --hl-comment: #9a9590; --hl-function: #2d6abf; --hl-operator: #1a7a52; --hl-punct: #6a6560;
}
[data-theme="bm77"] {
  --bg: #262335; --bg1: #2a2139; --bg2: #34294f; --bg3: #3e3357;
  --fg: #b6b1c4; --fg-dim: #6d5f8a; --fg-bright: #f0e8ff;
  --amber: #ff7edb; --amber-dim: #d66bb5; --amber-glow: #ff7edb30;
  --border: #463b5e; --blue: #36f9f6; --green: #72f1b8; --red: #fe4450;
  --hl-keyword: #fede5d; --hl-string: #72f1b8; --hl-number: #f97e72;
  --hl-comment: #6d5f8a; --hl-function: #36f9f6; --hl-operator: #ff7edb; --hl-punct: #8a7eaa;
}
/* BM77 neon glow effects */
[data-theme="bm77"] header h1 {
  text-shadow: 0 0 10px #ff7edb80, 0 0 25px #ff7edb40, 0 0 50px #ff7edb20;
}
[data-theme="bm77"] .results-tab.active {
  text-shadow: 0 0 8px #ff7edb90, 0 0 20px #ff7edb40;
}
[data-theme="bm77"] .section-head {
  text-shadow: 0 0 8px #ff7edb60, 0 0 18px #ff7edb30;
}
[data-theme="bm77"] .badge {
  box-shadow: 0 0 6px #ff7edb60, 0 0 14px #ff7edb30;
}
[data-theme="bm77"] .toolbar-btn:hover,
[data-theme="bm77"] .toolbar-icon-btn:hover {
  box-shadow: 0 0 8px #ff7edb50;
  text-shadow: 0 0 6px #ff7edb80;
}
[data-theme="bm77"] .execute-btn {
  box-shadow: 0 0 10px #ff7edb50, 0 0 25px #ff7edb25;
  text-shadow: 0 0 6px #ff7edb80;
}
[data-theme="bm77"] .stats-sidebar-title,
[data-theme="bm77"] .statscat-sidebar-title,
[data-theme="bm77"] .cat-sidebar-title,
[data-theme="bm77"] .gt-sidebar-title,
[data-theme="bm77"] .calcol-editor-head span,
[data-theme="bm77"] .calcol-sb-title,
[data-theme="bm77"] .settings-section-title,
[data-theme="bm77"] .preflight-head {
  text-shadow: 0 0 8px #ff7edb50, 0 0 16px #ff7edb25;
}
[data-theme="bm77"] .type-toggle[data-type="numeric"] {
  text-shadow: 0 0 6px #36f9f680;
}
[data-theme="bm77"] .type-toggle[data-type="categorical"] {
  text-shadow: 0 0 6px #ff7edb80;
}
[data-theme="bm77"] .stats-preset.active,
[data-theme="bm77"] .settings-preset-btn.active {
  box-shadow: 0 0 6px #ff7edb50;
  text-shadow: 0 0 6px #ff7edb80;
}
[data-theme="bm77"] .filter-apply-btn {
  box-shadow: 0 0 6px #36f9f640;
  text-shadow: 0 0 6px #36f9f680;
}
[data-theme="bm77"] .dropzone:hover,
[data-theme="bm77"] .dropzone.drag-over {
  box-shadow: 0 0 30px #ff7edb30, 0 0 60px #ff7edb15;
}
[data-theme="bm77"] .settings-swatch.selected {
  box-shadow: 0 0 8px #ff7edb60;
}
[data-theme="bm77"] .results-toolbar {
  border-bottom-color: #463b5e;
  box-shadow: 0 1px 12px #ff7edb10;
}
[data-theme="bm77"] ::-webkit-scrollbar-thumb {
  background: #4e3d6e;
}
[data-theme="bm77"] ::-webkit-scrollbar-thumb:hover {
  background: #5f4d80;
}
[data-theme="bm77"] .hl-keyword { text-shadow: 0 0 8px #fede5d80, 0 0 18px #fede5d30; }
[data-theme="bm77"] .hl-function { text-shadow: 0 0 8px #36f9f680, 0 0 18px #36f9f630; }
[data-theme="bm77"] .hl-string { text-shadow: 0 0 6px #72f1b860; }
[data-theme="bm77"] .hl-operator { text-shadow: 0 0 6px #ff7edb60; }
[data-theme="bm77"] .hl-rowaccess { text-shadow: 0 0 8px #ff7edb80, 0 0 16px #ff7edb30; }

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 14px; }
body {
  font-family: var(--mono);
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
  line-height: 1.6;
}
.app {
  margin: 0 auto;
  padding: 2rem 1.5rem;
  max-width: 800px;
}
.app.has-results {
  max-width: none;
  padding: 0;
}
.app.has-results > header,
.app.has-results > .dropzone,
.app.has-results > .about-section,
.app.has-results > .recent-files,
.app.has-results > .landing-footer { display: none; }
.app.has-results > .error-msg { display: none; }
.app.has-results > .error-msg.active { display: block; }
header {
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--border);
  padding-bottom: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
header h1 {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.08em;
  text-transform: uppercase;
}
header .sub {
  font-size: 0.78rem;
  color: var(--fg-dim);
  margin-top: 0.2rem;
}
header .logo-mark {
  width: 48px;
  height: 48px;
  opacity: 0.7;
  flex-shrink: 0;
}
.about-section {
  margin-top: 1.5rem;
  font-size: 0.75rem;
  color: var(--fg-dim);
  line-height: 1.7;
}
.about-section h2 {
  font-size: 0.78rem;
  color: var(--fg-bright);
  font-weight: 600;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  margin-bottom: 0.6rem;
}
.about-section p { margin: 0 0 0.8rem; }
.about-section code {
  background: var(--bg1);
  padding: 0.1rem 0.35rem;
  border-radius: 2px;
  font-size: 0.7rem;
  color: var(--fg-bright);
}
.about-features {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.4rem 1.5rem;
  margin: 0.6rem 0;
}
.about-features span {
  display: flex;
  align-items: baseline;
  gap: 0.4rem;
}
.about-features span::before {
  content: '·';
  color: var(--amber-dim);
  font-weight: 700;
}
.landing-footer {
  margin-top: 2rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border);
  font-size: 0.62rem;
  color: var(--fg-dim);
  opacity: 0.5;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.landing-footer a {
  color: var(--fg-dim);
  text-decoration: none;
}
.landing-footer a:hover { color: var(--fg-bright); }

/* Recent Files */
.recent-files {
  margin-top: 1.5rem;
}
.recent-files:empty { display: none; }
.recent-files-title {
  font-size: 0.68rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-weight: 600;
  margin-bottom: 0.5rem;
}
.recent-item {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  padding: 0.45rem 0.7rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.75rem;
  color: var(--fg);
  border: 1px solid transparent;
  transition: background 0.15s, border-color 0.15s;
}
.recent-item:hover {
  background: var(--bg2);
  border-color: var(--border);
}
.recent-item-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: 500;
  color: var(--fg-bright);
}
.recent-item-size {
  color: var(--fg-dim);
  font-size: 0.68rem;
  white-space: nowrap;
}
.recent-item-time {
  color: var(--fg-dim);
  font-size: 0.68rem;
  white-space: nowrap;
  min-width: 5.5em;
  text-align: right;
}
.recent-item-project {
  font-size: 0.58rem;
  color: var(--amber-dim);
  background: var(--amber-glow);
  padding: 0.1rem 0.35rem;
  border-radius: 2px;
  white-space: nowrap;
}
.recent-item-remove {
  background: none;
  border: none;
  color: var(--fg-dim);
  cursor: pointer;
  font-size: 0.75rem;
  padding: 0 0.25rem;
  line-height: 1;
  opacity: 0;
  transition: opacity 0.15s, color 0.15s;
}
.recent-item:hover .recent-item-remove { opacity: 1; }
.recent-item-remove:hover { color: var(--red); }

/* Drop Zone */
.dropzone {
  border: 2px dashed var(--border);
  border-radius: 6px;
  padding: 3rem 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  background: var(--bg1);
  position: relative;
}
.dropzone:hover, .dropzone.drag-over {
  border-color: var(--amber);
  background: var(--amber-glow);
}
.dropzone.drag-over { box-shadow: 0 0 30px var(--amber-glow); }
.dropzone .label {
  font-size: 1rem;
  color: var(--fg-dim);
  font-weight: 300;
}
.dropzone .label strong { color: var(--amber); font-weight: 500; }
.dropzone .hint {
  font-size: 0.72rem;
  color: var(--fg-dim);
  margin-top: 0.5rem;
  opacity: 0.6;
}
.dropzone.collapsed {
  padding: 0.5rem 1rem;
  border-style: solid;
  display: flex;
  align-items: center;
  gap: 1rem;
}
.dropzone.collapsed .label { font-size: 0.75rem; }
.dropzone.collapsed .hint { display: none; }
.dropzone.collapsed .loaded-name {
  color: var(--fg-bright);
  font-weight: 500;
  font-size: 0.75rem;
}
.dropzone input[type="file"] {
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
}

/* Progress */
/* Dark scrollbars */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: var(--bg1); }
::-webkit-scrollbar-thumb { background: var(--bg3); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #2d333b; }
::-webkit-scrollbar-corner { background: var(--bg1); }
* { scrollbar-width: thin; scrollbar-color: var(--bg3) var(--bg1); }

/* Preflight panel — full viewport overlay */
/* Preflight panel — needs flex column for head + body to fill space */
#panelPreflight.active { display: flex; flex-direction: column; overflow-y: hidden; }
.preflight-head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 1rem;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  flex-shrink: 0;
}
.preflight-back-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  width: 1.6rem;
  height: 1.6rem;
  border-radius: 3px;
  cursor: pointer;
  font-size: 0.8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}
.preflight-back-btn:hover { color: var(--fg-bright); border-color: var(--fg-dim); }
.preflight-filename {
  font-size: 0.7rem;
  color: var(--fg-dim);
  font-weight: 400;
  text-transform: none;
  letter-spacing: 0;
}
.preflight-zip {
  font-size: 0.72rem;
  color: var(--fg-dim);
}
.preflight-zip:empty { display: none; }
.preflight-zip select {
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.25rem 0.4rem;
  font-family: var(--mono);
  font-size: 0.7rem;
  margin: 0 0.3rem;
}
.preflight-zip .zip-size {
  font-size: 0.65rem;
  color: var(--fg-dim);
  margin-left: 0.3rem;
}

/* Two-column body */
.preflight-body {
  flex: 1;
  display: flex;
  min-height: 0;
}

/* Left sidebar — column controls */
.preflight-sidebar {
  width: 300px;
  min-width: 240px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.pf-sidebar-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.pf-sidebar-section-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
}
.pf-xyz-row {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 0.4rem;
  align-items: center;
}
.pf-xyz-row label {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.68rem;
  color: var(--fg-dim);
}
.pf-xyz-row .axis-label {
  font-weight: 700;
  color: var(--amber);
  font-size: 0.7rem;
  min-width: 1.4rem;
}
.pf-xyz-row select {
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.3rem;
  font-family: var(--mono);
  font-size: 0.66rem;
  min-width: 0;
  flex: 1;
}
.pf-col-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.pf-col-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.3rem 0.7rem;
  border-bottom: 1px solid var(--bg2);
  font-size: 0.7rem;
  transition: opacity 0.15s;
}
.pf-col-item:hover { background: var(--bg1); }
.pf-col-item.skipped { opacity: 0.3; }
.pf-col-item .col-idx {
  color: var(--fg-dim);
  opacity: 0.4;
  font-size: 0.58rem;
  min-width: 1.6em;
  text-align: right;
}
.pf-col-check {
  accent-color: var(--amber);
  width: 13px;
  height: 13px;
  cursor: pointer;
  flex-shrink: 0;
}
.pf-col-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg-bright);
  font-weight: 500;
}
.pf-col-controls {
  display: flex;
  gap: 0.25rem;
  align-items: center;
  flex-shrink: 0;
}
.type-toggle {
  font-size: 0.54rem;
  padding: 0.06rem 0.25rem;
  border-radius: 2px;
  border: 1px solid var(--border);
  cursor: pointer;
  font-family: var(--mono);
  font-weight: 600;
  letter-spacing: 0.04em;
  background: none;
  line-height: 1.2;
}
.type-toggle[data-type="numeric"] {
  color: var(--blue);
  border-color: var(--blue);
}
.type-toggle[data-type="categorical"] {
  color: var(--amber);
  border-color: var(--amber);
}
.pf-filter-btn {
  font-size: 0.5rem;
  padding: 0.06rem 0.2rem;
  border-radius: 2px;
  border: 1px solid var(--border);
  cursor: pointer;
  font-family: var(--mono);
  font-weight: 600;
  background: none;
  color: var(--fg-dim);
  line-height: 1.2;
  opacity: 0.5;
}
.pf-filter-btn.active {
  opacity: 1;
  color: var(--red, #f47067);
  border-color: var(--red, #f47067);
}
.pf-filter-btn:hover { opacity: 0.8; }
.pf-filter-hidden { display: none !important; }
.pf-sidebar-actions {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}
.pf-sidebar-actions button {
  font-size: 0.6rem;
  background: none;
  border: none;
  color: var(--blue);
  cursor: pointer;
  font-family: var(--mono);
  padding: 0;
}
.pf-sidebar-actions button:hover { text-decoration: underline; }
.pf-col-count {
  font-size: 0.6rem;
  color: var(--fg-dim);
  margin-left: auto;
}
.pf-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  box-sizing: border-box;
  margin-bottom: 0.3rem;
}
.pf-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.pf-search:focus { outline: none; border-color: var(--amber); }
.pf-bulk-filters {
  display: flex;
  gap: 0.4rem;
  align-items: center;
}
.pf-bulk-filters button {
  font-size: 0.58rem;
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  cursor: pointer;
  font-family: var(--mono);
  padding: 0.1rem 0.35rem;
  border-radius: 2px;
}
.pf-bulk-filters button:hover { color: var(--fg-bright); border-color: var(--fg-dim); }
.pf-filter-count {
  font-size: 0.58rem;
  color: var(--fg-dim);
  margin-left: auto;
}

/* Right preview pane */
.preflight-preview-wrap {
  flex: 1;
  overflow: auto;
  min-height: 0;
  min-width: 0;
}
.preflight-preview table {
  width: max-content;
  min-width: 100%;
  border-collapse: collapse;
  font-size: 0.72rem;
  white-space: nowrap;
}
.preflight-preview th {
  position: sticky;
  top: 0;
  background: var(--bg2);
  border-bottom: 2px solid var(--border);
  text-align: left;
  z-index: 2;
  color: var(--fg-bright);
  font-weight: 500;
}
.preflight-preview th, .preflight-preview td {
  padding: 0.25rem 0.6rem;
  border-right: 1px solid var(--border);
}
.preflight-preview th:last-child, .preflight-preview td:last-child { border-right: none; }
.preflight-preview tr { border-bottom: 1px solid #1a1e22; }
.preflight-preview tr:nth-child(even) td { background: var(--bg); }
.preflight-preview tr:nth-child(odd) td { background: var(--bg1); }
.preflight-preview td { color: var(--fg-dim); }
.preflight-preview td:first-child { color: var(--fg-dim); opacity: 0.5; }
.preflight-preview .col-skipped { opacity: 0.2; }

@media (max-width: 700px) {
  .preflight-body { flex-direction: column; }
  .preflight-sidebar {
    width: 100%;
    min-width: unset;
    max-height: 35vh;
    border-right: none;
    border-bottom: 1px solid var(--border);
  }
}

/* Results */
#results { display: none; margin-top: 0; }
#results.active { display: flex; flex-direction: column; height: 100vh; }

.results-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.4rem 1.2rem;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  z-index: 10;
  gap: 0.8rem;
  flex-wrap: wrap;
  position: relative;
}
.toolbar-left {
  display: flex; align-items: center; gap: 0.8rem;
  min-width: 0; flex-shrink: 1;
}
.toolbar-center {
  display: flex; gap: 1rem; align-items: center;
}
.toolbar-right {
  display: flex; gap: 0.5rem; align-items: center;
  position: relative;
}
.results-toolbar-title {
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.06em;
  text-transform: uppercase;
}
.results-toolbar-info {
  font-size: 0.68rem;
  color: var(--fg-dim);
}
.toolbar-btn {
  background: none; border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.68rem var(--mono); padding: 0.2rem 0.6rem;
  cursor: pointer; border-radius: 3px; text-transform: uppercase;
  letter-spacing: 0.04em; white-space: nowrap;
}
.toolbar-btn:hover { color: var(--amber); border-color: var(--amber); }
.toolbar-icon-btn {
  background: none; border: 1px solid var(--border); color: var(--fg-dim);
  border-radius: 3px; cursor: pointer; padding: 0.15rem 0.35rem;
  display: flex; align-items: center; justify-content: center;
}
.toolbar-icon-btn:hover { color: var(--amber); border-color: var(--amber); }
.toolbar-overflow {
  display: none;
  background: none; border: none; color: var(--fg-dim);
  font-size: 1.1rem; cursor: pointer; padding: 0.2rem 0.4rem;
}
.toolbar-overflow:hover { color: var(--fg-bright); }
.toolbar-menu {
  display: none; position: absolute; right: 0; top: 100%;
  background: var(--bg2); border: 1px solid var(--border);
  border-radius: 4px; z-index: 20; min-width: 150px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.toolbar-menu.open { display: block; }
.toolbar-menu-item {
  display: block; width: 100%; text-align: left;
  background: none; border: none; color: var(--fg);
  font: 0.75rem var(--mono); padding: 0.5rem 0.8rem;
  cursor: pointer;
}
.toolbar-menu-item:hover { background: var(--bg3); color: var(--amber); }

@media (max-width: 700px) {
  .toolbar-btn { display: none; }
  .toolbar-icon-btn { display: none; }
  .toolbar-overflow { display: block; }
  .toolbar-center {
    order: 3; width: 100%;
    font-size: 0.62rem; padding-left: 2rem;
  }
}

/* Tabs */
.results-tabs {
  display: flex;
  gap: 0;
  background: var(--bg1);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  padding: 0 1rem;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}
.results-tabs::-webkit-scrollbar { height: 3px; }
.results-tabs::-webkit-scrollbar-track { background: transparent; }
.results-tabs::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.results-tab {
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--fg-dim);
  font-family: var(--mono);
  font-size: 0.72rem;
  font-weight: 500;
  padding: 0.55rem 1rem;
  cursor: pointer;
  letter-spacing: 0.03em;
  transition: color 0.15s, border-color 0.15s;
  white-space: nowrap;
  flex-shrink: 0;
}
.results-tab:hover { color: var(--fg-bright); }
.results-tab.active {
  color: var(--amber);
  border-bottom-color: var(--amber);
}
.results-tab .tab-badge {
  font-size: 0.58rem;
  color: var(--fg-dim);
  margin-left: 0.3rem;
}

/* Panels */
.results-panels {
  flex: 1;
  min-height: 0;
  position: relative;
}
.results-panel {
  display: none;
  position: absolute;
  inset: 0;
  overflow-x: hidden;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.results-panel.active { display: block; }
.panel-inner {
  padding: 1rem 1.2rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
/* Statistics tab — full-bleed sidebar + CDF panel */
#panelStatistics.active { display: flex; flex-direction: column; }
.stats-body {
  display: flex;
  flex: 1;
  min-height: 0;
}
.stats-sidebar {
  width: 260px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg1);
}
.stats-sidebar-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.stats-sidebar-section--grow {
  flex: 1;
  min-height: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
}
.stats-sidebar-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.stats-sidebar-title .badge {
  background: var(--amber-dim);
  color: var(--bg);
  padding: 0.1rem 0.5rem;
  border-radius: 3px;
  font-size: 0.58rem;
  font-weight: 600;
}
.stats-preset-btns {
  display: flex;
  gap: 0;
  margin-bottom: 0.3rem;
}
.stats-preset {
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg2);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  padding: 0.2rem 0.5rem;
  cursor: pointer;
}
.stats-preset:first-child { border-radius: 3px 0 0 3px; }
.stats-preset:last-child { border-radius: 0 3px 3px 0; }
.stats-preset + .stats-preset { border-left: none; }
.stats-preset.active { color: var(--amber); border-color: var(--amber); background: var(--amber-glow); }
.stats-preset:hover:not(.active) { color: var(--fg-bright); }
.stats-custom-input {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.25rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  margin-top: 0.2rem;
}
.stats-custom-input::placeholder { color: var(--fg-dim); opacity: 0.5; }
.stats-custom-input:focus { outline: none; border-color: var(--amber); }
.stats-metric-toggles {
  display: flex;
  flex-wrap: wrap;
  gap: 0.15rem 0.3rem;
}
.stats-metric-toggle {
  display: flex;
  align-items: center;
  gap: 0.2rem;
  font-size: 0.62rem;
  color: var(--fg-dim);
  cursor: pointer;
}
.stats-metric-toggle input { cursor: pointer; accent-color: var(--amber); width: 12px; height: 12px; }
.stats-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  margin-bottom: 0.3rem;
}
.stats-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.stats-search:focus { outline: none; border-color: var(--amber); }
.stats-var-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 0.3rem;
}
.stats-var-actions button {
  font-size: 0.6rem;
  background: none;
  border: none;
  color: var(--blue);
  cursor: pointer;
  font-family: var(--mono);
  padding: 0;
}
.stats-var-actions button:hover { text-decoration: underline; }
.stats-var-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.stats-var-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.25rem 0.5rem;
  font-size: 0.7rem;
  cursor: pointer;
  border-bottom: 1px solid var(--bg2);
}
.stats-var-item:hover { background: var(--bg2); }
.stats-var-item input { flex-shrink: 0; cursor: pointer; accent-color: var(--amber); width: 13px; height: 13px; }
.stats-var-item .var-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--fg-bright); }
.stats-var-item.unchecked { opacity: 0.4; }
.stats-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}
.stats-table-area {
  flex: 1;
  overflow: auto;
  min-height: 0;
}
.stats-table-toolbar {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.4rem 0.8rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  background: var(--bg1);
  position: sticky;
  top: 0;
  z-index: 3;
}
.stats-copy-btn {
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg2);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.6rem;
  cursor: pointer;
}
.stats-copy-btn:hover { color: var(--fg-bright); border-color: var(--amber); }
.stats-table-wrap { overflow-x: auto; }
.stats-cdf-panel {
  border-top: 1px solid var(--border);
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  max-height: 380px;
  background: var(--bg1);
}
.stats-cdf-toolbar {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  padding: 0.3rem 0.8rem;
  border-bottom: 1px solid var(--border);
  font-size: 0.65rem;
  flex-shrink: 0;
}
.stats-cdf-toolbar .tb-group {
  display: flex;
  align-items: center;
  gap: 0.3rem;
}
.stats-cdf-toolbar button {
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg2);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.15rem 0.5rem;
  cursor: pointer;
}
.stats-cdf-toolbar button:hover { color: var(--fg-bright); border-color: var(--amber); }
.stats-cdf-toolbar button.active { color: var(--amber); border-color: var(--amber); background: var(--amber-glow); }
.stats-cdf-chart {
  flex: 1;
  overflow: auto;
  min-height: 0;
  padding: 0.5rem;
  position: relative;
}
.stats-cdf-tooltip {
  position: absolute;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
  font-size: 0.68rem;
  line-height: 1.5;
  pointer-events: none;
  z-index: 10;
  white-space: nowrap;
}
.stats-cdf-chart svg { width: 100%; height: auto; max-height: 340px; }
.stats-cdf-hint {
  color: var(--fg-dim);
  font-size: 0.72rem;
  text-align: center;
  padding: 2rem;
  opacity: 0.5;
}
.stats-scale { /* inherits from toolbar button */ }
@media (max-width: 700px) {
  .stats-body { flex-direction: column; }
  .stats-sidebar {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: none;
    overflow-y: auto;
  }
  .stats-sidebar-section--grow {
    max-height: none;
    overflow: hidden;
  }
  .stats-sidebar-title {
    cursor: pointer;
    user-select: none;
  }
  .stats-sidebar-title::after {
    content: ' \25BE';
    font-size: 0.6em;
  }
  .stats-sidebar-section--grow.collapsed {
    flex: none;
  }
  .stats-sidebar-section--grow.collapsed > *:not(.stats-sidebar-title) {
    display: none;
  }
  .stats-sidebar-section--grow.collapsed .stats-sidebar-title::after {
    content: ' \25B8';
  }
  .stats-cdf-panel { max-height: 300px; }
}

.section {
  margin-bottom: 2rem;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow: hidden;
}
.section-head {
  padding: 0.7rem 1rem;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.section-head .badge {
  background: var(--amber-dim);
  color: var(--bg);
  padding: 0.1rem 0.5rem;
  border-radius: 3px;
  font-size: 0.68rem;
  font-weight: 600;
}
.section-body { padding: 1rem; }

/* Calcol three-column layout */
#panelCalcols.active { display: flex; flex-direction: column; }
.calcol-layout {
  display: flex;
  flex: 1;
  min-height: 0;
}

/* Left sidebar — variable browser */
.calcol-sidebar {
  width: 260px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg1);
}
.calcol-sb-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.calcol-sb-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
}
.calcol-sb-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
}
.calcol-sb-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.calcol-sb-search:focus { outline: none; border-color: var(--amber); }
.calcol-sb-vars {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.calcol-var-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.25rem 0.7rem;
  font-size: 0.7rem;
  cursor: pointer;
  border-bottom: 1px solid var(--bg2);
  color: var(--fg);
  transition: background 0.1s;
}
.calcol-var-item:hover { background: var(--bg2); }
.calcol-var-item .cv-name {
  flex: 1; min-width: 0; overflow: hidden;
  text-overflow: ellipsis; white-space: nowrap;
  color: var(--fg-bright); font-weight: 500;
}
.calcol-var-item .cv-type {
  font-size: 0.55rem; padding: 0 0.3rem; border-radius: 2px;
  font-weight: 600; flex-shrink: 0;
}
.calcol-var-item .cv-type.num { color: var(--blue); border: 1px solid var(--blue); opacity: 0.5; }
.calcol-var-item .cv-type.cat { color: var(--green); border: 1px solid var(--green); opacity: 0.5; }
.calcol-var-item .cv-toggle {
  background: none; border: none; color: var(--fg-dim);
  cursor: pointer; font-size: 0.6rem; padding: 0 0.2rem; flex-shrink: 0;
}
.calcol-var-item .cv-toggle:hover { color: var(--fg-bright); }
.calcol-var-detail {
  padding: 0.2rem 0.7rem 0.4rem 1.4rem;
  font-size: 0.62rem;
  color: var(--fg-dim);
  border-bottom: 1px solid var(--bg2);
  display: none;
}
.calcol-var-detail.open { display: block; }
.calcol-var-detail .cv-stat {
  display: flex; gap: 0.4rem; padding: 0.1rem 0;
}
.calcol-var-detail .cv-stat-label { color: var(--fg-dim); min-width: 3rem; }
.calcol-var-detail .cv-stat-value { color: var(--fg-bright); }
.calcol-var-detail .cv-cat-val {
  cursor: pointer; padding: 0.1rem 0.3rem; border-radius: 2px;
}
.calcol-var-detail .cv-cat-val:hover { background: var(--bg3); color: var(--amber); }

/* Function reference in sidebar */
.calcol-fn-ref {
  font-size: 0.65rem; color: var(--fg-dim);
}
.calcol-fn-ref summary {
  cursor: pointer; color: var(--fg-dim); opacity: 0.6;
}
.calcol-fn-ref summary:hover { opacity: 1; }
.calcol-fn-list {
  padding: 0.3rem 0; max-height: 200px; overflow-y: auto;
}
.calcol-fn-item {
  display: flex; gap: 0.4rem; padding: 0.15rem 0;
  font-size: 0.62rem; cursor: pointer;
}
.calcol-fn-item:hover { color: var(--amber); }
.calcol-fn-item .cfn-name { color: var(--amber); font-weight: 500; }
.calcol-fn-item .cfn-desc { color: var(--fg-dim); }

/* Center — code editor */
.calcol-editor-pane {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}
.calcol-editor-head {
  display: flex; justify-content: space-between; align-items: center;
  padding: 0.5rem 1rem;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  font-size: 0.78rem; font-weight: 600; color: var(--amber);
  letter-spacing: 0.06em; text-transform: uppercase;
  flex-shrink: 0;
}
.calcol-editor-head .badge {
  background: var(--amber-dim); color: var(--bg);
  padding: 0.1rem 0.5rem; border-radius: 3px;
  font-size: 0.68rem; font-weight: 600;
}
.calcol-code-wrap {
  flex: 1;
  position: relative;
  overflow: auto;
  min-height: 120px;
  background: var(--bg);
}
.calcol-code-pre, .calcol-code-area {
  font-family: var(--mono);
  font-size: 0.78rem;
  line-height: 1.6;
  padding: 0.8rem 1rem;
  margin: 0;
  border: none;
  white-space: pre-wrap;
  word-wrap: break-word;
  tab-size: 2;
  -moz-tab-size: 2;
}
.calcol-code-pre {
  position: absolute;
  inset: 0;
  overflow: hidden;
  pointer-events: none;
  color: transparent;
  background: transparent;
}
.calcol-code-area {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 100%;
  resize: none;
  background: transparent;
  color: var(--fg);
  caret-color: var(--amber);
  outline: none;
  z-index: 1;
  -webkit-text-fill-color: transparent;
}
.calcol-code-area::placeholder {
  -webkit-text-fill-color: var(--fg-dim);
  opacity: 0.4;
}
/* Syntax highlighting tokens */
.hl-keyword { color: var(--hl-keyword); }
.hl-string { color: var(--hl-string); }
.hl-number { color: var(--hl-number); }
.hl-comment { color: var(--hl-comment); font-style: italic; }
.hl-rowaccess { color: var(--amber); }
.hl-function { color: var(--hl-function); }
.hl-operator { color: var(--hl-operator); }
.hl-punct { color: var(--hl-punct); }
.hl-text { color: var(--fg); }

/* Calcol autocomplete popup */
.calcol-ac {
  display: none;
  position: absolute;
  z-index: 20;
  max-height: 180px;
  overflow-y: auto;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  min-width: 200px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
}
.calcol-ac.open { display: block; }

.calcol-editor-footer {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  padding: 0.4rem 1rem;
  border-top: 1px solid var(--border);
  background: var(--bg1);
  flex-shrink: 0;
}
.calcol-error {
  flex: 1;
  font-size: 0.65rem;
  color: var(--red);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.calcol-sim-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  padding: 0.25rem 0.7rem;
  border-radius: 3px;
  cursor: pointer;
  font-family: var(--mono);
  font-size: 0.68rem;
  flex-shrink: 0;
}
.calcol-sim-btn:hover { color: var(--amber); border-color: var(--amber); }

/* Expression reference */
.calcol-ref {
  font-size: 0.65rem;
  color: var(--fg-dim);
  padding: 0 1rem 0.5rem;
  flex-shrink: 0;
}
.calcol-ref summary {
  cursor: pointer; color: var(--fg-dim); opacity: 0.6;
}
.calcol-ref summary:hover { opacity: 1; }
.calcol-ref-body {
  padding: 0.4rem 0; line-height: 1.6;
}
.calcol-ref-body p { margin: 0.15rem 0; }
.calcol-ref-body code {
  background: var(--bg); padding: 0.05rem 0.25rem;
  border-radius: 2px; font-size: 0.62rem;
}

/* Right — results panel */
.calcol-results {
  width: 300px;
  flex-shrink: 0;
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg1);
}
.calcol-results-head {
  display: flex; justify-content: space-between; align-items: center;
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  font-size: 0.62rem; color: var(--fg-dim);
  text-transform: uppercase; letter-spacing: 0.08em;
  flex-shrink: 0;
}
.calcol-datasrc-select {
  font-family: var(--mono); font-size: 0.62rem;
  background: var(--bg); color: var(--fg);
  border: 1px solid var(--border); border-radius: 3px;
  padding: 0.1rem 0.3rem; cursor: pointer;
}
.calcol-detected {
  padding: 0.4rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  max-height: 180px;
  overflow-y: auto;
}
.calcol-det-item {
  display: flex; align-items: center; gap: 0.4rem;
  padding: 0.2rem 0; font-size: 0.68rem;
}
.calcol-det-item .cd-name { color: var(--fg-bright); font-weight: 500; flex: 1; }
.calcol-det-item .cd-type {
  font-size: 0.55rem; padding: 0 0.3rem; border-radius: 2px;
  font-weight: 600;
}
.calcol-det-item .cd-type.num { color: var(--blue); border: 1px solid var(--blue); opacity: 0.6; }
.calcol-det-item .cd-type.cat { color: var(--green); border: 1px solid var(--green); opacity: 0.6; }
.calcol-preview-table {
  flex: 1;
  overflow: auto;
  min-height: 0;
  padding: 0.4rem 0.7rem;
}
.calcol-preview-table table {
  width: 100%; border-collapse: collapse; font-size: 0.68rem;
  font-variant-numeric: tabular-nums;
}
.calcol-preview-table th {
  text-align: left; padding: 0.2rem 0.4rem;
  color: var(--fg-dim); font-weight: 600; font-size: 0.6rem;
  border-bottom: 1px solid var(--border);
  position: sticky; top: 0; background: var(--bg1); z-index: 1;
}
.calcol-preview-table td {
  padding: 0.15rem 0.4rem;
  border-bottom: 1px solid var(--bg2);
  color: var(--fg);
  max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.calcol-preview-table .pv-err { color: var(--red); font-style: italic; }
.calcol-empty-hint {
  color: var(--fg-dim); font-size: 0.68rem; opacity: 0.5;
}

/* Mobile: stack vertically */
@media (max-width: 700px) {
  .calcol-layout { flex-direction: column; }
  .calcol-sidebar {
    width: 100%; border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: 30vh;
  }
  .calcol-results {
    width: 100%; border-left: none;
    border-top: 1px solid var(--border);
    max-height: 35vh;
  }
}

/* Shared calcol styles used by other tabs */
.calcol-tag {
  font-size: 0.55rem;
  color: var(--amber);
  font-weight: 600;
  margin-left: 0.3rem;
  vertical-align: super;
}
.stats tr.calcol-row { background: rgba(184, 115, 51, 0.05); }

/* Expression autocomplete (generic — used by filter) */
.expr-ac-wrap { position: relative; }
.expr-ac-wrap > textarea,
.expr-ac-wrap > input[type="text"] { width: 100%; box-sizing: border-box; }
.expr-ac {
  display: none;
  position: absolute;
  left: 0;
  bottom: 100%;
  max-height: 180px;
  overflow-y: auto;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 3px;
  z-index: 30;
  min-width: 200px;
  box-shadow: 0 -2px 8px rgba(0,0,0,0.4);
}
.expr-ac.open { display: block; }
.ac-item {
  padding: 0.25rem 0.5rem;
  font-size: 0.68rem;
  cursor: pointer;
  display: flex;
  gap: 0.5rem;
  align-items: center;
}
.ac-item:hover, .ac-item.selected { background: var(--bg1); }
.ac-item .ac-label { color: var(--fg-bright); }
.ac-item .ac-desc { color: var(--fg-dim); font-size: 0.55rem; }
.ac-item.ac-fn .ac-label { color: var(--amber); }
.ac-item.ac-calc .ac-label { color: var(--amber); font-style: italic; }
.expr-error {
  font-size: 0.62rem;
  color: var(--red);
  padding-top: 0.15rem;
  display: none;
  min-height: 0;
}
.expr-error.active { display: block; }

/* Re-analysis overlay */
.reanalysis-overlay {
  position: absolute;
  inset: 0;
  background: rgba(10, 10, 10, 0.75);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 0.8rem;
  z-index: 20;
}
.reanalysis-overlay .re-progress {
  width: 200px;
  height: 4px;
  background: var(--bg2);
  border-radius: 2px;
  overflow: hidden;
}
.reanalysis-overlay .re-bar {
  height: 100%;
  background: var(--amber);
  width: 0%;
  transition: width 0.15s;
}
.reanalysis-overlay .re-label {
  font-size: 0.72rem;
  color: var(--fg-dim);
}
.reanalysis-overlay .re-cancel {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  padding: 0.25rem 0.8rem;
  border-radius: 3px;
  cursor: pointer;
  font-family: var(--mono);
  font-size: 0.65rem;
  margin-top: 0.3rem;
}
.reanalysis-overlay .re-cancel:hover { color: var(--fg-bright); border-color: var(--fg-dim); }

/* File info bar */
.file-info {
  display: flex;
  gap: 0.4rem 1.5rem;
  flex-wrap: wrap;
  font-size: 0.78rem;
}
.file-info .fi-item { display: flex; gap: 0.4rem; }
.file-info .fi-label { color: var(--fg-dim); }
.file-info .fi-value { color: var(--fg-bright); font-weight: 500; }

/* Geometry grid */
.geo-grid {
  display: grid;
  grid-template-columns: auto repeat(3, 1fr);
  gap: 0;
  font-size: 0.78rem;
}
.geo-grid .gh {
  padding: 0.4rem 0.8rem;
  color: var(--fg-dim);
  font-weight: 500;
  border-bottom: 1px solid var(--border);
  text-align: right;
}
.geo-grid .gl {
  padding: 0.4rem 0.8rem;
  color: var(--amber);
  font-weight: 600;
  border-bottom: 1px solid var(--border);
}
.geo-grid .gc {
  padding: 0.4rem 0.8rem;
  text-align: right;
  border-bottom: 1px solid var(--border);
  color: var(--fg);
  font-variant-numeric: tabular-nums;
  cursor: pointer;
  position: relative;
  transition: background 0.15s, color 0.15s;
  user-select: text;
}
.geo-grid .gc:hover {
  background: var(--bg3);
  color: var(--fg-bright);
}
.geo-grid .gc.copied {
  background: var(--amber-glow);
  color: var(--amber);
}
.geo-grid .gc .copy-toast {
  position: absolute;
  top: -1.4rem;
  right: 0.4rem;
  font-size: 0.62rem;
  color: var(--amber);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s;
}
.geo-grid .gc.copied .copy-toast { opacity: 1; }
.copy-table-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  padding: 0.1rem 0.5rem;
  border-radius: 3px;
  font-size: 0.65rem;
  font-family: var(--mono);
  cursor: pointer;
  transition: all 0.15s;
  margin-left: 0.5rem;
}
.copy-table-btn:hover {
  border-color: var(--amber);
  color: var(--amber);
}
.copy-table-btn.copied {
  border-color: var(--green);
  color: var(--green);
}

/* Column Overview */
.section--cols { grid-column: 1 / -1; }
.col-overview-wrap { overflow-x: auto; }
.col-overview { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
.col-overview th { text-align: left; padding: 0.3rem 0.6rem; color: var(--fg-dim); font-weight: 500; border-bottom: 1px solid var(--border); font-size: 0.68rem; text-transform: uppercase; letter-spacing: 0.06em; }
.col-overview td { padding: 0.25rem 0.6rem; border-bottom: 1px solid rgba(255,255,255,0.04); }
.col-overview tr:hover { background: var(--bg2); }
.col-overview .col-name { color: var(--fg-bright); max-width: 14rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.col-overview .col-type { font-size: 0.62rem; font-weight: 600; letter-spacing: 0.06em; }
.col-overview .col-type-num { color: var(--fg-dim); }
.col-overview .col-type-cat { color: var(--blue); }
.col-overview .completeness-track { display: inline-block; width: 3rem; height: 4px; border-radius: 2px; background: var(--bg); vertical-align: middle; }
.col-overview .completeness-bar { display: inline-block; height: 4px; border-radius: 2px; background: var(--amber); vertical-align: middle; }
.col-overview .null-warn { color: var(--red); }

/* Stats table */
.stats-table-wrap { overflow-x: auto; }
table.stats {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.78rem;
  font-variant-numeric: tabular-nums;
}
table.stats th {
  text-align: right;
  padding: 0.4rem 0.6rem;
  color: var(--fg-dim);
  font-weight: 500;
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
  font-size: 0.7rem;
}
table.stats th:first-child { text-align: left; }
table.stats td {
  padding: 0.35rem 0.6rem;
  text-align: right;
  border-bottom: 1px solid var(--bg2);
  white-space: nowrap;
}
table.stats td:first-child {
  text-align: left;
  color: var(--fg-bright);
  font-weight: 500;
}
.cdf-link {
  color: var(--fg-bright);
  text-decoration: none;
  border-bottom: 1px dashed var(--border);
  cursor: pointer;
}
.cdf-link:hover {
  color: var(--amber);
  border-color: var(--amber);
}
.cdf-link.cdf-active {
  color: var(--amber);
  border-color: var(--amber);
  border-bottom-style: solid;
}
table.stats tr:hover td { background: var(--bg2); }
table.stats thead th {
  position: sticky;
  top: 0;
  background: var(--bg1);
  z-index: 2;
}
/* Sticky first column for horizontal scroll */
table.stats th:first-child,
table.stats td:first-child {
  position: sticky;
  left: 0;
  background: var(--bg1);
  z-index: 1;
}
table.stats thead th:first-child {
  z-index: 3;
}
table.stats tr:hover td:first-child { background: var(--bg2); }

/* Categories */
.cdf-modal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 100;
  background: rgba(0,0,0,0.7);
  align-items: center;
  justify-content: center;
}
.cdf-modal.active { display: flex; }
.cdf-modal-inner {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  width: min(90vw, 700px);
  max-height: 85vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.cdf-modal-head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.6rem 1rem;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.04em;
}
.cdf-modal-body {
  padding: 1rem;
  overflow: auto;
}
.cdf-modal-body svg {
  width: 100%;
  height: auto;
}

/* ─── Settings Modal ──────────────────────────────────────────────── */
.settings-modal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 100;
  background: rgba(0,0,0,0.6);
  align-items: center;
  justify-content: center;
}
.settings-modal.active { display: flex; }
.settings-modal-inner {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  width: 90vw;
  max-width: 540px;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.settings-modal-head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.7rem 1rem;
  border-bottom: 1px solid var(--border);
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.04em;
}
.settings-modal-body {
  padding: 0.8rem 1rem;
  overflow-y: auto;
  flex: 1;
}
.settings-section {
  margin-bottom: 1.2rem;
}
.settings-section-title {
  font-size: 0.68rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.5rem;
  font-weight: 600;
}
.settings-theme-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}
.settings-swatch {
  background: none;
  border: 2px solid var(--border);
  border-radius: 4px;
  padding: 0.35rem;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  min-width: 64px;
}
.settings-swatch:hover { border-color: var(--fg-dim); }
.settings-swatch.selected { border-color: var(--amber); }
.settings-swatch-colors {
  display: flex;
  gap: 2px;
  border-radius: 2px;
  overflow: hidden;
}
.settings-swatch-colors > div {
  width: 14px;
  height: 20px;
}
.settings-swatch-name {
  font-size: 0.58rem;
  color: var(--fg-dim);
  font-family: var(--mono);
  white-space: nowrap;
}
.settings-swatch.selected .settings-swatch-name { color: var(--amber); }
.settings-custom-details {
  margin-top: 0.6rem;
}
.settings-custom-details summary {
  font-size: 0.65rem;
  color: var(--fg-dim);
  cursor: pointer;
  font-family: var(--mono);
}
.settings-custom-details summary:hover { color: var(--fg-bright); }
.settings-custom-themes {
  margin-top: 0.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}
.settings-custom-slot label {
  font-size: 0.62rem;
  color: var(--fg-dim);
  display: block;
  margin-bottom: 0.2rem;
  font-family: var(--mono);
}
.settings-custom-input {
  width: 100%;
  background: var(--bg1);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.4rem;
  font-family: var(--mono);
  font-size: 0.62rem;
  resize: vertical;
}
.settings-custom-input:focus { border-color: var(--amber); outline: none; }
.settings-custom-actions {
  display: flex;
  gap: 0.4rem;
  margin-top: 0.3rem;
}
.settings-custom-actions button {
  font-size: 0.62rem;
  font-family: var(--mono);
  padding: 0.15rem 0.5rem;
  border-radius: 3px;
  cursor: pointer;
  border: 1px solid var(--border);
  background: none;
  color: var(--fg-dim);
}
.settings-custom-actions button:hover { color: var(--amber); border-color: var(--amber); }
.settings-preset-btns {
  display: flex;
  gap: 0.3rem;
  flex-wrap: wrap;
}
.settings-preset-btn {
  font-size: 0.65rem;
  font-family: var(--mono);
  padding: 0.2rem 0.5rem;
  border-radius: 3px;
  cursor: pointer;
  border: 1px solid var(--border);
  background: none;
  color: var(--fg-dim);
}
.settings-preset-btn:hover { color: var(--fg-bright); border-color: var(--fg-dim); }
.settings-preset-btn.active { color: var(--amber); border-color: var(--amber); background: var(--amber-glow); }
.settings-custom-pct {
  width: 100%;
  margin-top: 0.4rem;
  background: var(--bg1);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.4rem;
  font-family: var(--mono);
  font-size: 0.65rem;
}
.settings-custom-pct:focus { border-color: var(--amber); outline: none; }
.settings-sigfigs-row {
  display: flex;
  align-items: center;
  gap: 0.6rem;
}
.settings-sigfigs-row label {
  font-size: 0.68rem;
  color: var(--fg-dim);
  font-family: var(--mono);
}
.settings-sigfigs-row select {
  background: var(--bg1);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.4rem;
  font-family: var(--mono);
  font-size: 0.65rem;
}
.settings-cache-loading {
  font-size: 0.65rem;
  color: var(--fg-dim);
}
.settings-cache-empty {
  font-size: 0.65rem;
  color: var(--fg-dim);
}
.settings-cache-summary {
  font-size: 0.68rem;
  color: var(--fg);
  margin-bottom: 0.4rem;
}
.settings-cache-list {
  max-height: 150px;
  overflow-y: auto;
  border: 1px solid var(--border);
  border-radius: 3px;
  margin-bottom: 0.4rem;
}
.settings-cache-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0.5rem;
  border-bottom: 1px solid var(--bg2);
  font-size: 0.62rem;
}
.settings-cache-item:last-child { border-bottom: none; }
.settings-cache-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--fg);
}
.settings-cache-size {
  color: var(--fg-dim);
  flex-shrink: 0;
}
.settings-cache-del {
  background: none;
  border: none;
  color: var(--fg-dim);
  cursor: pointer;
  font-size: 0.7rem;
  padding: 0 0.2rem;
  flex-shrink: 0;
}
.settings-cache-del:hover { color: var(--red); }
.settings-cache-clear-all {
  font-size: 0.62rem;
  font-family: var(--mono);
  padding: 0.2rem 0.5rem;
  border-radius: 3px;
  cursor: pointer;
  border: 1px solid var(--border);
  background: none;
  color: var(--fg-dim);
}
.settings-cache-clear-all:hover { color: var(--red); border-color: var(--red); }
.cdf-stats {
  display: flex;
  gap: 1.5rem;
  flex-wrap: wrap;
  font-size: 0.7rem;
  color: var(--fg-dim);
  margin-top: 0.8rem;
  padding-top: 0.6rem;
  border-top: 1px solid var(--border);
}
.cdf-stats span { white-space: nowrap; }
.cdf-stats strong { color: var(--fg-bright); }
/* Categories tab — sidebar + main layout */
#panelCategories.active { display: flex; flex-direction: column; }
.cat-body {
  display: flex;
  flex: 1;
  min-height: 0;
}
.cat-sidebar {
  width: 260px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg1);
}
.cat-sidebar-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.cat-sidebar-section--grow {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
}
.cat-sidebar-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.cat-col-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
}
.cat-col-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.cat-col-search:focus { outline: none; border-color: var(--amber); }
.cat-col-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.35rem 0.7rem;
  border-bottom: 1px solid var(--bg2);
  font-size: 0.7rem;
  cursor: pointer;
  color: var(--fg);
  transition: background 0.1s;
}
.cat-col-item:hover { background: var(--bg2); }
.cat-col-item.active {
  background: var(--amber-glow);
  border-left: 2px solid var(--amber);
  color: var(--fg-bright);
}
.cat-col-item .col-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.cat-col-item .col-count {
  color: var(--fg-dim);
  font-size: 0.6rem;
  flex-shrink: 0;
}
.cat-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  position: relative;
}
.cat-toolbar {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.4rem 0.8rem;
  border-bottom: 1px solid var(--border);
  background: var(--bg1);
  flex-shrink: 0;
  flex-wrap: wrap;
}
.cat-toolbar-title {
  font-size: 0.82rem;
  font-weight: 600;
  color: var(--fg-bright);
  margin-right: auto;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.cat-sort-group {
  display: flex;
  gap: 0;
}
.cat-sort-btn {
  font-size: 0.6rem;
  font-family: var(--mono);
  padding: 0.15rem 0.45rem;
  border: 1px solid var(--border);
  background: none;
  color: var(--fg-dim);
  cursor: pointer;
}
.cat-sort-btn:first-child { border-radius: 3px 0 0 3px; }
.cat-sort-btn:last-child { border-radius: 0 3px 3px 0; }
.cat-sort-btn + .cat-sort-btn { border-left: 0; }
.cat-sort-btn.active {
  background: var(--amber);
  color: var(--bg);
  border-color: var(--amber);
}
.cat-sort-btn:hover:not(.active) { color: var(--fg-bright); border-color: var(--fg-dim); }
.cat-copy-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  font-size: 0.6rem;
  font-family: var(--mono);
  padding: 0.15rem 0.45rem;
  border-radius: 3px;
  cursor: pointer;
}
.cat-copy-btn:hover { color: var(--amber); border-color: var(--amber); }
.cat-main-content {
  flex: 1;
  overflow-y: auto;
  padding: 0.8rem;
}
.cat-empty {
  color: var(--fg-dim);
  font-size: 0.78rem;
  padding: 2rem;
  text-align: center;
  opacity: 0.6;
}
/* Bar chart */
.cat-chart {
  margin-bottom: 0.8rem;
}
.cat-chart svg { width: 100%; display: block; }
.cat-chart-toggle {
  text-align: center;
  font-size: 0.65rem;
  color: var(--amber);
  cursor: pointer;
  padding: 0.2rem;
  user-select: none;
}
.cat-chart-toggle:hover { text-decoration: underline; }
/* Value table */
.cat-value-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  margin-bottom: 0.4rem;
}
.cat-value-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.cat-value-search:focus { outline: none; border-color: var(--amber); }
table.cat-values {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  font-size: 0.72rem;
  font-variant-numeric: tabular-nums;
}
table.cat-values thead th {
  position: sticky;
  top: 0;
  background: var(--bg1);
  padding: 0.25rem 0.5rem;
  text-align: left;
  font-size: 0.6rem;
  text-transform: uppercase;
  color: var(--fg-dim);
  letter-spacing: 0.05em;
  border-bottom: 1px solid var(--border);
  z-index: 2;
}
table.cat-values td {
  padding: 0.22rem 0.5rem;
  border-bottom: 1px solid var(--bg2);
  position: relative;
  z-index: 1;
}
table.cat-values tr:hover td { background: var(--bg2); }
table.cat-values tr.active td { background: var(--amber-glow); }
table.cat-values tr {
  position: relative;
}
table.cat-values tr::before {
  content: '';
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: var(--bar, 0%);
  background: rgba(255, 255, 255, 0.05);
  pointer-events: none;
  z-index: 0;
}
table.cat-values td.cat-drag-cell {
  width: 20px;
  text-align: center;
  padding: 0.22rem 0.2rem;
  cursor: grab;
  color: var(--fg-dim);
  font-size: 0.6rem;
  user-select: none;
}
table.cat-values td.cat-drag-cell:active { cursor: grabbing; }
.cat-drag-hidden { display: none; }
table.cat-values tr.dragging { opacity: 0.4; }
table.cat-values tr.drag-over td { border-top: 2px solid var(--amber); }
/* Swatch */
.cat-swatch {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 2px;
  cursor: pointer;
  vertical-align: middle;
  border: 1px solid rgba(255,255,255,0.15);
  flex-shrink: 0;
}
.cat-swatch:hover { border-color: var(--amber); }
table.cat-values td.cat-swatch-cell {
  width: 24px;
  text-align: center;
  padding: 0.22rem 0.3rem;
}
/* Checkbox */
table.cat-values td.cat-cb-cell {
  width: 28px;
  text-align: center;
  padding-right: 0;
}
table.cat-values input[type="checkbox"] {
  appearance: none;
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border: 1px solid var(--border);
  border-radius: 2px;
  background: var(--bg);
  cursor: pointer;
  vertical-align: middle;
  position: relative;
}
table.cat-values input[type="checkbox"]:hover { border-color: var(--amber); }
table.cat-values input[type="checkbox"]:checked {
  background: var(--amber);
  border-color: var(--amber);
}
table.cat-values input[type="checkbox"]:checked::after {
  content: '\2713';
  position: absolute;
  top: -1px;
  left: 1.5px;
  font-size: 0.65rem;
  color: var(--bg);
  font-weight: 700;
}
table.cat-values td.cat-val-cell {
  color: var(--fg);
  word-break: break-all;
}
table.cat-values td.cat-count-cell {
  text-align: right;
  color: var(--fg-dim);
  white-space: nowrap;
}
table.cat-values td.cat-pct-cell {
  text-align: right;
  color: var(--fg-dim);
  white-space: nowrap;
  width: 55px;
}
/* Color picker popover */
.cat-color-picker {
  display: none;
  position: absolute;
  z-index: 100;
  background: var(--bg1);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 0.5rem;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
  width: 175px;
}
.cat-color-picker.open { display: block; }
.cat-color-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 4px;
  margin-bottom: 0.4rem;
}
.cat-color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 3px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: border-color 0.1s;
}
.cat-color-swatch:hover { border-color: var(--fg-bright); }
.cat-color-swatch.selected { border-color: var(--amber); }
.cat-hex-input {
  width: 100%;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.4rem;
  font-family: var(--mono);
  font-size: 0.68rem;
}
.cat-hex-input:focus { outline: none; border-color: var(--amber); }
/* Responsive */
@media (max-width: 700px) {
  .cat-body { flex-direction: column; }
  .cat-sidebar {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: 180px;
  }
  .cat-sidebar-section--grow { max-height: 120px; }
}

/* StatsCat */
#panelStatsCat.active { display: flex; flex-direction: column; }
.statscat-body {
  display: flex;
  flex: 1;
  min-height: 0;
}
.statscat-sidebar {
  width: 260px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg1);
}
.statscat-sidebar-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.statscat-sidebar-section--grow {
  flex: 1;
  min-height: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
}
.statscat-sidebar-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
}
.statscat-select {
  font-family: var(--mono);
  font-size: 0.72rem;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.5rem;
  cursor: pointer;
  width: 100%;
}
.statscat-select:focus { border-color: var(--amber); outline: none; }
.statscat-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  margin-bottom: 0.3rem;
}
.statscat-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.statscat-search:focus { outline: none; border-color: var(--amber); }
.statscat-var-list, .statscat-group-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.statscat-var-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.3rem 0.7rem;
  border-bottom: 1px solid var(--bg2);
  font-size: 0.7rem;
  cursor: pointer;
  color: var(--fg);
  transition: background 0.1s;
}
.statscat-var-item:hover { background: var(--bg2); }
.statscat-var-item.active {
  background: var(--amber-glow);
  border-left: 2px solid var(--amber);
  color: var(--fg-bright);
}
.statscat-var-item input[type="checkbox"] { flex-shrink: 0; margin: 0; cursor: pointer; }
.statscat-var-item .var-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.statscat-var-item .calcol-tag { margin-left: 0.3rem; }
.statscat-var-item.unchecked { opacity: 0.4; }
.statscat-group-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.25rem 0.7rem;
  font-size: 0.7rem;
  border-bottom: 1px solid var(--bg2);
}
.statscat-group-item label {
  flex: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.4rem;
  min-width: 0;
}
.statscat-group-item .gname {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}
.statscat-group-item .gcount {
  color: var(--fg-dim);
  font-size: 0.6rem;
  flex-shrink: 0;
}
.statscat-group-actions {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  margin-bottom: 0.3rem;
}
.statscat-group-actions button {
  font-size: 0.6rem;
  background: none;
  border: none;
  color: var(--blue);
  cursor: pointer;
  font-family: var(--mono);
  padding: 0;
}
.statscat-group-actions button:hover { text-decoration: underline; }
.statscat-content {
  flex: 1;
  overflow-y: auto;
  padding: 1rem 1.2rem;
  min-width: 0;
}
.statscat-empty {
  color: var(--fg-dim);
  font-size: 0.78rem;
  padding: 2rem;
  text-align: center;
  opacity: 0.6;
}
.statscat-table-wrap {
  overflow-x: auto;
  margin-bottom: 1rem;
}
.statscat-copy-btn {
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg2);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.6rem;
  cursor: pointer;
  margin-bottom: 0.5rem;
}
.statscat-copy-btn:hover { color: var(--fg-bright); border-color: var(--amber); }
.statscat-cdf-plot svg {
  width: 100%;
  height: auto;
  max-height: 450px;
}
.statscat-var-item .var-type-tag {
  font-size: 0.55rem;
  padding: 0 0.3rem;
  border-radius: 2px;
  font-weight: 600;
  flex-shrink: 0;
}
.statscat-var-item .var-type-tag.num { color: var(--blue); border: 1px solid var(--blue); opacity: 0.5; }
.statscat-var-item .var-type-tag.cat { color: var(--green); border: 1px solid var(--green); opacity: 0.5; }
.statscat-filter-toggle {
  font-size: 0.55rem;
  padding: 0.05rem 0.4rem;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: transparent;
  color: var(--fg-dim);
  cursor: pointer;
  margin-left: 0.5rem;
  vertical-align: middle;
}
.statscat-filter-toggle.active { color: var(--amber); border-color: var(--amber); }
.statscat-cdf-toolbar {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  flex-wrap: wrap;
  margin-bottom: 0.5rem;
  font-size: 0.65rem;
}
.statscat-cdf-toolbar .tb-group {
  display: flex;
  align-items: center;
  gap: 0.3rem;
}
.statscat-cdf-toolbar button {
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg2);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.15rem 0.5rem;
  cursor: pointer;
}
.statscat-cdf-toolbar button:hover { color: var(--fg-bright); border-color: var(--amber); }
.statscat-cdf-toolbar button.active { color: var(--amber); border-color: var(--amber); background: var(--amber-glow); }
.statscat-cdf-toolbar input[type="number"] {
  width: 70px;
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.15rem 0.3rem;
}
.statscat-cdf-toolbar input[type="number"]:focus { border-color: var(--amber); outline: none; }
.statscat-cdf-toolbar label { color: var(--fg-dim); cursor: pointer; display: flex; align-items: center; gap: 0.2rem; }
.statscat-crosstab-mode {
  display: flex;
  gap: 0;
  margin-bottom: 0.5rem;
}
.statscat-crosstab-mode button {
  font-family: var(--mono);
  font-size: 0.62rem;
  background: var(--bg2);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  padding: 0.2rem 0.6rem;
  cursor: pointer;
}
.statscat-crosstab-mode button:first-child { border-radius: 3px 0 0 3px; }
.statscat-crosstab-mode button:last-child { border-radius: 0 3px 3px 0; }
.statscat-crosstab-mode button + button { border-left: none; }
.statscat-crosstab-mode button.active { color: var(--amber); border-color: var(--amber); background: var(--amber-glow); }
@media (max-width: 700px) {
  .statscat-body { flex-direction: column; }
  .statscat-sidebar {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: none;
    overflow-y: auto;
  }
  .statscat-sidebar-section--grow {
    max-height: none;
    overflow: hidden;
  }
  .statscat-sidebar-title {
    cursor: pointer;
    user-select: none;
  }
  .statscat-sidebar-title::after {
    content: ' \25BE';
    font-size: 0.6em;
  }
  .statscat-sidebar-section--grow.collapsed {
    flex: none;
  }
  .statscat-sidebar-section--grow.collapsed > *:not(.statscat-sidebar-title) {
    display: none;
  }
  .statscat-sidebar-section--grow.collapsed .statscat-sidebar-title::after {
    content: ' \25B8';
  }
}

/* Export */
#panelExport.active { display: flex; flex-direction: column; height: calc(100vh - 100px); }
.export-body {
  display: flex; flex: 1; min-height: 0;
}
.export-sidebar {
  width: 260px; min-width: 260px; display: flex; flex-direction: column;
  border-right: 1px solid var(--border); background: var(--bg1);
}
.export-sidebar-section {
  padding: 0.6rem 0.75rem 0.4rem; border-bottom: 1px solid var(--border);
}
.export-sidebar-section--grow {
  flex: 1; min-height: 0; overflow-y: auto;
}
.export-sidebar-title {
  font: 600 0.78rem var(--mono); color: var(--fg); margin-bottom: 0.4rem;
  display: flex; align-items: center; gap: 0.5rem;
}
.export-col-search {
  width: 100%; box-sizing: border-box; background: var(--bg); border: 1px solid var(--border);
  color: var(--fg); font: 0.75rem var(--mono); padding: 0.3rem 0.5rem; border-radius: 3px;
  margin-bottom: 0.4rem;
}
.export-col-search:focus { border-color: var(--amber); outline: none; }
.export-sel-btns {
  display: flex; gap: 0.3rem; flex-wrap: wrap;
}
.export-sel-btns button {
  background: var(--bg2); border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.7rem var(--mono); padding: 0.2rem 0.5rem; cursor: pointer; border-radius: 3px;
}
.export-sel-btns button:hover { color: var(--fg-bright); border-color: var(--amber); }
.export-main {
  flex: 1; min-width: 0; display: flex; flex-direction: column;
}
.export-toolbar {
  display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem;
  border-bottom: 1px solid var(--border); background: var(--bg1); flex-wrap: wrap;
}
.export-toolbar .tb-group {
  display: flex; align-items: center; gap: 0.4rem;
}
.export-toolbar label {
  font: 0.75rem var(--mono); color: var(--fg-dim); cursor: pointer;
  display: flex; align-items: center; gap: 0.3rem;
}
.export-label {
  font: 500 0.72rem var(--mono); color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.04em;
}
.export-delim {
  background: var(--bg2); border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.75rem var(--mono); padding: 0.2rem 0.5rem; cursor: pointer; border-radius: 3px;
  min-width: 2rem; text-align: center;
}
.export-delim:hover { color: var(--fg-bright); border-color: var(--amber); }
.export-delim.active { background: var(--amber); color: var(--bg); border-color: var(--amber); }
.export-row-preview {
  font: 0.75rem var(--mono); color: var(--fg-dim);
}
.export-main-content {
  flex: 1; min-height: 0; display: flex; flex-direction: column; padding: 0.75rem;
}
.export-format {
  border: 1px solid var(--border); border-radius: 4px; padding: 0.6rem 0.75rem;
  background: var(--bg1); margin-bottom: 0.75rem;
}
.export-format-row {
  display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; margin-bottom: 0.4rem;
}
.export-format-row:last-child { margin-bottom: 0; }
.export-format-row label {
  font: 0.75rem var(--mono); color: var(--fg-dim); cursor: pointer;
  display: flex; align-items: center; gap: 0.3rem;
}
.export-custom-delim {
  width: 3.5ch; background: var(--bg); border: 1px solid var(--border); color: var(--fg);
  font: 0.75rem var(--mono); padding: 0.2rem 0.3rem; border-radius: 3px; text-align: center;
}
.export-custom-delim:focus { border-color: var(--amber); outline: none; }
.export-quote, .export-ending, .export-decsep {
  background: var(--bg2); border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.75rem var(--mono); padding: 0.2rem 0.5rem; cursor: pointer; border-radius: 3px;
  min-width: 2rem; text-align: center;
}
.export-quote:hover, .export-ending:hover, .export-decsep:hover {
  color: var(--fg-bright); border-color: var(--amber);
}
.export-quote.active, .export-ending.active, .export-decsep.active {
  background: var(--amber); color: var(--bg); border-color: var(--amber);
}
.export-select {
  background: var(--bg); border: 1px solid var(--border); color: var(--fg);
  font: 0.72rem var(--mono); padding: 0.2rem 0.35rem; border-radius: 3px; cursor: pointer;
}
.export-select:focus { border-color: var(--amber); outline: none; }
.export-inline-input {
  width: 5ch; background: var(--bg); border: 1px solid var(--border); color: var(--fg);
  font: 0.72rem var(--mono); padding: 0.2rem 0.35rem; border-radius: 3px; text-align: center;
}
.export-inline-input:focus { border-color: var(--amber); outline: none; }
.export-format-warn {
  font-size: 0.72rem; color: var(--amber); margin-top: 0.35rem; padding: 0.25rem 0;
}
.export-preview {
  border: 1px solid var(--border); border-radius: 4px; margin-bottom: 0.75rem; overflow: hidden;
  flex: 1; min-height: 0; display: flex; flex-direction: column;
}
.export-preview-head {
  display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0.6rem;
  border-bottom: 1px solid var(--border); background: var(--bg1);
}
.export-preview-info {
  font: 0.72rem var(--mono); color: var(--fg-dim); margin-left: auto;
}
.export-preview-pre {
  font: 0.72rem var(--mono); color: var(--fg); background: var(--bg);
  padding: 0.5rem 0.6rem; margin: 0; overflow: auto;
  white-space: pre; line-height: 1.5; flex: 1; min-height: 0;
}
.export-comment-section {
  margin-bottom: 0.75rem;
}
.export-comment-toolbar {
  display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;
}
.export-comment-toolbar button {
  background: var(--bg2); border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.72rem var(--mono); padding: 0.2rem 0.5rem; cursor: pointer; border-radius: 3px;
}
.export-comment-toolbar button:hover { color: var(--fg-bright); border-color: var(--amber); }
.export-comment-textarea {
  width: 100%; box-sizing: border-box; background: var(--bg); border: 1px solid var(--border);
  color: var(--fg); font: 0.75rem var(--mono); padding: 0.4rem 0.5rem; border-radius: 4px;
  resize: vertical;
}
.export-comment-textarea:focus { border-color: var(--amber); outline: none; }
.export-col-list {
  overflow-y: auto;
}
.export-col-item {
  display: flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.6rem;
  border-bottom: 1px solid var(--border); font-size: 0.78rem;
}
.export-col-item:last-child { border-bottom: none; }
.export-col-item:hover { background: var(--bg2); }
.export-col-item.export-col-hidden { display: none; }
.export-col-item input[type="checkbox"] { flex-shrink: 0; cursor: pointer; }
.export-col-item .ecol-name {
  min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  color: var(--fg); flex: 1;
}
.export-col-item .ecol-rename {
  width: 120px; background: var(--bg); border: 1px solid var(--border); color: var(--fg);
  font: 0.72rem var(--mono); padding: 0.15rem 0.4rem; border-radius: 3px;
}
.export-col-item .ecol-rename:focus { border-color: var(--amber); outline: none; }
.export-col-item .ecol-type {
  font-size: 0.65rem; padding: 0.1rem 0.35rem; border-radius: 3px;
  text-transform: uppercase; flex-shrink: 0;
}
.export-col-item .ecol-type.num { color: var(--blue); border: 1px solid var(--blue); opacity: 0.5; }
.export-col-item .ecol-type.cat { color: var(--green); border: 1px solid var(--green); opacity: 0.5; }
.export-col-item .ecol-type.calcol { color: var(--amber); border: 1px solid var(--amber); opacity: 0.5; }
.export-col-item .ecol-grip {
  cursor: grab; flex-shrink: 0; user-select: none;
  width: 8px; height: 14px;
  background-image: radial-gradient(circle, var(--fg-dim) 1px, transparent 1px);
  background-size: 4px 4px; background-position: 0 1px;
  opacity: 0.5;
}
.export-col-item:hover .ecol-grip {
  background-image: radial-gradient(circle, var(--amber) 1px, transparent 1px);
  opacity: 1;
}
.export-col-item.dragging { opacity: 0.25; }
.export-col-item.drag-over-top { box-shadow: 0 -2px 0 0 var(--amber); }
.export-col-item.drag-over-bottom { box-shadow: 0 2px 0 0 var(--amber); }
.export-btn {
  background: var(--amber); color: var(--bg); border: none; font: 600 0.82rem var(--mono);
  padding: 0.5rem 1.4rem; border-radius: 4px; cursor: pointer;
}
.export-btn:hover { filter: brightness(1.15); }
.export-btn:disabled { opacity: 0.4; cursor: not-allowed; }
.export-info { font-size: 0.72rem; color: var(--fg-dim); margin-top: 0.5rem; }
.export-progress { display: none; margin-top: 0.5rem; }
.export-progress.active { display: block; }
.export-progress-label { font-size: 0.72rem; color: var(--fg-dim); margin-bottom: 0.3rem; }
.export-progress-bar {
  height: 4px; background: var(--bg2); border-radius: 2px; overflow: hidden;
}
.export-progress-fill {
  height: 100%; width: 0; background: var(--amber); transition: width 0.15s;
}
@media (max-width: 700px) {
  .export-body { flex-direction: column; }
  .export-sidebar { width: 100%; min-width: 0; border-right: none; border-bottom: 1px solid var(--border); max-height: 40vh; }
  .export-main { min-height: 200px; }
}

/* Swath */
#panelSwath.active { display: flex; flex-direction: column; }
.swath-body {
  display: flex;
  flex: 1;
  min-height: 0;
}
.swath-sidebar {
  width: 260px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg1);
}
.swath-sidebar-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.swath-sidebar-section--grow {
  flex: 1;
  min-height: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
}
.swath-sidebar-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
}
.swath-select {
  font-family: var(--mono);
  font-size: 0.72rem;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.5rem;
  cursor: pointer;
  width: 100%;
}
.swath-select:focus { border-color: var(--amber); outline: none; }
.swath-input {
  font-family: var(--mono);
  font-size: 0.72rem;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.5rem;
  width: 100%;
}
.swath-input:focus { border-color: var(--amber); outline: none; }
.swath-bin-label {
  font-size: 0.6rem; color: var(--fg-dim); margin-top: 0.15rem;
}
.swath-search {
  width: 100%;
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.3rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  margin-bottom: 0.3rem;
}
.swath-search::placeholder { color: var(--fg-dim); opacity: 0.5; }
.swath-search:focus { outline: none; border-color: var(--amber); }
.swath-var-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.swath-var-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.2rem 0.4rem;
  font-size: 0.72rem;
  cursor: pointer;
  border-radius: 2px;
}
.swath-var-item:hover { background: var(--bg2); }
.swath-var-item input { cursor: pointer; accent-color: var(--amber); flex-shrink: 0; }
.swath-var-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.swath-var-btns {
  display: flex; gap: 0.3rem; margin-bottom: 0.3rem;
}
.swath-var-btns button {
  background: none; border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.6rem var(--mono); padding: 0.1rem 0.4rem; border-radius: 2px; cursor: pointer;
}
.swath-var-btns button:hover { border-color: var(--fg-dim); color: var(--fg); }
.swath-generate {
  background: var(--amber); color: var(--bg); border: none;
  padding: 0.4rem 1rem; border-radius: 3px; cursor: pointer;
  font: 600 0.75rem var(--mono); width: 100%; white-space: nowrap;
}
.swath-generate:hover { filter: brightness(1.15); }
.swath-generate:disabled { opacity: 0.4; cursor: not-allowed; }
.swath-progress { display: none; margin-top: 0.4rem; }
.swath-progress.active { display: block; }
.swath-progress-bar { height: 4px; background: var(--bg2); border-radius: 2px; overflow: hidden; }
.swath-progress-fill { height: 100%; width: 0; background: var(--amber); transition: width 0.15s; }
.swath-progress-label { font-size: 0.62rem; color: var(--fg-dim); margin-top: 0.2rem; }
.swath-content {
  flex: 1;
  min-width: 0;
  overflow-y: auto;
  padding: 1rem;
}
.swath-chart-card {
  margin-bottom: 1.5rem;
}
.swath-chart-card svg { width: 100%; height: auto; max-height: 500px; }
.swath-hint { color: var(--fg-dim); font-size: 0.78rem; padding: 2rem; text-align: center; opacity: 0.5; }
@media (max-width: 700px) {
  .swath-body { flex-direction: column; }
  .swath-sidebar {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: none;
    overflow-y: auto;
  }
}

#panelGt.active { display: flex; flex-direction: column; }
#panelStats.active { display: flex; flex-direction: column; }

/* GT (Grade-Tonnage) */
.gt-body {
  display: flex;
  flex: 1;
  min-height: 0;
}
.gt-sidebar {
  width: 260px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  background: var(--bg1);
}
.gt-sidebar-section {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.gt-sidebar-title {
  font-size: 0.62rem;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 0.3rem;
}
.gt-select {
  font-family: var(--mono);
  font-size: 0.72rem;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.5rem;
  cursor: pointer;
  width: 100%;
}
.gt-select:focus { border-color: var(--amber); outline: none; }
.gt-input {
  font-family: var(--mono);
  font-size: 0.72rem;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.5rem;
  width: 100%;
  box-sizing: border-box;
}
.gt-input:focus { border-color: var(--amber); outline: none; }
.gt-vol-display {
  font-size: 0.65rem; color: var(--fg-dim); margin-bottom: 0.2rem;
}
.gt-radio-label {
  font-size: 0.68rem; color: var(--fg); margin-right: 0.7rem; cursor: pointer;
}
.gt-radio-label input { accent-color: var(--amber); cursor: pointer; margin-right: 0.2rem; }
.gt-generate {
  background: var(--amber); color: var(--bg); border: none;
  padding: 0.4rem 1rem; border-radius: 3px; cursor: pointer;
  font: 600 0.75rem var(--mono); width: 100%; white-space: nowrap;
}
.gt-generate:hover { filter: brightness(1.15); }
.gt-generate:disabled { opacity: 0.4; cursor: not-allowed; }
.gt-progress { display: none; margin-top: 0.4rem; }
.gt-progress.active { display: block; }
.gt-progress-bar { height: 4px; background: var(--bg2); border-radius: 2px; overflow: hidden; }
.gt-progress-fill { height: 100%; width: 0; background: var(--amber); transition: width 0.15s; }
.gt-progress-label { font-size: 0.62rem; color: var(--fg-dim); margin-top: 0.2rem; }
.gt-content {
  flex: 1;
  min-width: 0;
  overflow-y: auto;
  padding: 1rem;
}
.gt-hint { color: var(--fg-dim); font-size: 0.78rem; padding: 2rem; text-align: center; opacity: 0.5; }
.gt-toolbar {
  display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.8rem;
}
.gt-copy-btn {
  background: none; border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.65rem var(--mono); padding: 0.2rem 0.6rem; border-radius: 3px; cursor: pointer;
}
.gt-copy-btn:hover { border-color: var(--fg-dim); color: var(--fg); }
.gt-elapsed { font-size: 0.6rem; color: var(--fg-dim); margin-left: auto; }
.gt-chart-wrap { margin-bottom: 1rem; }
.gt-chart-wrap svg { width: 100%; height: auto; max-height: 500px; }
.gt-table-wrap { overflow-x: auto; }
.gt-table {
  width: 100%; border-collapse: collapse; font-size: 0.72rem;
}
.gt-table th {
  text-align: left; padding: 0.35rem 0.6rem; border-bottom: 2px solid var(--border);
  color: var(--fg-dim); font-weight: 600; font-size: 0.65rem; text-transform: uppercase;
  letter-spacing: 0.04em; white-space: nowrap;
}
.gt-table td {
  padding: 0.25rem 0.6rem; border-bottom: 1px solid var(--bg3);
  color: var(--fg); font-variant-numeric: tabular-nums;
}
.gt-table tbody tr:hover { background: var(--bg2); }
.gt-sidebar-section--grow {
  padding: 0.5rem 0.7rem;
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  flex: 1;
  min-height: 0;
}
.gt-var-list {
  flex: 1;
  overflow-y: auto;
  min-height: 60px;
  max-height: 200px;
}
.gt-var-item {
  display: flex;
  align-items: center;
  gap: 0.3rem;
  padding: 0.15rem 0.2rem;
  font-size: 0.7rem;
  cursor: pointer;
}
.gt-var-item:hover { background: var(--bg2); }
.gt-var-item input { cursor: pointer; accent-color: var(--amber); flex-shrink: 0; }
.gt-var-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; }
.gt-var-unit {
  margin-left: auto;
  font: 0.62rem var(--mono);
  background: var(--bg);
  color: var(--fg-dim);
  border: 1px solid var(--border);
  border-radius: 2px;
  padding: 0 0.2rem;
  cursor: pointer;
  max-width: 50px;
  flex-shrink: 0;
}
.gt-var-search { margin-bottom: 0.3rem; padding: 0.15rem 0.4rem !important; font-size: 0.65rem !important; }
.gt-group-values { margin-top: 0.4rem; }
.gt-group-values .gt-var-list { max-height: 150px; }
.gt-var-btns {
  display: flex; gap: 0.3rem; margin-bottom: 0.3rem;
}
.gt-var-btns button {
  background: none; border: 1px solid var(--border); color: var(--fg-dim);
  font: 0.6rem var(--mono); padding: 0.1rem 0.4rem; border-radius: 2px; cursor: pointer;
}
.gt-var-btns button:hover { border-color: var(--fg-dim); color: var(--fg); }
.gt-chart-title {
  font-size: 0.72rem; color: var(--fg-bright); margin-bottom: 0.4rem; font-weight: 600;
}
.gt-table-section { margin-top: 0.5rem; border: 1px solid var(--border); border-radius: 4px; }
.gt-table-header {
  display: flex; align-items: center; gap: 0.4rem;
  padding: 0.35rem 0.6rem; cursor: pointer; user-select: none;
  font-size: 0.68rem; color: var(--fg-bright); font-weight: 600;
  background: var(--bg1); border-radius: 4px 4px 0 0;
}
.gt-table-header:hover { background: var(--bg2); }
.gt-table-toggle { font-size: 0.55rem; color: var(--fg-dim); width: 0.7rem; text-align: center; }
.gt-table-header .gt-copy-btn { margin-left: auto; }
@media (max-width: 700px) {
  .gt-body { flex-direction: column; }
  .gt-sidebar {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: none;
    overflow-y: auto;
  }
}

/* Section */
#panelSection.active { display: block; }
.section-config-bar {
  display: flex; gap: 0.6rem; flex-wrap: wrap; align-items: flex-end;
  padding: 0.6rem 1rem; border-bottom: 1px solid var(--border);
}
.section-config-bar label {
  display: flex; flex-direction: column; gap: 0.2rem;
  font-size: 0.65rem; color: var(--fg-dim); font-weight: 600; letter-spacing: 0.04em;
}
.section-config-bar select, .section-config-bar input[type="number"] {
  background: var(--bg); color: var(--fg); border: 1px solid var(--border);
  border-radius: 3px; padding: 0.25rem 0.4rem; font: 0.72rem var(--mono);
}
.section-config-bar select:focus, .section-config-bar input:focus { border-color: var(--amber); outline: none; }
.section-config-bar input[type="number"] { width: 90px; }
.section-config-bar input[type="range"] { width: 120px; accent-color: var(--amber); }
.section-slice-val { font-size: 0.72rem; color: var(--fg-bright); min-width: 60px; }
.section-local-filter {
  flex: 1; min-width: 120px;
}
.section-local-filter input {
  width: 100%; background: var(--bg); color: var(--fg-bright); border: 1px solid var(--border);
  border-radius: 3px; padding: 0.25rem 0.5rem; font: 0.72rem var(--mono);
}
.section-local-filter input:focus { border-color: var(--amber); outline: none; }
.section-local-filter input::placeholder { color: var(--fg-dim); opacity: 0.5; }
.section-show-swath {
  display: flex; align-items: center; gap: 0.3rem;
  font-size: 0.65rem; color: var(--fg-dim); cursor: pointer;
}
.section-show-swath input { cursor: pointer; accent-color: var(--amber); }
.section-render-btn {
  background: var(--amber); color: var(--bg); border: none;
  padding: 0.35rem 1rem; border-radius: 3px; cursor: pointer;
  font: 600 0.75rem var(--mono); white-space: nowrap;
}
.section-render-btn:hover { filter: brightness(1.15); }
.section-render-btn:disabled { opacity: 0.4; cursor: not-allowed; }
.section-reset-btn {
  background: none; border: 1px solid var(--border); color: var(--fg-dim);
  padding: 0.3rem 0.6rem; border-radius: 3px; cursor: pointer;
  font: 0.68rem var(--mono); white-space: nowrap;
}
.section-reset-btn:hover { border-color: var(--fg-dim); color: var(--fg); }
.section-canvas-wrap {
  position: relative; flex: 1; min-height: 300px; background: var(--bg);
  overflow: hidden;
}
.section-canvas-wrap canvas { display: block; width: 100%; height: 100%; }
.section-colorbar {
  position: absolute; right: 12px; top: 12px; width: 20px; height: 180px;
  border: 1px solid var(--border); border-radius: 2px; pointer-events: none;
}
.section-colorbar canvas { width: 100%; height: 100%; display: block; border-radius: 2px; }
.section-colorbar-labels {
  position: absolute; right: 36px; top: 12px; height: 180px;
  display: flex; flex-direction: column; justify-content: space-between;
  font-size: 0.6rem; color: var(--fg-dim); pointer-events: none;
}
.section-tooltip {
  position: absolute; display: none; background: var(--bg1); border: 1px solid var(--border);
  border-radius: 3px; padding: 0.3rem 0.5rem; font-size: 0.65rem; color: var(--fg-bright);
  pointer-events: none; white-space: nowrap; z-index: 10;
}
.section-info {
  position: absolute; left: 12px; bottom: 12px; font-size: 0.62rem;
  color: var(--fg-dim); pointer-events: none;
}
.section-progress { display: none; padding: 1rem; }
.section-progress.active { display: block; }
.section-progress-label { font-size: 0.72rem; color: var(--fg-dim); margin-bottom: 0.3rem; }
.section-progress-bar { height: 4px; background: var(--bg2); border-radius: 2px; overflow: hidden; }
.section-progress-fill { height: 100%; width: 0; background: var(--amber); transition: width 0.15s; }
.section-hint { color: var(--fg-dim); font-size: 0.78rem; padding: 2rem; text-align: center; opacity: 0.5; }
#panelSection .panel-section-body {
  display: flex; flex-direction: column; height: calc(100vh - 160px);
}

/* Action bar — Analyze + Filter, between toolbar and tabs */
.action-bar {
  display: none;
  flex-shrink: 0;
  background: var(--bg1);
  border-bottom: 1px solid var(--border);
}
.action-bar.active { display: block; }
.action-bar-inner {
  padding: 0 1rem;
  display: flex;
  gap: 0.75rem;
  align-items: center;
  height: 2rem;
}
.execute-btn {
  background: var(--amber);
  color: var(--bg);
  border: none;
  padding: 0.25rem 0.9rem;
  border-radius: 3px;
  cursor: pointer;
  font-family: var(--mono);
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 0.04em;
  flex-shrink: 0;
  white-space: nowrap;
}
.execute-btn:hover { opacity: 0.9; }
.execute-btn.clean {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
}
.execute-btn.clean:hover { border-color: var(--fg-dim); color: var(--fg); }
.filter-section { display: none; flex: 1; min-width: 0; }
.filter-section.active { display: flex; justify-content: flex-end; }
.filter-editor-body {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}
.filter-editor-body .expr-ac-wrap { width: 22rem; flex-shrink: 1; min-width: 8rem; }
.filter-label {
  font-size: 0.68rem;
  font-weight: 600;
  color: var(--amber);
  letter-spacing: 0.08em;
  flex-shrink: 0;
}
.filter-expr-input {
  background: var(--bg);
  color: var(--fg-bright);
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.2rem 0.5rem;
  font-family: var(--mono);
  font-size: 0.72rem;
  line-height: 1.3;
  resize: none;
  margin: 0;
  vertical-align: middle;
  min-height: unset;
  max-height: 4rem;
}
.filter-expr-input:focus {
  outline: none;
  border-color: var(--amber);
}
.filter-expr-input::placeholder { color: var(--fg-dim); opacity: 0.5; }
.filter-btn-group { display: flex; gap: 0.4rem; flex-shrink: 0; }
.filter-apply-btn {
  background: var(--amber);
  color: var(--bg);
  border: none;
  padding: 0.2rem 0.6rem;
  border-radius: 3px;
  cursor: pointer;
  font-family: var(--mono);
  font-size: 0.66rem;
  font-weight: 600;
}
.filter-apply-btn:hover { opacity: 0.9; }
.filter-apply-btn:disabled { opacity: 0.4; cursor: default; }
.filter-clear-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--fg-dim);
  padding: 0.2rem 0.5rem;
  border-radius: 3px;
  cursor: pointer;
  font-family: var(--mono);
  font-size: 0.66rem;
}
.filter-clear-btn:hover { border-color: var(--fg-dim); color: var(--fg); }
.filter-error {
  padding: 0;
  font-size: 0.7rem;
  color: var(--red);
  display: none;
}
.filter-error.active { display: block; }

@media (max-width: 700px) {
  .action-bar-inner {
    flex-direction: column;
    align-items: stretch;
    height: auto;
    padding: 0.4rem 0.75rem;
    gap: 0.5rem;
  }
  .execute-btn { text-align: center; }
  .filter-section.active { justify-content: stretch; }
  .filter-editor-body {
    flex-wrap: wrap;
    gap: 0.3rem;
  }
  .filter-editor-body .expr-ac-wrap {
    width: 100%;
    min-width: 0;
    order: 2;
  }
  .filter-label { flex: 1; }
  .filter-btn-group { order: 1; }
}

/* XYZ column selector */
.xyz-config {
  display: flex;
  gap: 1.5rem;
  align-items: center;
  flex-wrap: wrap;
  font-size: 0.78rem;
  margin-bottom: 0.8rem;
}
.xyz-config label {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  color: var(--fg-dim);
}
.xyz-config .axis-label {
  font-weight: 600;
  color: var(--amber-dim);
}
.xyz-config .axis-value {
  color: var(--fg-bright);
}

/* Timing */
.timing { font-size: 0.7rem; color: var(--fg-dim); }

/* Error */
.error-msg {
  color: var(--red);
  background: #f8717115;
  border: 1px solid #f8717140;
  padding: 0.6rem 1rem;
  border-radius: 4px;
  font-size: 0.8rem;
  margin-top: 1rem;
  display: none;
}
.error-msg.active { display: block; }

@media (max-width: 700px) {
  .app { padding: 1rem; }
  .app.has-results { padding: 0; }
  .geo-grid { font-size: 0.7rem; }
  .geo-grid .gc, .geo-grid .gh, .geo-grid .gl { padding: 0.3rem 0.4rem; }
  .about-features { grid-template-columns: 1fr; }
  .landing-footer { flex-direction: column; gap: 0.2rem; text-align: center; }
}

/* Desktop layout */
@media (min-width: 1024px) {
  .app.has-results {
    padding: 0;
  }

  .file-info { gap: 1.5rem; }

  .filter-editor-body { align-items: center; }

  .panel-inner {
    padding: 1.5rem 2rem;
    max-width: 1600px;
  }

  /* Summary panel: two-column layout */
  #panelSummary .panel-inner {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    align-items: start;
  }
}

@media (min-width: 1400px) {
}
</style>
<script>try{var t=JSON.parse(localStorage.getItem('bma:settings')||'{}').theme;if(t&&t!=='default')document.documentElement.setAttribute('data-theme',t)}catch(e){}</script>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>BMA — Block Model Atelier</h1>
      <div class="sub">Stream-parse block model CSVs. Detect geometry, compute statistics.</div>
    </div>
    <svg class="logo-mark" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
      <rect width="64" height="64" rx="8" fill="var(--bg1)"/>
      <defs><clipPath id="lc"><circle cx="300" cy="200" r="220" transform="rotate(15,300,200)"/></clipPath></defs>
      <g opacity="0.4" stroke="var(--fg-dim)" stroke-width="7.8125" fill="none"
         transform="translate(-6.4,6.4) scale(0.128) rotate(15,300,200)" clip-path="url(#lc)">
        <path d="M 300.0 448.5 C 309.8 445.0, 318.9 440.5, 327.3 435.7 C 335.7 430.8, 343.3 425.2, 350.4 419.3 C 357.5 413.4, 363.9 406.9, 369.8 400.1 C 375.7 393.4, 381.0 386.2, 385.7 378.7 C 390.5 371.3, 394.7 363.6, 398.4 355.7 C 402.2 347.7, 405.3 339.5, 408.1 331.2 C 410.8 322.9, 413.1 314.4, 414.9 305.8 C 416.7 297.2, 418.1 288.4, 419.0 279.7 C 420.0 270.9, 420.4 262.0, 420.5 253.1 C 420.6 244.2, 420.3 235.3, 419.6 226.4 C 418.8 217.5, 417.7 208.6, 416.2 199.8 C 414.7 191.0, 412.8 182.2, 410.5 173.5 C 408.2 164.8, 405.5 156.2, 402.5 147.8 C 399.5 139.4, 396.1 131.0, 392.4 122.9 C 388.7 114.8, 384.6 106.8, 380.1 99.1 C 375.7 91.4, 370.9 83.9, 365.8 76.7 C 360.7 69.5, 355.2 62.5, 349.5 55.8 C 343.7 49.2, 337.6 42.8, 331.1 36.9 C 324.7 30.9, 317.9 25.3, 310.9 20.2 C 303.8 15.0, 296.4 10.3, 288.7 6.0 C 281.0 1.8, 272.9 -2.0, 264.6 -5.1 C 256.2 -8.2, 247.6 -10.9, 238.6 -12.7 C 229.7 -14.6, 220.4 -15.9, 210.8 -16.2 C 201.3 -16.6, 191.4 -16.3, 181.3 -14.8 C 171.2 -13.3, 160.8 -11.1, 150.3 -7.4 C 139.8 -3.8, 128.9 0.8, 118.2 7.2 C 107.5 13.6, 96.5 21.1, 86.0 30.7 C 75.6 40.3, 65.0 51.5, 55.7 64.8 C 46.4 78.2, 37.1 93.6, 30.2 110.9 C 23.3 128.1, 17.1 147.9, 14.2 168.4 C 11.3 188.9, 10.3 212.0, 12.7 233.9 C 15.0 255.9, 20.5 279.5, 28.4 300.3 C 36.2 321.2, 47.6 341.8, 59.8 359.2 C 71.9 376.6, 86.8 392.0, 101.3 404.7 C 115.8 417.3, 131.7 427.2, 146.6 435.2 C 161.6 443.1, 176.8 448.3, 191.0 452.2 C 205.2 456.1, 219.0 457.8, 231.9 458.5 C 244.8 459.2, 256.9 458.3, 268.3 456.6 Z"/>
        <path d="M 300.0 448.5 C 294.4 446.5, 289.1 444.2, 284.1 441.7 C 279.0 439.3, 274.1 436.6, 269.5 433.7 C 264.8 430.9, 260.4 427.8, 256.2 424.6 C 252.0 421.4, 248.0 418.0, 244.1 414.5 C 240.3 411.0, 236.7 407.4, 233.3 403.6 C 229.9 399.9, 226.6 396.0, 223.5 392.0 C 220.5 388.0, 217.6 383.9, 214.9 379.7 C 212.2 375.5, 209.6 371.2, 207.3 366.9 C 204.9 362.5, 202.7 358.1, 200.6 353.6 C 198.6 349.1, 196.7 344.5, 194.9 339.8 C 193.2 335.2, 191.6 330.5, 190.2 325.8 C 188.8 321.0, 187.5 316.2, 186.3 311.4 C 185.2 306.6, 184.2 301.7, 183.4 296.8 C 182.5 291.9, 181.8 286.9, 181.2 282.0 C 180.7 277.0, 180.2 272.0, 179.9 267.0 C 179.6 262.0, 179.5 257.0, 179.5 252.0 C 179.4 246.9, 179.5 241.9, 179.8 236.9 C 180.0 231.8, 180.4 226.8, 180.9 221.8 C 181.3 216.7, 182.0 211.7, 182.7 206.7 C 183.5 201.7, 184.3 196.7, 185.3 191.7 C 186.3 186.8, 187.4 181.8, 188.6 176.9 C 189.9 172.0, 191.2 167.1, 192.7 162.2 C 194.2 157.4, 195.8 152.6, 197.5 147.8 C 199.2 143.0, 201.0 138.3, 202.9 133.6 C 204.9 128.9, 206.9 124.3, 209.1 119.7 C 211.2 115.2, 213.5 110.7, 215.9 106.2 C 218.3 101.8, 220.8 97.4, 223.4 93.1 C 226.0 88.8, 228.7 84.6, 231.6 80.5 C 234.4 76.3, 237.3 72.3, 240.4 68.3 C 243.4 64.3, 246.5 60.5, 249.8 56.7 C 253.0 52.9, 256.4 49.2, 259.9 45.7 C 263.3 42.1, 266.9 38.7, 270.6 35.3 C 274.2 32.0, 278.0 28.8, 281.9 25.7 C 285.7 22.6, 289.7 19.7, 293.8 16.9 C 297.9 14.1, 302.1 11.4, 306.3 8.9 C 310.6 6.4, 315.0 4.0, 319.5 1.8 C 324.0 -0.4, 328.6 -2.4, 333.2 -4.3 C 337.9 -6.1, 342.7 -7.8, 347.6 -9.2 C 352.5 -10.7, 357.5 -11.9, 362.5 -13.0 C 367.6 -14.0, 372.8 -14.8, 378.1 -15.4 C 383.3 -16.0, 388.7 -16.3, 394.2 -16.4 C 399.6 -16.4, 405.2 -16.2, 410.8 -15.7 C 416.5 -15.2, 422.2 -14.4, 428.0 -13.3 C 433.8 -12.1, 439.7 -10.7, 445.6 -8.8 C 451.5 -6.9, 457.5 -4.7, 463.6 -2.1 C 469.6 0.6, 475.7 3.6, 481.8 7.2 C 487.9 10.8, 494.0 14.7, 500.1 19.3 C 506.1 23.8, 512.2 28.9, 518.1 34.5 C 524.0 40.2, 529.8 46.4, 535.4 53.2 C 541.0 60.1, 546.5 67.6, 551.6 75.7 C 556.7 83.8, 561.6 92.6, 565.9 102.0 C 570.2 111.4, 574.2 121.5, 577.5 132.1 C 580.7 142.7, 583.5 154.0, 585.3 165.7 C 587.2 177.3, 588.4 189.6, 588.7 202.0 C 588.9 214.3, 588.3 227.2, 586.7 239.8 C 585.1 252.4, 582.5 265.3, 579.0 277.7 C 575.6 290.1, 571.1 302.4, 566.0 314.0 C 560.8 325.7, 554.7 337.0, 548.1 347.4 C 541.6 357.8, 534.2 367.7, 526.6 376.7 C 519.0 385.7, 510.8 393.9, 502.5 401.3 C 494.3 408.7, 485.7 415.3, 477.1 421.1 C 468.6 426.9, 459.9 431.9, 451.4 436.2 C 442.9 440.5, 434.3 444.0, 426.0 447.0 C 417.7 450.0, 409.5 452.2, 401.6 454.0 C 393.6 455.8, 385.9 457.0, 378.3 457.8 C 370.8 458.6, 363.6 458.8, 356.5 458.7 C 349.5 458.6, 342.7 458.1, 336.2 457.2 C 329.7 456.4, 323.4 455.2, 317.4 453.7 Z"/>
        <path d="M 450.2 70.0 C 447.9 74.2, 445.0 78.2, 441.8 81.9 C 438.7 85.6, 435.0 89.1, 431.2 92.4 C 427.3 95.6, 423.1 98.6, 418.6 101.5 C 414.1 104.3, 409.4 106.8, 404.4 109.2 C 399.5 111.6, 394.3 113.7, 388.9 115.7 C 383.6 117.6, 378.0 119.3, 372.4 120.9 C 366.7 122.4, 360.9 123.7, 355.0 124.9 C 349.1 126.0, 343.1 127.0, 337.0 127.7 C 330.9 128.5, 324.8 129.1, 318.6 129.4 C 312.4 129.8, 306.2 130.0, 300.0 130.0 C 293.8 130.0, 287.6 129.8, 281.4 129.4 C 275.2 129.1, 269.1 128.5, 263.0 127.7 C 256.9 127.0, 250.9 126.0, 245.0 124.9 C 239.1 123.7, 233.3 122.4, 227.6 120.9 C 222.0 119.3, 216.4 117.6, 211.1 115.7 C 205.7 113.7, 200.5 111.6, 195.6 109.2 C 190.6 106.8, 185.9 104.3, 181.4 101.5 C 176.9 98.6, 172.7 95.6, 168.8 92.4 C 165.0 89.1, 161.3 85.6, 158.2 81.9 C 155.0 78.2, 152.1 74.2, 149.8 70.0 C 147.4 65.8, 145.4 61.3, 144.1 56.6 C 142.7 51.8, 141.8 46.9, 141.6 41.7 C 141.4 36.5, 141.7 31.0, 142.9 25.4 C 144.1 19.7, 145.9 13.8, 148.7 7.9 C 151.5 1.9, 155.1 -4.3, 159.7 -10.4 C 164.4 -16.4, 169.9 -22.7, 176.6 -28.5 C 183.3 -34.4, 191.0 -40.3, 199.7 -45.4 C 208.4 -50.6, 218.4 -55.5, 228.9 -59.4 C 239.5 -63.3, 251.2 -66.7, 263.0 -68.8 C 274.9 -70.9, 287.7 -72.1, 300.0 -72.1 C 312.3 -72.1, 325.1 -70.9, 337.0 -68.8 C 348.8 -66.7, 360.5 -63.3, 371.1 -59.4 C 381.6 -55.5, 391.6 -50.6, 400.3 -45.4 C 409.0 -40.3, 416.7 -34.4, 423.4 -28.5 C 430.1 -22.7, 435.6 -16.4, 440.3 -10.4 C 444.9 -4.3, 448.5 1.9, 451.3 7.9 C 454.1 13.8, 455.9 19.7, 457.1 25.4 C 458.3 31.0, 458.6 36.5, 458.4 41.7 C 458.2 46.9, 457.3 51.8, 455.9 56.6 Z"/>
        <path d="M 119.0 356.7 C 123.1 355.7, 127.6 354.9, 132.3 354.3 C 137.0 353.6, 142.1 353.1, 147.3 352.7 C 152.5 352.3, 157.9 352.0, 163.6 351.7 C 169.2 351.4, 175.0 351.3, 181.0 351.1 C 187.0 351.0, 193.1 350.9, 199.4 350.9 C 205.7 350.8, 212.1 350.8, 218.6 350.8 C 225.1 350.7, 231.7 350.7, 238.4 350.8 C 245.1 350.8, 251.9 350.8, 258.7 350.8 C 265.5 350.8, 272.4 350.8, 279.3 350.8 C 286.1 350.8, 293.1 350.8, 300.0 350.8 C 306.9 350.8, 313.9 350.8, 320.7 350.8 C 327.6 350.8, 334.5 350.8, 341.3 350.8 C 348.1 350.8, 354.9 350.8, 361.6 350.8 C 368.3 350.7, 374.9 350.7, 381.4 350.8 C 387.9 350.8, 394.3 350.8, 400.6 350.9 C 406.9 350.9, 413.0 351.0, 419.0 351.1 C 425.0 351.3, 430.8 351.4, 436.4 351.7 C 442.1 352.0, 447.5 352.3, 452.7 352.7 C 457.9 353.1, 463.0 353.6, 467.7 354.3 C 472.4 354.9, 476.9 355.7, 481.0 356.7 C 485.2 357.7, 489.1 358.8, 492.5 360.3 C 495.9 361.7, 499.1 363.3, 501.6 365.4 C 504.2 367.5, 506.4 369.8, 507.8 372.7 C 509.3 375.6, 510.3 378.8, 510.3 382.9 C 510.2 386.9, 509.7 391.3, 507.5 396.8 C 505.3 402.2, 502.5 408.4, 497.1 415.5 C 491.8 422.6, 485.4 430.9, 475.4 439.5 C 465.4 448.2, 453.3 458.5, 436.9 467.3 C 420.5 476.2, 399.9 486.5, 377.1 492.5 C 354.3 498.4, 325.7 503.2, 300.0 503.2 C 274.3 503.2, 245.7 498.4, 222.9 492.5 C 200.1 486.5, 179.5 476.2, 163.1 467.3 C 146.7 458.5, 134.6 448.2, 124.6 439.5 C 114.6 430.9, 108.2 422.6, 102.9 415.5 C 97.5 408.4, 94.7 402.2, 92.5 396.8 C 90.3 391.3, 89.8 386.9, 89.7 382.9 C 89.7 378.8, 90.7 375.6, 92.2 372.7 C 93.6 369.8, 95.8 367.5, 98.4 365.4 C 100.9 363.3, 104.1 361.7, 107.5 360.3 Z"/>
        <path d="M 520.0 200.0 C 515.9 202.4, 511.6 204.6, 507.3 206.7 C 502.9 208.8, 498.3 210.8, 493.7 212.7 C 489.0 214.5, 484.2 216.3, 479.3 218.0 C 474.5 219.7, 469.4 221.3, 464.3 222.7 C 459.2 224.2, 454.0 225.6, 448.7 227.0 C 443.4 228.3, 438.0 229.5, 432.5 230.6 C 427.0 231.8, 421.4 232.9, 415.8 233.8 C 410.2 234.8, 404.5 235.7, 398.7 236.5 C 393.0 237.4, 387.1 238.1, 381.3 238.8 C 375.4 239.5, 369.5 240.1, 363.5 240.6 C 357.6 241.1, 351.5 241.5, 345.5 241.9 C 339.5 242.3, 333.4 242.6, 327.4 242.8 C 321.3 243.0, 315.2 243.2, 309.1 243.2 C 303.1 243.3, 296.9 243.3, 290.9 243.2 C 284.8 243.2, 278.7 243.0, 272.6 242.8 C 266.6 242.6, 260.5 242.3, 254.5 241.9 C 248.5 241.5, 242.4 241.1, 236.5 240.6 C 230.5 240.1, 224.6 239.5, 218.7 238.8 C 212.9 238.1, 207.0 237.4, 201.3 236.5 C 195.5 235.7, 189.8 234.8, 184.2 233.8 C 178.6 232.9, 173.0 231.8, 167.5 230.6 C 162.0 229.5, 156.6 228.3, 151.3 227.0 C 146.0 225.6, 140.8 224.2, 135.7 222.7 C 130.6 221.3, 125.5 219.7, 120.7 218.0 C 115.8 216.3, 111.0 214.5, 106.3 212.7 C 101.7 210.8, 97.1 208.8, 92.7 206.7 C 88.4 204.6, 84.1 202.4, 80.0 200.0 C 75.9 197.6, 71.9 195.2, 68.2 192.5 C 64.4 189.9, 60.8 187.1, 57.4 184.1 C 53.9 181.2, 50.7 178.1, 47.7 174.7 C 44.7 171.3, 41.8 167.8, 39.3 163.9 C 36.7 160.0, 34.4 156.0, 32.4 151.5 C 30.4 147.0, 28.6 142.3, 27.4 136.9 C 26.1 131.6, 25.1 126.0, 24.7 119.6 C 24.4 113.1, 24.4 106.3, 25.4 98.3 C 26.5 90.4, 27.9 81.8, 31.2 71.7 C 34.6 61.5, 38.2 50.5, 45.6 37.5 C 53.0 24.4, 60.9 9.5, 75.7 -6.5 C 90.5 -22.5, 107.8 -42.8, 134.6 -58.6 C 161.4 -74.4, 198.2 -94.2, 236.3 -101.3 C 274.5 -108.4, 325.5 -108.4, 363.7 -101.3 C 401.8 -94.2, 438.6 -74.4, 465.4 -58.6 C 492.2 -42.8, 509.5 -22.5, 524.3 -6.5 C 539.1 9.5, 547.0 24.4, 554.4 37.5 C 561.8 50.5, 565.4 61.5, 568.8 71.7 C 572.1 81.8, 573.5 90.4, 574.6 98.3 C 575.6 106.3, 575.6 113.1, 575.3 119.6 C 574.9 126.0, 573.9 131.6, 572.6 136.9 C 571.4 142.3, 569.6 147.0, 567.6 151.5 C 565.6 156.0, 563.3 160.0, 560.7 163.9 C 558.2 167.8, 555.3 171.3, 552.3 174.7 C 549.3 178.1, 546.1 181.2, 542.6 184.1 C 539.2 187.1, 535.6 189.9, 531.8 192.5 Z"/>
      </g>
      <circle cx="32" cy="32" r="28.16" stroke="var(--fg-dim)" stroke-width="1" fill="none" opacity="0.4" transform="rotate(15,32,32)"/>
      <text x="32" y="44" font-family="Georgia,serif" font-size="28" font-weight="bold" fill="var(--amber)" text-anchor="middle" opacity="0.7">GCU</text>
    </svg>
  </header>

  <div class="dropzone" id="dropzone">
    <div class="label">Drop a CSV file here, or <strong>click to browse</strong></div>
    <div class="hint">Supports .csv, .txt, .dat, .zip — streamed, not loaded into memory</div>
    <input type="file" id="fileInput" accept=".csv,.txt,.dat,.CSV,.TXT,.DAT,.zip,.ZIP">
  </div>

  <div class="recent-files" id="recentFiles"></div>

  <div class="about-section">
    <h2>What is this?</h2>
    <p>BMA is a client-side block model inspector. Drop a CSV (or zipped CSV) exported from Isatis, Vulcan, Surpac, Leapfrog, Datamine, or any other mining package and get instant summary statistics, geometry detection, and categorical breakdowns — all without uploading anything to a server.</p>

    <p>Everything runs in your browser using streaming File API and Web Workers. Files are parsed row by row, never fully loaded into memory, so multi-gigabyte models work fine on modest hardware.</p>

    <h2>Features</h2>
    <div class="about-features">
      <span>Streaming single-pass parsing</span>
      <span>Auto-detect delimiters and types</span>
      <span>XYZ coordinate detection</span>
      <span>Grid geometry and fill ratio</span>
      <span>Sub-block model detection</span>
      <span><a href="https://doi.org/10.1080/00401706.1962.10490022" target="_blank">Welford's</a> online statistics</span>
      <span>Approximate quantiles (<a href="https://github.com/tdunning/t-digest" target="_blank">t-digest</a>)</span>
      <span>Skewness, kurtosis, CV%</span>
      <span>Per-column zero/negative filters</span>
      <span>CDF plots from centroids</span>
      <span>Categorical value counts</span>
      <span>Row filter expressions</span>
      <span>ZIP streaming decompression</span>
      <span>Preflight column controls</span>
    </div>

    <p>Columns are classified as numeric or categorical automatically. The preflight panel lets you override types, select coordinate axes, enable/disable columns, and set per-column value filters before analysis. Filter expressions use JavaScript syntax on row objects: <code>r.LITO === 'BIF' && r.fe_pct > 30</code>.</p>
  </div>

  <div class="landing-footer">
    <span>© 2026 <a href="https://endarthur.github.io" target="_blank">Arthur Endlein</a> — <a href="https://gentropic.org" target="_blank">Geoscientific Chaos Union</a></span>
    <span><a href="https://opensource.org/license/mit" target="_blank">MIT License</a> — use, modify, distribute freely</span>
  </div>

  <div class="error-msg" id="errorMsg"></div>

  <div id="results">
    <div class="results-toolbar" id="resultsToolbar">
      <div class="toolbar-left">
        <button class="preflight-back-btn" id="backToPreflight" title="Close file">✕</button>
        <span class="results-toolbar-title" id="resultsFilename"></span>
      </div>
      <div class="toolbar-center">
        <span id="resultsRowInfo" class="results-toolbar-info"></span>
        <span id="resultsTimeInfo" class="results-toolbar-info"></span>
        <span id="resultsMemInfo" class="results-toolbar-info"></span>
      </div>
      <div class="toolbar-right">
        <button class="toolbar-btn" id="projectSave" title="Save project (.bma.json)">Save</button>
        <button class="toolbar-btn" id="projectLoad" title="Load project (.bma.json)">Load</button>
        <button class="toolbar-btn" id="projectClear" title="Clear saved config, revert to defaults">Clear</button>
        <input type="file" id="projectFileInput" accept=".bma.json,.json" style="display:none">
        <button class="toolbar-icon-btn" id="settingsBtn" title="Settings">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="8" cy="8" r="2.5"/>
            <path d="M8 1.5v1.2M8 13.3v1.2M1.5 8h1.2M13.3 8h1.2M3.4 3.4l.85.85M11.75 11.75l.85.85M3.4 12.6l.85-.85M11.75 4.25l.85-.85"/>
          </svg>
        </button>
        <button class="toolbar-overflow" id="toolbarOverflow" title="More">⋮</button>
        <div class="toolbar-menu" id="toolbarMenu">
          <button class="toolbar-menu-item" data-action="save">Save project</button>
          <button class="toolbar-menu-item" data-action="load">Load project</button>
          <button class="toolbar-menu-item" data-action="clear">Clear project</button>
          <button class="toolbar-menu-item" data-action="settings">Settings</button>
        </div>
      </div>
    </div>
    <div class="action-bar" id="appFooter">
      <div class="action-bar-inner">
        <button class="execute-btn" id="executeBtn">Analyze &#9654;</button>
        <div class="filter-section" id="filterSection">
          <div class="filter-editor-body">
            <div class="filter-label">FILTER</div>
            <textarea class="filter-expr-input" id="filterExpr" rows="1" placeholder='e.g. r.Fe > 60' spellcheck="false"></textarea>
            <div class="filter-btn-group">
              <button class="filter-apply-btn" id="filterApply">Apply</button>
              <button class="filter-clear-btn" id="filterClear">Clear</button>
            </div>
          </div>
          <div class="filter-error" id="filterError"></div>
        </div>
      </div>
    </div>
    <div class="results-tabs" id="resultsTabs">
      <button class="results-tab active" data-tab="preflight">Preflight</button>
      <button class="results-tab" data-tab="summary">Summary</button>
      <button class="results-tab" data-tab="calcols">Calc</button>
      <button class="results-tab" data-tab="statistics">Statistics</button>
      <button class="results-tab" data-tab="categories">Categories</button>
      <button class="results-tab" data-tab="statscat">StatsCat</button>
      <button class="results-tab" data-tab="export">Export</button>
      <button class="results-tab" data-tab="gt">GT</button>
      <button class="results-tab" data-tab="swath">Swath</button>
      <button class="results-tab" data-tab="section">Section</button>
    </div>
    <div class="results-panels">
      <div class="results-panel active" id="panelPreflight" data-tab="preflight">
        <div class="preflight-head" id="preflightHead">
          <span class="preflight-zip" id="preflightZip"></span>
        </div>
        <div class="preflight-body">
          <div class="preflight-sidebar" id="preflightSidebar"></div>
          <div class="preflight-preview-wrap">
            <div class="preflight-preview" id="preflightPreview"></div>
          </div>
        </div>
      </div>

      <div class="results-panel" id="panelSummary" data-tab="summary">
        <div class="panel-inner">
          <div class="section section--geo" id="geoSection">
            <div class="section-head">
              Grid Geometry
              <span><span class="badge" id="geoBadge"></span><button class="copy-table-btn" id="exportObjBtn" title="Download bounding box as .obj" style="display:none">Export OBJ</button><button class="copy-table-btn" id="copyGeoBtn" title="Copy as table">Copy table</button></span>
            </div>
            <div class="section-body">
              <div class="xyz-config" id="xyzConfig"></div>
              <div id="geoContent"></div>
            </div>
          </div>

          <div class="section section--file">
            <div class="section-head">File Info</div>
            <div class="section-body">
              <div class="file-info" id="fileInfo"></div>
            </div>
          </div>

          <div class="section section--cols" id="colOverviewSection" style="display:none">
            <div class="section-head">
              Column Overview
              <span><span class="badge" id="colOverviewBadge"></span><button class="copy-table-btn" id="copyColOverviewBtn" title="Copy as table">Copy table</button></span>
            </div>
            <div class="section-body" id="colOverviewContent"></div>
          </div>
        </div>
      </div>

      <div class="results-panel" id="panelCalcols" data-tab="calcols">
        <div class="calcol-layout">
          <div class="calcol-sidebar" id="calcolVarBrowser">
            <div class="calcol-sb-section">
              <div class="calcol-sb-title">Variables</div>
              <input type="text" class="calcol-sb-search" id="calcolVarSearch" placeholder="Search columns..." autocomplete="off" spellcheck="false">
            </div>
            <div class="calcol-sb-vars" id="calcolVarList"></div>
            <div class="calcol-sb-section">
              <details class="calcol-fn-ref">
                <summary>Functions</summary>
                <div class="calcol-fn-list" id="calcolFnList"></div>
              </details>
            </div>
          </div>
          <div class="calcol-editor-pane">
            <div class="calcol-editor-head">
              <span>Calculated Columns</span>
              <span class="badge" id="calcolBadge">0</span>
            </div>
            <div class="calcol-code-wrap">
              <pre class="calcol-code-pre" id="calcolCodePre" aria-hidden="true"></pre>
              <textarea class="calcol-code-area" id="calcolCodeArea" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"
                placeholder="// Mutate r to create new columns&#10;r.grade_cut = min(r.AU, 5);&#10;r.is_ore = r.AU > 0.5 ? 'ore' : 'waste';"></textarea>
              <div class="calcol-ac" id="calcolAc"></div>
            </div>
            <div class="calcol-editor-footer">
              <span class="calcol-error" id="calcolError"></span>
              <button class="calcol-sim-btn" id="calcolSimBtn">Simulate</button>
            </div>
            <details class="calcol-ref">
              <summary>Reference</summary>
              <div class="calcol-ref-body">
                <p>Row object: <code>r</code> — mutate it to create columns: <code>r.name = expr;</code></p>
                <p>Access columns: <code>r.col</code> or <code>r["col name"]</code></p>
                <p><b>Math:</b> <code>abs</code> <code>sqrt</code> <code>pow</code> <code>log</code> <code>log10</code> <code>exp</code> <code>min</code> <code>max</code> <code>round</code> <code>floor</code> <code>ceil</code> <code>PI</code></p>
                <p><b>Helpers:</b> <code>cap(v, hi)</code> · <code>clamp(v, lo, hi)</code> · <code>ifnull(v, d)</code> · <code>ifnum(v, d)</code> · <code>isnum(v)</code> · <code>between(v, lo, hi)</code> · <code>remap(v, map)</code> · <code>fn.round(v, n)</code></p>
                <p><b>Loops &amp; conditionals:</b> <code>for</code>, <code>if/else</code>, ternary — full JS</p>
                <p><b>String:</b> <code>r.LITO.startsWith("BIF")</code> · <code>r.LITO.includes("x")</code></p>
                <p><b>Type forcing:</b> <code>r.META.cat.push('name')</code> force categorical · <code>r.META.num.push('name')</code> force numeric</p>
              </div>
            </details>
          </div>
          <div class="calcol-results">
            <div class="calcol-results-head">
              <span>Detected Columns</span>
            </div>
            <div class="calcol-detected" id="calcolDetected">
              <div class="calcol-empty-hint">Write code and click Simulate to detect new columns.</div>
            </div>
            <div class="calcol-results-head" style="margin-top:0.5rem">
              <span>Preview</span>
              <select class="calcol-datasrc-select" id="calcolDataSrc">
                <option value="preflight">Preflight</option>
                <option value="simulated" disabled>Simulated</option>
              </select>
            </div>
            <div class="calcol-preview-table" id="calcolPreviewTable">
              <div class="calcol-empty-hint">No preview yet.</div>
            </div>
          </div>
        </div>
      </div>

      <div class="results-panel" id="panelStatistics" data-tab="statistics">
        <div class="stats-body" id="statsBody">
          <div class="stats-sidebar" id="statsSidebar">
            <div class="stats-sidebar-section">
              <div class="stats-sidebar-title">Percentiles</div>
              <div class="stats-preset-btns" id="statsPresetBtns">
                <button class="stats-preset active" data-preset="quartiles">Quartiles</button>
                <button class="stats-preset" data-preset="deciles">Deciles</button>
                <button class="stats-preset" data-preset="ventiles">Ventiles</button>
                <button class="stats-preset" data-preset="custom">Custom</button>
              </div>
              <input type="text" class="stats-custom-input" id="statsCustomPct" placeholder="e.g. 5,10,25,50,75,90,95" style="display:none" autocomplete="off" spellcheck="false">
            </div>
            <div class="stats-sidebar-section">
              <div class="stats-sidebar-title">Metrics</div>
              <div class="stats-metric-toggles" id="statsMetricToggles"></div>
            </div>
            <div class="stats-sidebar-section--grow">
              <div class="stats-sidebar-title">Variables <span class="badge" id="statsBadge"></span></div>
              <input type="text" class="stats-search" id="statsVarSearch" placeholder="Search variables…" autocomplete="off" spellcheck="false">
              <div class="stats-var-actions">
                <button id="statsVarAll">All</button>
                <button id="statsVarNone">None</button>
              </div>
              <div class="stats-var-list" id="statsVarList"></div>
            </div>
          </div>
          <div class="stats-main" id="statsMain">
            <div class="stats-table-area">
              <div class="stats-table-toolbar">
                <button class="stats-copy-btn" id="statsCopyBtn">Copy table</button>
              </div>
              <div class="stats-table-wrap" id="statsContent"></div>
            </div>
            <div class="stats-cdf-panel" id="statsCdfPanel">
              <div class="stats-cdf-toolbar" id="statsCdfToolbar">
                <div class="tb-group">
                  <button class="stats-scale active" data-scale="linear">Linear</button>
                  <button class="stats-scale" data-scale="log">Log</button>
                </div>
                <div class="tb-group" style="margin-left:auto">
                  <button id="statsDownloadSvg">SVG</button>
                  <button id="statsDownloadPng">PNG</button>
                </div>
              </div>
              <div class="stats-cdf-chart" id="statsCdfChart">
                <div class="stats-cdf-hint">Click column names to add CDF curves</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="results-panel" id="panelCategories" data-tab="categories">
        <div class="cat-body" id="catBody">
          <div class="cat-sidebar" id="catSidebar">
            <div class="cat-sidebar-section">
              <div class="cat-sidebar-title">Columns <span class="badge" id="catBadge"></span></div>
              <input type="text" class="cat-col-search" id="catColSearch" placeholder="Search columns..." autocomplete="off" spellcheck="false">
            </div>
            <div class="cat-sidebar-section--grow">
              <div class="cat-col-list" id="catColList"></div>
            </div>
          </div>
          <div class="cat-main" id="catMain">
            <div class="cat-toolbar" id="catToolbar"></div>
            <div class="cat-main-content" id="catMainContent">
              <div class="cat-chart" id="catChart"></div>
              <div class="cat-value-table-wrap" id="catValueTableWrap">
                <input type="text" class="cat-value-search" id="catValueSearch" placeholder="Search values..." autocomplete="off" spellcheck="false">
                <table class="cat-values" id="catValueTable"><tbody></tbody></table>
              </div>
            </div>
            <div class="cat-color-picker" id="catColorPicker"></div>
          </div>
        </div>
      </div>

      <div class="results-panel" id="panelStatsCat" data-tab="statscat">
        <div class="statscat-body">
          <div class="statscat-sidebar">
            <div class="statscat-sidebar-section">
              <div class="statscat-sidebar-title">Group By <span class="badge" id="statsCatBadge"></span></div>
              <select class="statscat-select" id="statsCatGroupBy">
                <option value="">— select grouping column —</option>
              </select>
            </div>
            <div class="statscat-sidebar-section--grow">
              <div class="statscat-sidebar-title">Variables <button id="statsCatVarFilter" class="statscat-filter-toggle" title="Show only selected variables">All</button></div>
              <input type="text" class="statscat-search" id="statsCatVarSearch" placeholder="Search variables…" autocomplete="off" spellcheck="false">
              <div class="statscat-group-actions">
                <button id="statsCatVarAll">All</button>
                <button id="statsCatVarNone">None</button>
              </div>
              <div class="statscat-var-list" id="statsCatVarList"></div>
            </div>
            <div class="statscat-sidebar-section--grow">
              <div class="statscat-sidebar-title">Groups</div>
              <div class="statscat-group-actions">
                <button id="statsCatGroupAll">All</button>
                <button id="statsCatGroupNone">None</button>
                <span style="margin-left:auto"></span>
                <button id="statsCatGroupSort" title="Toggle sort: count / name">Sort: count</button>
              </div>
              <input type="text" class="statscat-search" id="statsCatGroupSearch" placeholder="Search groups…" autocomplete="off" spellcheck="false">
              <div class="statscat-group-list" id="statsCatGroupList"></div>
            </div>
          </div>
          <div class="statscat-content" id="statsCatContent"></div>
        </div>
      </div>
      <div class="results-panel" id="panelExport" data-tab="export">
        <div class="export-body" id="exportBody">
          <div class="export-sidebar">
            <div class="export-sidebar-section">
              <div class="export-sidebar-title">Columns <span class="badge" id="exportBadge">0</span></div>
              <input type="text" class="export-col-search" id="exportColSearch" placeholder="Search columns…" autocomplete="off" spellcheck="false">
              <div class="export-sel-btns">
                <button id="exportSelAll">All</button>
                <button id="exportSelNone">None</button>
                <button id="exportSelOrig">Original</button>
                <button id="exportSelCalc">Calcols</button>
              </div>
            </div>
            <div class="export-sidebar-section--grow">
              <div class="export-col-list" id="exportColList"></div>
            </div>
          </div>
          <div class="export-main">
            <div class="export-toolbar" id="exportToolbar">
              <div class="tb-group" style="margin-left:auto">
                <span class="export-row-preview" id="exportRowPreview"></span>
                <button class="export-btn" id="exportDownload">Download CSV</button>
              </div>
            </div>
            <div class="export-main-content" id="exportMainContent">
              <div class="export-format" id="exportFormatSection">
                <div class="export-format-row">
                  <span class="export-label">Delimiter</span>
                  <button class="export-delim active" data-delim=",">,</button>
                  <button class="export-delim" data-delim="tab">Tab</button>
                  <button class="export-delim" data-delim=";">;</button>
                  <button class="export-delim" data-delim="|">|</button>
                  <button class="export-delim" data-delim=" ">Spc</button>
                  <span class="export-label" style="margin-left:0.5rem">Other</span>
                  <input type="text" class="export-custom-delim" id="exportCustomDelim" maxlength="4" placeholder="…">
                </div>
                <div class="export-format-row">
                  <span class="export-label">Quote</span>
                  <button class="export-quote active" data-quote='"'>&quot;</button>
                  <button class="export-quote" data-quote="'">&apos;</button>
                  <button class="export-quote" data-quote="">None</button>
                  <span class="export-label" style="margin-left:0.75rem">Ending</span>
                  <button class="export-ending active" data-ending="lf">LF</button>
                  <button class="export-ending" data-ending="crlf">CRLF</button>
                  <label style="margin-left:0.75rem"><input type="checkbox" id="exportIncludeHeader" checked> Header row</label>
                  <label><input type="checkbox" id="exportCommentHeader"> Comment header</label>
                </div>
                <div class="export-format-row">
                  <span class="export-label">Nulls</span>
                  <select class="export-select" id="exportNullSelect">
                    <option value="">(empty)</option>
                    <option value="NA">NA</option>
                    <option value="NaN">NaN</option>
                    <option value="NULL">NULL</option>
                    <option value="-999">-999</option>
                    <option value="custom">Custom…</option>
                  </select>
                  <input type="text" class="export-inline-input" id="exportNullInput" style="display:none" placeholder="value" maxlength="20">
                  <span class="export-label" style="margin-left:0.75rem">Precision</span>
                  <select class="export-select" id="exportPrecisionSelect">
                    <option value="auto">Auto</option>
                    <option value="0">0 dp</option>
                    <option value="1">1 dp</option>
                    <option value="2">2 dp</option>
                    <option value="3">3 dp</option>
                    <option value="4">4 dp</option>
                    <option value="6">6 dp</option>
                    <option value="8">8 dp</option>
                    <option value="10">10 dp</option>
                    <option value="custom">Custom…</option>
                  </select>
                  <input type="number" class="export-inline-input" id="exportPrecisionInput" style="display:none" min="0" max="20" placeholder="dp">
                  <span class="export-label" style="margin-left:0.75rem">Dec sep</span>
                  <button class="export-decsep active" data-sep=".">.</button>
                  <button class="export-decsep" data-sep=",">,</button>
                </div>
                <div class="export-format-warn" id="exportPrecisionWarn" style="display:none"></div>
              </div>
              <div class="export-comment-section" id="exportCommentSection" style="display:none">
                <div class="export-comment-toolbar">
                  <span class="export-label">Comment Header</span>
                  <button id="exportCommentGenerate" title="Generate from detected geometry">Generate from geometry</button>
                </div>
                <textarea id="exportCommentText" class="export-comment-textarea" rows="6" spellcheck="false" placeholder="Lines will be prefixed with # in the output"></textarea>
              </div>
              <div class="export-preview" id="exportPreview">
                <div class="export-preview-head">
                  <span class="export-label">Preview</span>
                  <span class="export-preview-info" id="exportPreviewInfo"></span>
                </div>
                <pre class="export-preview-pre" id="exportPreviewPre"></pre>
              </div>
              <div class="export-progress" id="exportProgress">
                <div class="export-progress-label" id="exportProgressLabel"></div>
                <div class="export-progress-bar"><div class="export-progress-fill" id="exportProgressFill"></div></div>
              </div>
              <div class="export-info" id="exportInfo"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="results-panel" id="panelGt" data-tab="gt">
        <div class="gt-body">
          <div class="gt-sidebar" id="gtSidebar"></div>
          <div class="gt-content" id="gtContent">
            <div class="gt-hint">Select a grade variable and click Generate.</div>
          </div>
        </div>
      </div>
      <div class="results-panel" id="panelSwath" data-tab="swath">
        <div class="swath-body">
          <div class="swath-sidebar" id="swathSidebar"></div>
          <div class="swath-content" id="swathContent">
            <div class="swath-hint">Configure settings and click Generate to create swath plots.</div>
          </div>
        </div>
      </div>
      <div class="results-panel" id="panelSection" data-tab="section">
        <div class="panel-section-body">
          <div class="section-config-bar" id="sectionConfig"></div>
          <div class="section-progress" id="sectionProgress">
            <div class="section-progress-label" id="sectionProgressLabel"></div>
            <div class="section-progress-bar"><div class="section-progress-fill" id="sectionProgressFill"></div></div>
          </div>
          <div class="section-canvas-wrap" id="sectionCanvasWrap">
            <canvas id="sectionCanvas"></canvas>
            <div class="section-colorbar" id="sectionColorbar"><canvas id="sectionColorbarCanvas"></canvas></div>
            <div class="section-colorbar-labels" id="sectionColorbarLabels"></div>
            <div class="section-tooltip" id="sectionTooltip"></div>
            <div class="section-info" id="sectionInfo"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="cdf-modal" id="cdfModal">
  <div class="cdf-modal-inner">
    <div class="cdf-modal-head">
      <span id="cdfTitle"></span>
      <button class="preflight-back-btn" id="cdfClose" title="Close">✕</button>
    </div>
    <div class="cdf-modal-body" id="cdfBody"></div>
  </div>
</div>

<div class="settings-modal" id="settingsModal">
  <div class="settings-modal-inner">
    <div class="settings-modal-head">
      <span>Settings</span>
      <button class="preflight-back-btn" id="settingsClose" title="Close">✕</button>
    </div>
    <div class="settings-modal-body" id="settingsBody"></div>
  </div>
</div>

<script>
// ─── Worker Code (inlined as Blob) ────────────────────────────────────
const WORKER_CODE = `
const DELIMITERS = [',', '\\t', ';', '|', ' '];
const MAX_UNIQUE_CAT = 500;
const MAX_GROUPS = 500;

// XYZ name patterns
const XYZ_PATTERNS = {
  x: [/^x$/i, /^xc$/i, /^x[_-]?cent(re|er)?$/i, /^mid[_-]?x$/i, /^centroid[_-]?x$/i, /^east(ing)?$/i, /^x[_-]?coord$/i, /^xcenter$/i, /^xmid$/i, /^xblock$/i],
  y: [/^y$/i, /^yc$/i, /^y[_-]?cent(re|er)?$/i, /^mid[_-]?y$/i, /^centroid[_-]?y$/i, /^north(ing)?$/i, /^y[_-]?coord$/i, /^ycenter$/i, /^ymid$/i, /^yblock$/i],
  z: [/^z$/i, /^zc$/i, /^z[_-]?cent(re|er)?$/i, /^mid[_-]?z$/i, /^centroid[_-]?z$/i, /^elev(ation)?$/i, /^rl$/i, /^z[_-]?coord$/i, /^zcenter$/i, /^zmid$/i, /^zblock$/i, /^level$/i, /^bench$/i]
};

const DXYZ_PATTERNS = {
  dx: [/^dx$/i, /^xinc$/i, /^xdis$/i, /^xsize$/i, /^dimx$/i, /^xlen$/i, /^x[_-]?dim$/i, /^x[_-]?size$/i, /^d[_-]?x$/i, /^size[_-]?x$/i],
  dy: [/^dy$/i, /^yinc$/i, /^ydis$/i, /^ysize$/i, /^dimy$/i, /^ylen$/i, /^y[_-]?dim$/i, /^y[_-]?size$/i, /^d[_-]?y$/i, /^size[_-]?y$/i],
  dz: [/^dz$/i, /^zinc$/i, /^zdis$/i, /^zsize$/i, /^dimz$/i, /^zlen$/i, /^z[_-]?dim$/i, /^z[_-]?size$/i, /^d[_-]?z$/i, /^size[_-]?z$/i]
};

function guessDXYZ(header, types) {
  const result = { dx: -1, dy: -1, dz: -1 };
  for (const axis of ['dx', 'dy', 'dz']) {
    for (const pat of DXYZ_PATTERNS[axis]) {
      const idx = header.findIndex((h, i) => types[i] === 'numeric' && pat.test(h.trim()));
      if (idx >= 0) { result[axis] = idx; break; }
    }
  }
  return result;
}

function detectDelimiter(lines) {
  let best = ',', bestScore = -1;
  for (const d of DELIMITERS) {
    const counts = lines.map(l => l.split(d).length);
    if (counts[0] < 2) continue;
    const allSame = counts.every(c => c === counts[0]);
    const score = allSame ? counts[0] * 1000 + counts.length : counts[0];
    if (score > bestScore) { bestScore = score; best = d; }
  }
  return best;
}

const NULL_SENTINELS = new Set(['', 'NA', 'NaN', 'na', 'nan', 'N/A', 'n/a', 'null', 'NULL', '*', '-', '-999', '-99', '#N/A', 'VOID', 'void', '-1.0e+32', '-1e+32', '1e+31', '-9999', '-99999']);

function guessXYZ(header, types) {
  const result = { x: -1, y: -1, z: -1 };
  for (const axis of ['x', 'y', 'z']) {
    for (const pat of XYZ_PATTERNS[axis]) {
      const idx = header.findIndex((h, i) => types[i] === 'numeric' && pat.test(h.trim()));
      if (idx >= 0) { result[axis] = idx; break; }
    }
  }
  // Fallback: if not all found, look for first 3 numeric columns
  if (result.x < 0 || result.y < 0 || result.z < 0) {
    const numCols = header.map((h, i) => i).filter(i => types[i] === 'numeric');
    if (numCols.length >= 3 && result.x < 0 && result.y < 0 && result.z < 0) {
      result.x = numCols[0]; result.y = numCols[1]; result.z = numCols[2];
    }
  }
  return result;
}

function computeGeometry(xVals, yVals, zVals, decimals, dims) {
  const axes = { x: xVals, y: yVals, z: zVals };
  const result = {};
  for (const [axis, vals] of Object.entries(axes)) {
    if (!vals || vals.length === 0) { result[axis] = null; continue; }
    const dp = decimals[axis];
    const rnd = (v) => {
      if (v === null) return null;
      const factor = Math.pow(10, dp);
      return Math.round(v * factor) / factor;
    };
    const sorted = Float64Array.from(vals).sort();
    const min = sorted[0], max = sorted[sorted.length - 1];
    const count = sorted.length;

    // Collect all spacings and their frequencies
    const spacingCounts = {};
    if (count > 1) {
      for (let i = 1; i < sorted.length; i++) {
        const d = rnd(sorted[i] - sorted[i - 1]);
        if (d > 0) spacingCounts[d] = (spacingCounts[d] || 0) + 1;
      }
    }

    const spacings = Object.entries(spacingCounts)
      .map(([s, c]) => ({ size: Number(s), count: c }))
      .sort((a, b) => b.count - a.count);

    let parentSize = null;
    let subBlockSizes = [];
    let isSubBlocked = false;

    if (spacings.length === 0) {
      // Single unique value
    } else if (spacings.length === 1) {
      // Regular grid
      parentSize = spacings[0].size;
    } else {
      // Multiple spacings — check for sub-block pattern
      // Parent block = largest spacing that appears frequently
      // "frequently" = at least 5% of total spacings
      const totalSpacings = spacings.reduce((s, x) => s + x.count, 0);
      const significant = spacings.filter(s => s.count / totalSpacings > 0.02);

      if (significant.length === 1) {
        parentSize = significant[0].size;
      } else {
        // Find the largest significant spacing as candidate parent
        const sorted_sig = significant.slice().sort((a, b) => b.size - a.size);
        const candidateParent = sorted_sig[0].size;

        // Check if smaller spacings are clean divisors of the parent
        const subs = [];
        let allDivisors = true;
        for (const s of sorted_sig.slice(1)) {
          const ratio = candidateParent / s.size;
          const roundedRatio = Math.round(ratio);
          if (roundedRatio >= 2 && Math.abs(ratio - roundedRatio) < 0.05) {
            subs.push({ size: s.size, ratio: roundedRatio, count: s.count });
          } else {
            allDivisors = false;
          }
        }

        if (subs.length > 0) {
          // Sub-block model detected
          parentSize = rnd(candidateParent);
          subBlockSizes = subs.map(s => ({ size: rnd(s.size), ratio: s.ratio, count: s.count }));
          isSubBlocked = true;
        } else {
          // Irregular spacings — use most frequent as best guess
          parentSize = spacings[0].size;
        }
      }
    }

    // Override from explicit dimension columns if available
    if (dims && dims[axis] && dims[axis].length > 0) {
      const dimVals = dims[axis];
      const uniqueDims = [...new Set(dimVals)].sort((a, b) => a - b);
      const maxDim = Math.max(...uniqueDims);
      if (uniqueDims.length === 1) {
        parentSize = rnd(uniqueDims[0]);
        isSubBlocked = false;
        subBlockSizes = [];
      } else {
        parentSize = rnd(maxDim);
        isSubBlocked = true;
        subBlockSizes = uniqueDims.filter(d => d < maxDim).map(d => ({
          size: rnd(d), ratio: Math.round(maxDim / d), count: dimVals.filter(v => v === d).length
        }));
      }
    }

    const origin = rnd(min);
    const maxR = rnd(max);
    const nBlocks = parentSize ? Math.round((maxR - origin) / parentSize) + 1 : count;
    const extent = parentSize ? rnd(nBlocks * parentSize) : rnd(maxR - origin);
    const minBlockSize = spacings.length > 0 ? spacings[spacings.length - 1].size : null;

    result[axis] = {
      origin,
      max: maxR,
      blockSize: parentSize,
      minBlockSize: isSubBlocked ? rnd(Math.min(...subBlockSizes.map(s => s.size))) : null,
      subBlockSizes: isSubBlocked ? subBlockSizes : [],
      isSubBlocked,
      uniqueCount: count,
      gridCount: nBlocks,
      extent,
      decimals: dp
    };
  }
  return result;
}

// Round to n significant figures for display
// ─── ZIP support ──────────────────────────────────────────────────────
const CSV_EXTENSIONS = /\\.(csv|txt|dat|tsv)$/i;

async function readBytes(file, offset, length) {
  const blob = file.slice(offset, offset + length);
  return new Uint8Array(await blob.arrayBuffer());
}

function readUint16(buf, off) { return buf[off] | (buf[off+1] << 8); }
function readUint32(buf, off) { return (buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24)) >>> 0; }

async function extractCSVFromZip(file, targetEntry) {
  self.postMessage({ type: 'progress', percent: 0, rowCount: 0, note: 'Reading ZIP headers...' });

  // Read last 64KB to find End of Central Directory
  const tailSize = Math.min(65557, file.size);
  const tail = await readBytes(file, file.size - tailSize, tailSize);

  let eocdPos = -1;
  for (let i = tail.length - 22; i >= 0; i--) {
    if (readUint32(tail, i) === 0x06054b50) { eocdPos = i; break; }
  }
  if (eocdPos < 0) throw new Error('Not a valid ZIP file (EOCD not found)');

  const cdEntries = readUint16(tail, eocdPos + 8);
  const cdSize = readUint32(tail, eocdPos + 12);
  const cdOffset = readUint32(tail, eocdPos + 16);

  // Read central directory
  const cd = await readBytes(file, cdOffset, cdSize);
  const entries = [];
  let pos = 0;
  for (let i = 0; i < cdEntries && pos < cd.length; i++) {
    if (readUint32(cd, pos) !== 0x02014b50) break;
    const method = readUint16(cd, pos + 10);
    const compSize = readUint32(cd, pos + 20);
    const uncompSize = readUint32(cd, pos + 24);
    const nameLen = readUint16(cd, pos + 28);
    const extraLen = readUint16(cd, pos + 30);
    const commentLen = readUint16(cd, pos + 32);
    const localOffset = readUint32(cd, pos + 42);
    const name = new TextDecoder().decode(cd.slice(pos + 46, pos + 46 + nameLen));
    entries.push({ name, method, compSize, uncompSize, localOffset });
    pos += 46 + nameLen + extraLen + commentLen;
  }

  // Find CSV entry: use targetEntry if specified, otherwise first CSV
  let csvEntry;
  if (targetEntry) {
    csvEntry = entries.find(e => e.name === targetEntry);
    if (!csvEntry) throw new Error('Entry not found in ZIP: ' + targetEntry);
  } else {
    csvEntry = entries.find(e =>
      !e.name.endsWith('/') &&
      !e.name.startsWith('__MACOSX') &&
      !e.name.startsWith('.') &&
      CSV_EXTENSIONS.test(e.name)
    );
  }

  if (!csvEntry) {
    const names = entries.filter(e => !e.name.endsWith('/')).map(e => e.name).join(', ');
    throw new Error('No CSV/TXT/DAT file found in ZIP. Contents: ' + names);
  }

  self.postMessage({ type: 'progress', percent: 0, rowCount: 0, note: 'Streaming ' + csvEntry.name + '...' });

  // Read local file header (30 bytes + variable) to find data start
  const lh = await readBytes(file, csvEntry.localOffset, 30);
  const lhNameLen = readUint16(lh, 26);
  const lhExtraLen = readUint16(lh, 28);
  const dataStart = csvEntry.localOffset + 30 + lhNameLen + lhExtraLen;

  // Slice compressed data directly from file — no full load
  const compressedSlice = file.slice(dataStart, dataStart + csvEntry.compSize);

  if (csvEntry.method === 0) {
    // Stored
    return { stream: () => compressedSlice.stream(), size: csvEntry.uncompSize, name: csvEntry.name };
  } else if (csvEntry.method === 8) {
    // Deflate — stream through DecompressionStream
    return {
      stream: () => compressedSlice.stream().pipeThrough(new DecompressionStream('deflate-raw')),
      size: csvEntry.uncompSize,
      name: csvEntry.name
    };
  } else {
    throw new Error('Unsupported ZIP compression method: ' + csvEntry.method);
  }
}

function isZipFile(file) {
  return file.name.toLowerCase().endsWith('.zip') || file.type === 'application/zip';
}

async function readSample(file, maxLines) {
  const stream = file.stream().pipeThrough(new TextDecoderStream());
  const reader = stream.getReader();
  let buf = '', lines = [], done = false;
  while (!done && lines.length < maxLines + 1) {
    const res = await reader.read();
    if (res.done) { done = true; break; }
    buf += res.value;
    const parts = buf.split('\\n');
    buf = parts.pop();
    for (const p of parts) {
      const trimmed = p.replace(/\\r$/, '');
      if (trimmed.startsWith('#')) continue;
      lines.push(trimmed);
      if (lines.length >= maxLines + 1) break;
    }
  }
  if (buf && lines.length < maxLines + 1) {
    const trimmed = buf.replace(/\\r$/, '');
    if (!trimmed.startsWith('#')) lines.push(trimmed);
  }
  reader.cancel();
  return lines;
}

// ─── T-Digest for streaming approximate quantiles ─────────────────────
const TD_COMPRESSION = 100;
const TD_BUFFER_SIZE = 2000;

function newTDigest() {
  return { centroids: [], buffer: [], totalCount: 0 };
}

function tdAdd(td, value) {
  td.buffer.push(value);
  td.totalCount++;
  if (td.buffer.length >= TD_BUFFER_SIZE) tdFlush(td);
}

function tdFlush(td) {
  if (td.buffer.length === 0) return;
  td.buffer.sort((a, b) => a - b);
  // Merge sorted buffer with sorted centroids
  const merged = [];
  let bi = 0, ci = 0;
  while (bi < td.buffer.length || ci < td.centroids.length) {
    if (bi < td.buffer.length && (ci >= td.centroids.length || td.buffer[bi] <= td.centroids[ci].mean)) {
      merged.push({ mean: td.buffer[bi], count: 1 });
      bi++;
    } else {
      merged.push({ mean: td.centroids[ci].mean, count: td.centroids[ci].count });
      ci++;
    }
  }
  td.buffer = [];
  td.centroids = tdCompress(merged, td.totalCount);
}

function tdCompress(centroids, totalCount) {
  if (centroids.length <= 1) return centroids;
  const result = [centroids[0]];
  let cumCount = centroids[0].count;
  for (let i = 1; i < centroids.length; i++) {
    const c = centroids[i];
    const last = result[result.length - 1];
    const q = cumCount / totalCount;
    const maxSize = Math.max(1, Math.floor(4 * TD_COMPRESSION * q * (1 - q)));
    if (last.count + c.count <= maxSize) {
      const newCount = last.count + c.count;
      last.mean += (c.mean - last.mean) * c.count / newCount;
      last.count = newCount;
    } else {
      result.push({ mean: c.mean, count: c.count });
    }
    cumCount += c.count;
  }
  return result;
}

function tdQuantile(td, q) {
  tdFlush(td);
  const centroids = td.centroids;
  if (centroids.length === 0) return null;
  if (centroids.length === 1) return centroids[0].mean;
  if (q <= 0) return centroids[0].mean;
  if (q >= 1) return centroids[centroids.length - 1].mean;

  const target = q * td.totalCount;
  let cumCount = 0;
  for (let i = 0; i < centroids.length; i++) {
    const c = centroids[i];
    const lo = cumCount;
    const mid = lo + c.count / 2;
    if (target < mid) {
      if (i === 0) return c.mean;
      const prev = centroids[i - 1];
      const prevMid = lo - prev.count / 2;
      const t = (target - prevMid) / (mid - prevMid);
      return prev.mean + t * (c.mean - prev.mean);
    }
    cumCount += c.count;
  }
  return centroids[centroids.length - 1].mean;
}

const MATH_PREAMBLE = 'const {abs,sqrt,pow,log,log2,log10,exp,min,max,round,floor,ceil,sign,trunc,hypot,sin,cos,tan,asin,acos,atan,atan2,PI,E}=Math;const fn={cap:(v,lo,hi)=>v==null?null:hi===undefined?Math.min(v,lo):Math.min(Math.max(v,lo),hi),ifnull:(v,d)=>(v==null||v!==v)?d:v,between:(v,lo,hi)=>v!=null&&v>=lo&&v<=hi,remap:(v,m,d)=>m.hasOwnProperty(v)?m[v]:(d!==undefined?d:null),round:(v,n)=>{const f=Math.pow(10,n||0);return Math.round(v*f)/f;},clamp:(v,lo,hi)=>Math.min(Math.max(v,lo),hi),isnum:(v)=>Number.isFinite(v),ifnum:(v,d)=>Number.isFinite(v)?v:(d!==undefined?d:NaN)};const clamp=fn.clamp;const cap=fn.cap;const ifnull=fn.ifnull;const between=fn.between;const remap=fn.remap;const isnum=fn.isnum;const ifnum=fn.ifnum;';

async function analyze(file, xyzOverride, filter, typeOverrides, zipEntry, skipCols, colFilters, calcolCode, calcolMeta, groupBy, groupStatsCols, dxyzOverride) {
  const startTime = performance.now();

  // ZIP extraction
  let csvFile = file;
  let zipName = null;
  if (isZipFile(file)) {
    try {
      csvFile = await extractCSVFromZip(file, zipEntry);
      zipName = csvFile.name;
    } catch(e) {
      self.postMessage({ type: 'error', message: e.message });
      return;
    }
  }

  // Tiny sample for delimiter + header only
  const sampleLines = await readSample(csvFile, 50);
  if (sampleLines.length < 2) {
    self.postMessage({ type: 'error', message: 'File appears empty or has no data rows.' });
    return;
  }

  const delimiter = detectDelimiter(sampleLines.slice(0, 20));
  const header = sampleLines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
  const nCols = header.length;

  // Pick a row variable name that doesn't collide with a column name
  let rowVarName = 'r';
  const colSet = new Set(header);
  for (const candidate of ['r', 'd', 'row', '_r', '_d']) {
    if (!colSet.has(candidate)) { rowVarName = candidate; break; }
  }

  // ── Per-column type detection state ──
  const TYPE_MIN_NONNULL = 20;
  const TYPE_MAX_ROWS = 100000;
  const detect_num = new Int32Array(nCols);
  const detect_nonNum = new Int32Array(nCols);
  const forced = new Set(); // columns with forced types
  let colTypes = null; // null = still detecting
  let typesResolved = false;
  let detectRowCount = 0;

  // Apply type overrides — these columns skip detection
  if (typeOverrides) {
    for (const [col, type] of Object.entries(typeOverrides)) {
      forced.add(Number(col));
    }
  }

  function resolveTypes() {
    const types = new Array(nCols);
    for (let col = 0; col < nCols; col++) {
      if (typeOverrides && typeOverrides[col]) {
        types[col] = typeOverrides[col];
        continue;
      }
      const n = detect_num[col], nn = detect_nonNum[col], total = n + nn;
      if (total === 0) types[col] = 'numeric';
      else if (nn === 0) types[col] = 'numeric';
      else if (n === 0) types[col] = 'categorical';
      else types[col] = (n / total > 0.8) ? 'numeric' : 'categorical';
    }
    return types;
  }

  function checkAllResolved() {
    for (let col = 0; col < nCols; col++) {
      if (forced.has(col)) continue;
      if (detect_num[col] + detect_nonNum[col] < TYPE_MIN_NONNULL) return false;
    }
    return true;
  }

  // ── XYZ guess (name-based, no types needed) ──
  function guessXYZByName() {
    const result = { x: -1, y: -1, z: -1 };
    for (const axis of ['x', 'y', 'z']) {
      for (const pat of XYZ_PATTERNS[axis]) {
        const idx = header.findIndex(h => pat.test(h.trim()));
        if (idx >= 0) { result[axis] = idx; break; }
      }
    }
    return result;
  }
  let xyzGuess = xyzOverride || guessXYZByName();
  const xyzSets = { x: new Set(), y: new Set(), z: new Set() };
  let hasXYZ = xyzGuess.x >= 0 && xyzGuess.y >= 0 && xyzGuess.z >= 0;

  // DXYZ guess
  function guessDXYZByName() {
    const result = { dx: -1, dy: -1, dz: -1 };
    for (const axis of ['dx', 'dy', 'dz']) {
      for (const pat of DXYZ_PATTERNS[axis]) {
        const idx = header.findIndex(h => pat.test(h.trim()));
        if (idx >= 0) { result[axis] = idx; break; }
      }
    }
    return result;
  }
  let dxyzGuess = dxyzOverride || guessDXYZByName();
  let hasDXYZ = dxyzGuess.dx >= 0 || dxyzGuess.dy >= 0 || dxyzGuess.dz >= 0;
  const dxyzSets = { dx: [], dy: [], dz: [] };

  // Coordinate ordering detection
  const ORDER_SAMPLE = 50000;
  const prevCoord = { x: null, y: null, z: null };
  const transitions = { x: 0, y: 0, z: 0 };
  let orderSampleCount = 0;

  // Decimal precision detection
  const maxDecimals = { x: 0, y: 0, z: 0 };
  const PRECISION_SAMPLE = 10000;
  let precisionSampleCount = 0;

  // ── Stats accumulators (initialized after type detection) ──
  let stats = null;
  let catCounts = null;
  let catOverflow = null;
  let numericCols = null;
  let catCols = null;
  let filterFn = null;
  let groupByCol = (groupBy !== null && groupBy !== undefined) ? groupBy : null;
  let groupByColName = null;
  let groupStats = {};
  let groupCategories = {};

  // ── Calcol compiled function ──
  let calcolFn = null;
  let calcolNumCols = [];
  let calcolCatCols = [];

  function initStatsPhase() {
    const skip = skipCols ? new Set(skipCols.map(Number)) : new Set();
    numericCols = header.map((_, i) => i).filter(i => colTypes[i] === 'numeric' && !skip.has(i));
    catCols = header.map((_, i) => i).filter(i => colTypes[i] === 'categorical' && !skip.has(i));
    stats = {};
    for (const i of numericCols) {
      stats[i] = { count: 0, min: Infinity, max: -Infinity, m1: 0, m2: 0, m3: 0, m4: 0, nulls: 0, zeros: 0, td: newTDigest() };
    }
    catCounts = {};
    catOverflow = new Set();
    for (const i of catCols) catCounts[i] = {};

    // Compile calcol code block
    calcolFn = null;
    calcolNumCols = [];
    calcolCatCols = [];
    if (calcolCode && calcolMeta && calcolMeta.length > 0) {
      try {
        calcolFn = new Function(rowVarName, MATH_PREAMBLE + calcolCode);
      } catch(e) {
        calcolFn = null; // compilation failed — skip calcols silently
      }
      for (let ci = 0; ci < calcolMeta.length; ci++) {
        const cm = calcolMeta[ci];
        const idx = nCols + ci;
        if (cm.type === 'numeric') {
          calcolNumCols.push(idx);
          stats[idx] = { count: 0, min: Infinity, max: -Infinity, m1: 0, m2: 0, m3: 0, m4: 0, nulls: 0, zeros: 0, td: newTDigest() };
        } else {
          calcolCatCols.push(idx);
          catCounts[idx] = {};
        }
      }
    }

    // GroupBy init
    if (groupByCol !== null) {
      // Resolve groupBy column name (may be a calcol)
      if (groupByCol < nCols) {
        groupByColName = header[groupByCol];
      } else if (calcolMeta && groupByCol - nCols < calcolMeta.length) {
        groupByColName = calcolMeta[groupByCol - nCols].name;
      }
      const allNum = [...numericCols, ...calcolNumCols];
      const allCat = [...catCols, ...calcolCatCols];
      const gsColSet = groupStatsCols ? new Set(groupStatsCols) : null;
      for (const i of allNum) {
        if (!gsColSet || gsColSet.has(i)) groupStats[i] = new Map();
      }
      for (const i of allCat) {
        if (i === groupByCol) continue;
        if (!gsColSet || gsColSet.has(i)) groupCategories[i] = new Map();
      }
    }

    // Apply XYZ fallback now that types are known
    if (!hasXYZ && !xyzOverride) {
      xyzGuess = guessXYZ(header, colTypes);
      hasXYZ = xyzGuess.x >= 0 && xyzGuess.y >= 0 && xyzGuess.z >= 0;
    }

    // Compile filter
    const filterExpr = filter ? filter.expression : null;
    if (filterExpr) {
      try {
        filterFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + filterExpr + '); } catch(e) { return false; }');
      } catch(e) {
        self.postMessage({ type: 'error', message: 'Filter expression error: ' + e.message });
      }
    }

    // Build extended header/types for calcols
    const extHeader = [...header];
    const extTypes = [...colTypes];
    if (calcolMeta) {
      for (const cm of calcolMeta) {
        extHeader.push(cm.name);
        extTypes.push(cm.type);
      }
    }

    self.postMessage({ type: 'header', header: extHeader, delimiter, colTypes: extTypes, xyzGuess, rowVarName, calcolCount: calcolMeta ? calcolMeta.length : 0, origColCount: nCols });
  }

  function buildRow(fields) {
    const obj = {};
    for (let i = 0; i < nCols; i++) {
      const raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      obj[header[i]] = colTypes[i] === 'numeric' ? (NULL_SENTINELS.has(raw) ? NaN : (isNaN(Number(raw)) ? raw : Number(raw))) : raw;
    }
    // Evaluate calcol code block — mutates obj, adding new properties
    if (calcolFn) {
      obj.META = { cat: [], num: [] };
      try { calcolFn(obj); } catch(e) { /* calcol runtime error — skip */ }
      delete obj.META;
    }
    return obj;
  }

  function welfordAdd(s, v) {
    s.count++;
    if (v === 0) s.zeros++;
    if (v < s.min) s.min = v;
    if (v > s.max) s.max = v;
    const n = s.count;
    const delta = v - s.m1;
    const delta_n = delta / n;
    const delta_n2 = delta_n * delta_n;
    const term1 = delta * delta_n * (n - 1);
    s.m4 += term1 * delta_n2 * (n * n - 3 * n + 3) + 6 * delta_n2 * s.m2 - 4 * delta_n * s.m3;
    s.m3 += term1 * delta_n * (n - 2) - 3 * delta_n * s.m2;
    s.m2 += term1;
    s.m1 += delta_n;
    tdAdd(s.td, v);
  }

  function newAcc() {
    return { count: 0, min: Infinity, max: -Infinity, m1: 0, m2: 0, m3: 0, m4: 0, nulls: 0, zeros: 0, td: newTDigest() };
  }

  function getGroupAcc(map, gv) {
    let acc = map.get(gv);
    if (acc) return acc;
    if (map.size >= MAX_GROUPS) return null;
    acc = newAcc();
    map.set(gv, acc);
    return acc;
  }

  function finalizeAcc(s) {
    const n = s.count;
    const variance = n > 1 ? s.m2 / (n - 1) : null;
    const std = variance !== null ? Math.sqrt(variance) : null;
    let skewness = null;
    if (n > 2 && s.m2 > 0) {
      skewness = (Math.sqrt(n) * s.m3) / Math.pow(s.m2, 1.5);
      skewness *= Math.sqrt(n * (n - 1)) / (n - 2);
    }
    let kurtosis = null;
    if (n > 3 && s.m2 > 0) {
      kurtosis = (n * s.m4) / (s.m2 * s.m2) - 3;
      kurtosis = ((n - 1) / ((n - 2) * (n - 3))) * ((n + 1) * kurtosis + 6);
    }
    let quantiles = null;
    let centroids = null;
    if (n > 0) {
      tdFlush(s.td);
      quantiles = {
        p10: tdQuantile(s.td, 0.10),
        p25: tdQuantile(s.td, 0.25),
        p50: tdQuantile(s.td, 0.50),
        p75: tdQuantile(s.td, 0.75),
        p90: tdQuantile(s.td, 0.90)
      };
      centroids = s.td.centroids.map(c => [c.mean, c.count]);
    }
    return {
      count: n, nulls: s.nulls, zeros: s.zeros,
      min: n > 0 ? s.min : null, max: n > 0 ? s.max : null,
      mean: n > 0 ? s.m1 : null, std, skewness, kurtosis, quantiles, centroids
    };
  }

  function processCalcolStats(row) {
    const gv = groupByCol !== null ? String(row[groupByColName] ?? '') : null;
    for (const idx of calcolNumCols) {
      const cm = calcolMeta[idx - nCols];
      let v = row[cm.name];
      if (typeof v === 'boolean') v = v ? 1 : 0;
      const s = stats[idx];
      if (v === null || v === undefined || (typeof v !== 'number') || !isFinite(v)) { s.nulls++; if (gv !== null && groupStats[idx]) { const ga = getGroupAcc(groupStats[idx], gv); if (ga) ga.nulls++; } continue; }
      // Per-column value filters
      const cf = colFilters ? colFilters[idx] : null;
      if (cf) {
        if (cf.skipZeros && v === 0) { s.nulls++; if (gv !== null && groupStats[idx]) { const ga = getGroupAcc(groupStats[idx], gv); if (ga) ga.nulls++; } continue; }
        if (cf.skipNeg && v < 0) { s.nulls++; if (gv !== null && groupStats[idx]) { const ga = getGroupAcc(groupStats[idx], gv); if (ga) ga.nulls++; } continue; }
      }
      welfordAdd(s, v);
      if (gv !== null && groupStats[idx]) {
        const ga = getGroupAcc(groupStats[idx], gv);
        if (ga) welfordAdd(ga, v);
      }
    }
    for (const idx of calcolCatCols) {
      const cm = calcolMeta[idx - nCols];
      const v = row[cm.name];
      if (v === null || v === undefined || v === '') continue;
      const sv = String(v);
      const counts = catCounts[idx];
      if (catOverflow.has(idx)) continue;
      counts[sv] = (counts[sv] || 0) + 1;
      if (Object.keys(counts).length > MAX_UNIQUE_CAT) catOverflow.add(idx);
      // Cross-tab counting
      if (gv !== null && groupCategories[idx]) {
        let gm = groupCategories[idx].get(gv);
        if (!gm) { gm = {}; groupCategories[idx].set(gv, gm); }
        gm[sv] = (gm[sv] || 0) + 1;
      }
    }
  }

  function processRowStats(fields, row) {
    const gv = groupByCol !== null ? (groupByCol >= nCols && row ? String(row[groupByColName] ?? '') : (fields[groupByCol] || '').trim().replace(/^["']|["']$/g, '')) : null;
    for (const i of numericCols) {
      const raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      if (NULL_SENTINELS.has(raw)) { stats[i].nulls++; if (gv !== null && groupStats[i]) { const ga = getGroupAcc(groupStats[i], gv); if (ga) ga.nulls++; } continue; }
      const v = Number(raw);
      if (!isFinite(v)) { stats[i].nulls++; if (gv !== null && groupStats[i]) { const ga = getGroupAcc(groupStats[i], gv); if (ga) ga.nulls++; } continue; }
      const s = stats[i];
      // Per-column value filters
      const cf = colFilters ? colFilters[i] : null;
      if (cf) {
        if (cf.skipZeros && v === 0) { s.nulls++; if (gv !== null && groupStats[i]) { const ga = getGroupAcc(groupStats[i], gv); if (ga) ga.nulls++; } continue; }
        if (cf.skipNeg && v < 0) { s.nulls++; if (gv !== null && groupStats[i]) { const ga = getGroupAcc(groupStats[i], gv); if (ga) ga.nulls++; } continue; }
      }
      welfordAdd(s, v);
      if (gv !== null && groupStats[i]) {
        const ga = getGroupAcc(groupStats[i], gv);
        if (ga) welfordAdd(ga, v);
      }
    }
    for (const i of catCols) {
      const v = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      if (!v) continue;
      const cc = catCounts[i];
      if (catOverflow.has(i)) continue;
      cc[v] = (cc[v] || 0) + 1;
      if (Object.keys(cc).length > MAX_UNIQUE_CAT) catOverflow.add(i);
      // Cross-tab counting
      if (gv !== null && groupCategories[i]) {
        let gm = groupCategories[i].get(gv);
        if (!gm) { gm = {}; groupCategories[i].set(gv, gm); }
        gm[v] = (gm[v] || 0) + 1;
      }
    }
  }

  function processRowGeometry(fields) {
    if (!hasXYZ) return;
    for (const axis of ['x', 'y', 'z']) {
      const raw = (fields[xyzGuess[axis]] || '').trim();
      const v = Number(raw);
      if (isFinite(v)) {
        xyzSets[axis].add(v);
        if (precisionSampleCount < PRECISION_SAMPLE) {
          const dotIdx = raw.indexOf('.');
          if (dotIdx >= 0) {
            const dp = raw.length - dotIdx - 1;
            if (dp > maxDecimals[axis]) maxDecimals[axis] = dp;
          }
        }
        if (orderSampleCount < ORDER_SAMPLE) {
          if (prevCoord[axis] !== null && v !== prevCoord[axis]) transitions[axis]++;
          prevCoord[axis] = v;
        }
      }
    }
    // Collect DXYZ dimension values
    if (hasDXYZ) {
      for (const [dAxis, coordAxis] of [['dx','x'],['dy','y'],['dz','z']]) {
        if (dxyzGuess[dAxis] >= 0) {
          const raw = (fields[dxyzGuess[dAxis]] || '').trim();
          const v = Number(raw);
          if (isFinite(v) && v > 0) dxyzSets[dAxis].push(v);
        }
      }
    }
    if (orderSampleCount < ORDER_SAMPLE) orderSampleCount++;
    if (precisionSampleCount < PRECISION_SAMPLE) precisionSampleCount++;
  }

  // ── Single-pass stream ──
  const stream = csvFile.stream().pipeThrough(new TextDecoderStream());
  const reader = stream.getReader();
  let buffer = '', isFirstLine = true, rowCount = 0, totalRowCount = 0, totalChars = 0, commentCount = 0;
  let lastProgress = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    totalChars += value.length;
    buffer += value;

    const parts = buffer.split('\\n');
    buffer = parts.pop();

    for (const raw of parts) {
      const line = raw.replace(/\\r$/, '');
      if (line.startsWith('#')) { commentCount++; continue; }
      if (isFirstLine) { isFirstLine = false; continue; }
      if (!line) continue;

      const fields = line.split(delimiter);

      // Geometry — always, unfiltered
      processRowGeometry(fields);

      totalRowCount++;

      // ── Type detection phase ──
      if (!typesResolved) {
        detectRowCount++;
        for (let col = 0; col < nCols && col < fields.length; col++) {
          if (forced.has(col)) continue;
          const v = (fields[col] || '').trim().replace(/^["']|["']$/g, '');
          if (NULL_SENTINELS.has(v)) continue;
          if (!isNaN(Number(v))) detect_num[col]++;
          else detect_nonNum[col]++;
        }
        if (checkAllResolved() || detectRowCount >= TYPE_MAX_ROWS) {
          typesResolved = true;
          colTypes = resolveTypes();
          initStatsPhase();
        }
        continue; // skip stats during detection — negligible row loss
      }

      // ── Stats phase (filter + accumulate) ──
      const hasCalcols = calcolFn !== null;
      const needsRow = hasCalcols || filterFn || (groupByCol !== null && groupByCol >= nCols);
      let row = null;
      if (needsRow) row = buildRow(fields);
      if (filterFn) {
        if (!filterFn(row)) continue;
      }
      rowCount++;
      processRowStats(fields, row);
      if (hasCalcols) processCalcolStats(row);

      // Progress
      if (totalRowCount - lastProgress >= 25000) {
        lastProgress = totalRowCount;
        self.postMessage({ type: 'progress', percent: (totalChars / csvFile.size) * 100, rowCount: totalRowCount });
      }
    }
  }

  // Process last buffer line
  if (buffer) {
    const line = buffer.replace(/\\r$/, '');
    if (line && !line.startsWith('#') && !isFirstLine) {
      const fields = line.split(delimiter);
      processRowGeometry(fields);
      totalRowCount++;
      if (!typesResolved) {
        for (let col = 0; col < nCols && col < fields.length; col++) {
          if (forced.has(col)) continue;
          const v = (fields[col] || '').trim().replace(/^["']|["']$/g, '');
          if (NULL_SENTINELS.has(v)) continue;
          if (!isNaN(Number(v))) detect_num[col]++;
          else detect_nonNum[col]++;
        }
        typesResolved = true;
        colTypes = resolveTypes();
        initStatsPhase();
      } else {
        const hasCalcols2 = calcolFn !== null;
        const needsRow2 = hasCalcols2 || filterFn || (groupByCol !== null && groupByCol >= nCols);
        let row2 = null;
        if (needsRow2) row2 = buildRow(fields);
        let passFilter = true;
        if (filterFn) passFilter = filterFn(row2);
        if (passFilter) {
          rowCount++;
          processRowStats(fields, row2);
          if (hasCalcols2) processCalcolStats(row2);
        }
      }
    }
  }

  // Edge case: file was so small that detection never triggered
  if (!typesResolved) {
    typesResolved = true;
    colTypes = resolveTypes();
    initStatsPhase();
  }

  // Finalize stats
  const finalStats = {};
  const allNumCols = [...numericCols, ...calcolNumCols];
  for (const i of allNumCols) {
    finalStats[i] = finalizeAcc(stats[i]);
  }

  // Finalize group stats
  const finalGroupStats = {};
  const finalGroupCategories = {};
  if (groupByCol !== null) {
    for (const i of allNumCols) {
      if (!groupStats[i]) continue;
      const gMap = {};
      for (const [gv, acc] of groupStats[i]) {
        gMap[gv] = finalizeAcc(acc);
      }
      finalGroupStats[i] = gMap;
    }
    const gcCatCols = [...catCols, ...calcolCatCols];
    for (const i of gcCatCols) {
      if (!groupCategories[i]) continue;
      const gMap = {};
      for (const [gv, counts] of groupCategories[i]) {
        gMap[gv] = counts;
      }
      finalGroupCategories[i] = gMap;
    }
  }

  // Geometry
  // Build dims from DXYZ columns if available
  const dimsForGeometry = hasDXYZ ? {
    x: dxyzSets.dx.length > 0 ? dxyzSets.dx : null,
    y: dxyzSets.dy.length > 0 ? dxyzSets.dy : null,
    z: dxyzSets.dz.length > 0 ? dxyzSets.dz : null
  } : null;

  const geometry = hasXYZ ? computeGeometry(
    Array.from(xyzSets.x), Array.from(xyzSets.y), Array.from(xyzSets.z), maxDecimals, dimsForGeometry
  ) : null;

  // Coordinate ordering (most transitions = fastest varying = innermost loop)
  let coordOrder = null;
  if (hasXYZ && orderSampleCount > 10) {
    const axes = ['x', 'y', 'z'];
    const sorted = axes.slice().sort((a, b) => transitions[b] - transitions[a]);
    coordOrder = {
      fastest: sorted[0].toUpperCase(),
      middle: sorted[1].toUpperCase(),
      slowest: sorted[2].toUpperCase(),
      transitions: { x: transitions.x, y: transitions.y, z: transitions.z },
      sampleSize: orderSampleCount
    };
  }

  // Clean category counts
  const finalCats = {};
  const allCatCols = [...catCols, ...calcolCatCols];
  for (const i of allCatCols) {
    const cc = catCounts[i];
    finalCats[i] = { counts: cc, overflow: catOverflow.has(i) };
  }

  // Build extended header/types for complete message
  const extHeaderFinal = [...header];
  const extTypesFinal = [...colTypes];
  if (calcolMeta) {
    for (const cm of calcolMeta) {
      extHeaderFinal.push(cm.name);
      extTypesFinal.push(cm.type);
    }
  }

  const elapsed = performance.now() - startTime;

  self.postMessage({
    type: 'complete',
    stats: finalStats,
    geometry,
    coordOrder,
    maxDecimals,
    categories: finalCats,
    rowCount,
    totalRowCount,
    commentCount,
    elapsed,
    rowVarName,
    header: extHeaderFinal,
    colTypes: extTypesFinal,
    xyzGuess,
    zipName,
    calcolCount: calcolMeta ? calcolMeta.length : 0,
    origColCount: nCols,
    groupStats: groupByCol !== null ? finalGroupStats : null,
    groupCategories: groupByCol !== null ? finalGroupCategories : null,
    groupBy: groupByCol,
    dxyzGuess
  });
}

async function exportCSV(data) {
  const { file, filter, zipEntry, calcolCode, calcolMeta, resolvedTypes, exportCols } = data;
  const outDelim = data.delimiter || ',';
  const includeHeader = data.includeHeader !== false;
  const commentLines = data.commentLines || null;
  const quoteChar = data.quoteChar !== undefined ? data.quoteChar : '"';
  const lineEnding = data.lineEnding || '\\n';
  const nullValue = data.nullValue !== undefined ? data.nullValue : '';
  const precision = data.precision !== undefined ? data.precision : null;
  const decimalSep = data.decimalSep || '.';
  const startTime = performance.now();

  let csvFile = file;
  if (isZipFile(file)) {
    try { csvFile = await extractCSVFromZip(file, zipEntry); }
    catch(e) { self.postMessage({ type: 'error', message: e.message }); return; }
  }

  const sampleLines = await readSample(csvFile, 50);
  if (sampleLines.length < 2) {
    self.postMessage({ type: 'error', message: 'File appears empty or has no data rows.' });
    return;
  }

  const delimiter = detectDelimiter(sampleLines.slice(0, 20));
  const header = sampleLines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
  const nCols = header.length;

  let rowVarName = 'r';
  const colSet = new Set(header);
  for (const candidate of ['r', 'd', 'row', '_r', '_d']) {
    if (!colSet.has(candidate)) { rowVarName = candidate; break; }
  }

  const colTypes = resolvedTypes;

  // Compile calcol code block
  let calcolFn = null;
  if (calcolCode && calcolMeta && calcolMeta.length > 0) {
    try { calcolFn = new Function(rowVarName, MATH_PREAMBLE + calcolCode); }
    catch(e) { calcolFn = null; }
  }

  // Compile filter
  let filterFn = null;
  const filterExpr = filter ? filter.expression : null;
  if (filterExpr) {
    try {
      filterFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + filterExpr + '); } catch(e) { return false; }');
    } catch(e) {
      self.postMessage({ type: 'error', message: 'Filter expression error: ' + e.message });
      return;
    }
  }

  // Precompute escaped quoteChar regex
  var qcEscRe = null;
  if (quoteChar) {
    qcEscRe = new RegExp(quoteChar.replace(/[.*+?^\${}()|[\\]\\\\]/g, '\\\\$&'), 'g');
  }

  function buildRow(fields) {
    const obj = {};
    for (let i = 0; i < nCols; i++) {
      const raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      obj[header[i]] = colTypes[i] === 'numeric' ? (NULL_SENTINELS.has(raw) ? NaN : (isNaN(Number(raw)) ? raw : Number(raw))) : raw;
    }
    if (calcolFn) { obj.META = { cat: [], num: [] }; try { calcolFn(obj); } catch(e) { /* skip */ } delete obj.META; }
    return obj;
  }

  function csvEscape(v) {
    if (v === null || v === undefined || (typeof v === 'number' && !isFinite(v))) return nullValue;
    var s;
    if (typeof v === 'number') {
      s = precision !== null ? v.toFixed(precision) : String(v);
      if (decimalSep !== '.') s = s.replace('.', decimalSep);
    } else {
      s = String(v);
    }
    if (quoteChar && (s.indexOf(outDelim) >= 0 || s.indexOf(quoteChar) >= 0 || s.indexOf('\\n') >= 0 || s.indexOf('\\r') >= 0)) {
      return quoteChar + s.replace(qcEscRe, quoteChar + quoteChar) + quoteChar;
    }
    return s;
  }

  // Comment header lines
  if (commentLines && commentLines.length > 0) {
    const commentBlock = commentLines.map(function(l) { return '# ' + l; }).join(lineEnding) + lineEnding;
    self.postMessage({ type: 'export-chunk', csv: commentBlock });
  }

  // CSV header row
  if (includeHeader) {
    const headerLine = exportCols.map(function(c) { return csvEscape(c.outputName); }).join(outDelim) + lineEnding;
    self.postMessage({ type: 'export-chunk', csv: headerLine });
  }

  const stream = csvFile.stream().pipeThrough(new TextDecoderStream());
  const reader = stream.getReader();
  let buffer = '', isFirstLine = true, rowCount = 0, totalChars = 0;
  let lastProgress = 0;
  let chunkLines = [];
  const CHUNK_SIZE = 5000;

  function flushChunk() {
    if (chunkLines.length === 0) return;
    self.postMessage({ type: 'export-chunk', csv: chunkLines.join('') });
    chunkLines = [];
  }

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    totalChars += value.length;
    buffer += value;

    const parts = buffer.split('\\n');
    buffer = parts.pop();

    for (const raw of parts) {
      const line = raw.replace(/\\r$/, '');
      if (line.startsWith('#')) continue;
      if (isFirstLine) { isFirstLine = false; continue; }
      if (!line) continue;

      const fields = line.split(delimiter);
      const row = buildRow(fields);
      if (filterFn && !filterFn(row)) continue;

      rowCount++;
      const csvLine = exportCols.map(c => csvEscape(row[c.name])).join(outDelim) + lineEnding;
      chunkLines.push(csvLine);

      if (chunkLines.length >= CHUNK_SIZE) {
        flushChunk();
        self.postMessage({ type: 'export-progress', percent: (totalChars / csvFile.size) * 100, rowCount });
      }
    }
  }

  // Last buffer line
  if (buffer) {
    const line = buffer.replace(/\\r$/, '');
    if (line && !line.startsWith('#') && !isFirstLine) {
      const fields = line.split(delimiter);
      const row = buildRow(fields);
      if (!filterFn || filterFn(row)) {
        rowCount++;
        chunkLines.push(exportCols.map(c => csvEscape(row[c.name])).join(outDelim) + lineEnding);
      }
    }
  }
  flushChunk();

  const elapsed = performance.now() - startTime;
  self.postMessage({ type: 'export-complete', rowCount, elapsed });
}

async function swathAnalysis(data) {
  const { file, zipEntry, globalFilter, localFilter, calcolCode, calcolMeta, resolvedTypes,
          xyzCols, dxyzCols, axis, varCols, binWidth } = data;
  const startTime = performance.now();

  let csvFile = file;
  if (isZipFile(file)) {
    try { csvFile = await extractCSVFromZip(file, zipEntry); }
    catch(e) { self.postMessage({ type: 'error', message: e.message }); return; }
  }

  const sampleLines = await readSample(csvFile, 50);
  if (sampleLines.length < 2) { self.postMessage({ type: 'error', message: 'File appears empty.' }); return; }

  const delimiter = detectDelimiter(sampleLines.slice(0, 20));
  const header = sampleLines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
  const nCols = header.length;
  let rowVarName = 'r';
  const colSet = new Set(header);
  for (const c of ['r','d','row','_r','_d']) { if (!colSet.has(c)) { rowVarName = c; break; } }

  const colTypes = resolvedTypes;

  let calcolFn = null;
  if (calcolCode && calcolMeta && calcolMeta.length > 0) {
    try { calcolFn = new Function(rowVarName, MATH_PREAMBLE + calcolCode); }
    catch(e) { calcolFn = null; }
  }

  let globalFn = null, localFn = null;
  if (globalFilter) {
    try { globalFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + globalFilter.expression + '); } catch(e) { return false; }'); }
    catch(e) { self.postMessage({ type: 'error', message: 'Global filter error: ' + e.message }); return; }
  }
  if (localFilter) {
    try { localFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + localFilter + '); } catch(e) { return false; }'); }
    catch(e) { self.postMessage({ type: 'error', message: 'Local filter error: ' + e.message }); return; }
  }

  function buildRow(fields) {
    const obj = {};
    for (let i = 0; i < nCols; i++) {
      const raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      obj[header[i]] = colTypes[i] === 'numeric' ? (NULL_SENTINELS.has(raw) ? NaN : (isNaN(Number(raw)) ? raw : Number(raw))) : raw;
    }
    if (calcolFn) { obj.META = { cat: [], num: [] }; try { calcolFn(obj); } catch(e) { /* skip */ } delete obj.META; }
    return obj;
  }

  const axisIdx = xyzCols[axis];
  const axisName = header[axisIdx];

  // Resolve variable column names
  const varNames = varCols.map(vi => header[vi]);

  // Per-variable bins: Map<binIdx, {vars: {varIdx: {count,sum,sumSq,td}}, center}>
  const bins = new Map();

  function getBin(coord) {
    const idx = Math.floor(coord / binWidth);
    let b = bins.get(idx);
    if (!b) {
      b = { center: (idx + 0.5) * binWidth, vars: {} };
      for (const vi of varCols) {
        b.vars[vi] = { count: 0, sum: 0, sumSq: 0, td: newTDigest() };
      }
      bins.set(idx, b);
    }
    return b;
  }

  function processRow(row) {
    const coord = row[axisName];
    if (coord == null || isNaN(coord)) return;
    const bin = getBin(coord);
    for (let vi = 0; vi < varCols.length; vi++) {
      const val = row[varNames[vi]];
      if (val == null || typeof val !== 'number' || isNaN(val)) continue;
      const vb = bin.vars[varCols[vi]];
      vb.count++;
      vb.sum += val;
      vb.sumSq += val * val;
      tdAdd(vb.td, val);
    }
  }

  const stream = csvFile.stream().pipeThrough(new TextDecoderStream());
  const reader = stream.getReader();
  let buffer = '', isFirstLine = true, totalChars = 0, lastProgress = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    totalChars += value.length;
    buffer += value;
    const parts = buffer.split('\\n');
    buffer = parts.pop();

    for (const raw of parts) {
      const line = raw.replace(/\\r$/, '');
      if (line.startsWith('#')) continue;
      if (isFirstLine) { isFirstLine = false; continue; }
      if (!line) continue;

      const fields = line.split(delimiter);
      const row = buildRow(fields);
      if (globalFn && !globalFn(row)) continue;
      if (localFn && !localFn(row)) continue;
      processRow(row);

      if (totalChars - lastProgress >= 500000) {
        lastProgress = totalChars;
        self.postMessage({ type: 'swath-progress', percent: (totalChars / csvFile.size) * 100 });
      }
    }
  }
  if (buffer) {
    const line = buffer.replace(/\\r$/, '');
    if (line && !line.startsWith('#') && !isFirstLine) {
      const fields = line.split(delimiter);
      const row = buildRow(fields);
      if ((!globalFn || globalFn(row)) && (!localFn || localFn(row))) {
        processRow(row);
      }
    }
  }

  // Finalize: produce per-variable bin arrays
  const vars = {};
  for (const vi of varCols) {
    const arr = [];
    for (const [, b] of bins) {
      const vb = b.vars[vi];
      if (vb.count === 0) continue;
      tdFlush(vb.td);
      const mean = vb.sum / vb.count;
      const variance = vb.count > 1 ? (vb.sumSq - vb.sum * vb.sum / vb.count) / (vb.count - 1) : 0;
      arr.push({
        center: b.center, count: vb.count, mean,
        std: Math.sqrt(Math.max(0, variance)),
        centroids: vb.td.centroids.map(c => [c.mean, c.count])
      });
    }
    arr.sort((a, b) => a.center - b.center);
    vars[vi] = arr;
  }

  const elapsed = performance.now() - startTime;
  self.postMessage({ type: 'swath-complete', vars, elapsed, axis });
}

async function sectionAnalysis(data) {
  const { file, zipEntry, globalFilter, localFilter, calcolCode, calcolMeta, resolvedTypes,
          xyzCols, dxyzCols, normalAxis, slicePos, tolerance, varCol } = data;
  const startTime = performance.now();

  let csvFile = file;
  if (isZipFile(file)) {
    try { csvFile = await extractCSVFromZip(file, zipEntry); }
    catch(e) { self.postMessage({ type: 'error', message: e.message }); return; }
  }

  const sampleLines = await readSample(csvFile, 50);
  if (sampleLines.length < 2) { self.postMessage({ type: 'error', message: 'File appears empty.' }); return; }

  const delimiter = detectDelimiter(sampleLines.slice(0, 20));
  const header = sampleLines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
  const nCols = header.length;
  let rowVarName = 'r';
  const colSet = new Set(header);
  for (const c of ['r','d','row','_r','_d']) { if (!colSet.has(c)) { rowVarName = c; break; } }

  const colTypes = resolvedTypes;

  let calcolFn = null;
  if (calcolCode && calcolMeta && calcolMeta.length > 0) {
    try { calcolFn = new Function(rowVarName, MATH_PREAMBLE + calcolCode); }
    catch(e) { calcolFn = null; }
  }

  let globalFn = null, localFn = null;
  if (globalFilter) {
    try { globalFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + globalFilter.expression + '); } catch(e) { return false; }'); }
    catch(e) { self.postMessage({ type: 'error', message: 'Global filter error: ' + e.message }); return; }
  }
  if (localFilter) {
    try { localFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + localFilter + '); } catch(e) { return false; }'); }
    catch(e) { self.postMessage({ type: 'error', message: 'Local filter error: ' + e.message }); return; }
  }

  function buildRow(fields) {
    const obj = {};
    for (let i = 0; i < nCols; i++) {
      const raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      obj[header[i]] = colTypes[i] === 'numeric' ? (NULL_SENTINELS.has(raw) ? NaN : (isNaN(Number(raw)) ? raw : Number(raw))) : raw;
    }
    if (calcolFn) { obj.META = { cat: [], num: [] }; try { calcolFn(obj); } catch(e) { /* skip */ } delete obj.META; }
    return obj;
  }

  // Map normalAxis from int (0/1/2) to string key
  const axisKeys = ['x','y','z'];
  const normalAxisKey = axisKeys[normalAxis];
  const aToI = {x:0, y:1, z:2};

  // Determine axes: normal vs h vs v
  const axisMap = {
    z: { h: 'x', v: 'y' },  // plan view
    x: { h: 'y', v: 'z' },  // east section
    y: { h: 'x', v: 'z' }   // north section
  };
  const { h: hAxis, v: vAxis } = axisMap[normalAxisKey];
  const normalIdx = xyzCols[aToI[normalAxisKey]];
  const hIdx = xyzCols[aToI[hAxis]];
  const vIdx = xyzCols[aToI[vAxis]];
  const normalName = header[normalIdx];
  const hName = header[hIdx];
  const vName = header[vIdx];

  // Variable column name
  const varName = header[varCol];

  // DXYZ column names (may be -1 if not assigned)
  const dhIdx = dxyzCols ? dxyzCols[aToI[hAxis]] : -1;
  const dvIdx = dxyzCols ? dxyzCols[aToI[vAxis]] : -1;
  const dhName = dhIdx >= 0 ? header[dhIdx] : null;
  const dvName = dvIdx >= 0 ? header[dvIdx] : null;

  const halfTol = tolerance / 2;
  const blocks = [];

  const stream = csvFile.stream().pipeThrough(new TextDecoderStream());
  const reader = stream.getReader();
  let buf = '', isFirstLine = true, totalChars = 0, lastProgress = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    totalChars += value.length;
    buf += value;
    const parts = buf.split('\\n');
    buf = parts.pop();

    for (const raw of parts) {
      const line = raw.replace(/\\r$/, '');
      if (line.startsWith('#')) continue;
      if (isFirstLine) { isFirstLine = false; continue; }
      if (!line) continue;

      const fields = line.split(delimiter);
      const row = buildRow(fields);
      if (globalFn && !globalFn(row)) continue;
      if (localFn && !localFn(row)) continue;

      const nv = row[normalName];
      if (nv == null || isNaN(nv)) continue;
      if (nv < slicePos - halfTol || nv > slicePos + halfTol) continue;

      const h = row[hName];
      const v = row[vName];
      if (h == null || !isFinite(h) || v == null || !isFinite(v)) continue;

      const val = row[varName];
      const dh = dhName ? row[dhName] : 0;
      const dv = dvName ? row[dvName] : 0;

      blocks.push({
        h, v,
        dh: (typeof dh === 'number' && !isNaN(dh)) ? dh : 0,
        dv: (typeof dv === 'number' && !isNaN(dv)) ? dv : 0,
        val: (typeof val === 'number' && !isNaN(val)) ? val : null
      });

      if (totalChars - lastProgress >= 500000) {
        lastProgress = totalChars;
        self.postMessage({ type: 'section-progress', percent: (totalChars / csvFile.size) * 100 });
      }
    }
  }
  // Last buffer line
  if (buf) {
    const line = buf.replace(/\\r$/, '');
    if (line && !line.startsWith('#') && !isFirstLine) {
      const fields = line.split(delimiter);
      const row = buildRow(fields);
      if ((!globalFn || globalFn(row)) && (!localFn || localFn(row))) {
        const nv = row[normalName];
        if (nv != null && !isNaN(nv) && nv >= slicePos - halfTol && nv <= slicePos + halfTol) {
          const h = row[hName]; const v = row[vName];
          if (h != null && isFinite(h) && v != null && isFinite(v)) {
            const val = row[varName];
            const dh = dhName ? row[dhName] : 0;
            const dv = dvName ? row[dvName] : 0;
            blocks.push({
              h, v,
              dh: (typeof dh === 'number' && !isNaN(dh)) ? dh : 0,
              dv: (typeof dv === 'number' && !isNaN(dv)) ? dv : 0,
              val: (typeof val === 'number' && !isNaN(val)) ? val : null
            });
          }
        }
      }
    }
  }

  const elapsed = performance.now() - startTime;
  self.postMessage({
    type: 'section-complete',
    blocks,
    hAxis, vAxis, normalAxis, slicePos,
    blockCount: blocks.length,
    elapsed
  });
}

async function gtAnalysis(data) {
  var startTime = performance.now();
  var file = data.file, zipEntry = data.zipEntry, globalFilter = data.globalFilter,
      localFilter = data.localFilter, calcolCode = data.calcolCode, calcolMeta = data.calcolMeta,
      resolvedTypes = data.resolvedTypes,
      densityCol = data.densityCol, weightCol = data.weightCol,
      dxyzCols = data.dxyzCols, blockVolume = data.blockVolume,
      groupByCol = data.groupByCol != null ? data.groupByCol : null;

  // Multi-grade: gradeCols + gradeRanges arrays
  var gradeCols = data.gradeCols;
  var gradeRanges = data.gradeRanges;

  var csvFile = file;
  if (isZipFile(file)) {
    try { csvFile = await extractCSVFromZip(file, zipEntry); }
    catch(e) { self.postMessage({ type: 'error', message: e.message }); return; }
  }

  var sampleLines = await readSample(csvFile, 50);
  if (sampleLines.length < 2) { self.postMessage({ type: 'error', message: 'File appears empty.' }); return; }

  var delimiter = detectDelimiter(sampleLines.slice(0, 20));
  var header = sampleLines[0].split(delimiter).map(function(h) { return h.trim().replace(/^["']|["']$/g, ''); });
  var nCols = header.length;
  var rowVarName = 'r';
  var colSet = new Set(header);
  for (var ci = 0; ci < ['r','d','row','_r','_d'].length; ci++) {
    var cand = ['r','d','row','_r','_d'][ci];
    if (!colSet.has(cand)) { rowVarName = cand; break; }
  }

  var colTypes = resolvedTypes;

  var calcolFn = null;
  if (calcolCode && calcolMeta && calcolMeta.length > 0) {
    try { calcolFn = new Function(rowVarName, MATH_PREAMBLE + calcolCode); }
    catch(e) { calcolFn = null; }
  }

  var globalFn = null, localFn = null;
  if (globalFilter) {
    try { globalFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + globalFilter.expression + '); } catch(e) { return false; }'); }
    catch(e) { self.postMessage({ type: 'error', message: 'Global filter error: ' + e.message }); return; }
  }
  if (localFilter) {
    try { localFn = new Function(rowVarName, MATH_PREAMBLE + 'try { return !!(' + localFilter + '); } catch(e) { return false; }'); }
    catch(e) { self.postMessage({ type: 'error', message: 'Local filter error: ' + e.message }); return; }
  }

  function buildRow(fields) {
    var obj = {};
    for (var i = 0; i < nCols; i++) {
      var raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      obj[header[i]] = colTypes[i] === 'numeric' ? (NULL_SENTINELS.has(raw) ? NaN : (isNaN(Number(raw)) ? raw : Number(raw))) : raw;
    }
    if (calcolFn) { obj.META = { cat: [], num: [] }; try { calcolFn(obj); } catch(e) {} delete obj.META; }
    return obj;
  }

  // Resolve column names
  function resolveColName(idx) {
    if (idx >= nCols && calcolMeta) return calcolMeta[idx - nCols].name;
    return header[idx];
  }

  var densityColName = densityCol != null && densityCol >= 0 ? resolveColName(densityCol) : null;
  var weightColName = weightCol != null && weightCol >= 0 ? resolveColName(weightCol) : null;
  var dxyzNames = dxyzCols ? [header[dxyzCols[0]], header[dxyzCols[1]], header[dxyzCols[2]]] : null;

  // Resolve group-by column name
  var groupByColName = groupByCol !== null ? resolveColName(groupByCol) : null;
  var GT_MAX_GROUPS = 200;

  // Per-grade-variable bin arrays
  var N_BINS = 10000;
  var gradeInfo = [];
  for (var gi = 0; gi < gradeCols.length; gi++) {
    var gc = gradeCols[gi];
    var gr = gradeRanges[gi];
    var colName = resolveColName(gc);
    var bw = (gr.max - gr.min) / N_BINS;
    gradeInfo.push({
      colIdx: gc,
      colName: colName,
      gradeMin: gr.min,
      gradeMax: gr.max,
      binWidth: bw,
      groups: {} // groupVal -> { tonnageBins, metalBins }
    });
    // Create default (ungrouped) bins
    gradeInfo[gi].groups['__all__'] = {
      tonnageBins: new Float64Array(N_BINS),
      metalBins: new Float64Array(N_BINS)
    };
  }

  function getGroupBins(gInfo, gv) {
    var bins = gInfo.groups[gv];
    if (bins) return bins;
    if (Object.keys(gInfo.groups).length >= GT_MAX_GROUPS + 1) return null; // +1 for __all__
    bins = { tonnageBins: new Float64Array(N_BINS), metalBins: new Float64Array(N_BINS) };
    gInfo.groups[gv] = bins;
    return bins;
  }

  function processRowGt(row, tonnage) {
    var gv = groupByColName ? String(row[groupByColName] || '') : null;
    for (var gi = 0; gi < gradeInfo.length; gi++) {
      var info = gradeInfo[gi];
      var grade = row[info.colName];
      if (grade == null || typeof grade !== 'number' || !isFinite(grade)) continue;
      var metal = grade * tonnage;
      var binIdx = Math.floor((grade - info.gradeMin) / info.binWidth);
      if (binIdx < 0) binIdx = 0;
      if (binIdx >= N_BINS) binIdx = N_BINS - 1;
      // Always accumulate into __all__
      info.groups['__all__'].tonnageBins[binIdx] += tonnage;
      info.groups['__all__'].metalBins[binIdx] += metal;
      // Group bins
      if (gv !== null) {
        var gb = getGroupBins(info, gv);
        if (gb) {
          gb.tonnageBins[binIdx] += tonnage;
          gb.metalBins[binIdx] += metal;
        }
      }
    }
  }

  var stream = csvFile.stream().pipeThrough(new TextDecoderStream());
  var reader = stream.getReader();
  var buffer = '', isFirstLine = true, totalChars = 0, lastProgress = 0;

  while (true) {
    var res = await reader.read();
    if (res.done) break;
    totalChars += res.value.length;
    buffer += res.value;
    var parts = buffer.split('\\n');
    buffer = parts.pop();

    for (var pi = 0; pi < parts.length; pi++) {
      var line = parts[pi].replace(/\\r$/, '');
      if (line.startsWith('#')) continue;
      if (isFirstLine) { isFirstLine = false; continue; }
      if (!line) continue;

      var fields = line.split(delimiter);
      var row = buildRow(fields);
      if (globalFn && !globalFn(row)) continue;
      if (localFn && !localFn(row)) continue;

      // Compute tonnage for this block
      var volume = 1;
      if (dxyzNames) {
        var dx = row[dxyzNames[0]], dy = row[dxyzNames[1]], dz = row[dxyzNames[2]];
        if (typeof dx === 'number' && typeof dy === 'number' && typeof dz === 'number' && isFinite(dx) && isFinite(dy) && isFinite(dz)) {
          volume = Math.abs(dx) * Math.abs(dy) * Math.abs(dz);
        }
      } else if (blockVolume > 0) {
        volume = blockVolume;
      }
      var density = 1;
      if (densityColName) {
        var dv = row[densityColName];
        if (typeof dv === 'number' && isFinite(dv) && dv > 0) density = dv;
      }
      var weight = 1;
      if (weightColName) {
        var wv = row[weightColName];
        if (typeof wv === 'number' && isFinite(wv) && wv > 0) weight = wv;
      }
      var tonnage = volume * density * weight;
      processRowGt(row, tonnage);

      if (totalChars - lastProgress >= 500000) {
        lastProgress = totalChars;
        self.postMessage({ type: 'gt-progress', percent: (totalChars / csvFile.size) * 100 });
      }
    }
  }
  // Last buffer line
  if (buffer) {
    var lastLine = buffer.replace(/\\r$/, '');
    if (lastLine && !lastLine.startsWith('#') && !isFirstLine) {
      var lastFields = lastLine.split(delimiter);
      var lastRow = buildRow(lastFields);
      if ((!globalFn || globalFn(lastRow)) && (!localFn || localFn(lastRow))) {
        var lVol = 1;
        if (dxyzNames) {
          var ldx = lastRow[dxyzNames[0]], ldy = lastRow[dxyzNames[1]], ldz = lastRow[dxyzNames[2]];
          if (typeof ldx === 'number' && typeof ldy === 'number' && typeof ldz === 'number' && isFinite(ldx) && isFinite(ldy) && isFinite(ldz)) {
            lVol = Math.abs(ldx) * Math.abs(ldy) * Math.abs(ldz);
          }
        } else if (blockVolume > 0) {
          lVol = blockVolume;
        }
        var lDen = 1;
        if (densityColName) { var ldv = lastRow[densityColName]; if (typeof ldv === 'number' && isFinite(ldv) && ldv > 0) lDen = ldv; }
        var lWt = 1;
        if (weightColName) { var lwv = lastRow[weightColName]; if (typeof lwv === 'number' && isFinite(lwv) && lwv > 0) lWt = lwv; }
        var lTon = lVol * lDen * lWt;
        processRowGt(lastRow, lTon);
      }
    }
  }

  // Post-process: cumulative sums for each grade variable and group
  function buildResults(tonnageBins, metalBins, gradeMin, binWidth) {
    var cumTonnage = new Float64Array(N_BINS);
    var cumMetal = new Float64Array(N_BINS);
    cumTonnage[N_BINS - 1] = tonnageBins[N_BINS - 1];
    cumMetal[N_BINS - 1] = metalBins[N_BINS - 1];
    for (var i = N_BINS - 2; i >= 0; i--) {
      cumTonnage[i] = cumTonnage[i + 1] + tonnageBins[i];
      cumMetal[i] = cumMetal[i + 1] + metalBins[i];
    }
    var totalTonnage = cumTonnage[0];
    var results = [];
    for (var j = 0; j < N_BINS; j++) {
      results.push({
        cutoff: gradeMin + j * binWidth,
        tonnage: cumTonnage[j],
        grade: cumTonnage[j] > 0 ? cumMetal[j] / cumTonnage[j] : 0,
        metal: cumMetal[j]
      });
    }
    return { results: results, totalTonnage: totalTonnage };
  }

  var gradeResults = [];
  for (var gi = 0; gi < gradeInfo.length; gi++) {
    var info = gradeInfo[gi];
    var allBins = info.groups['__all__'];
    var allResult = buildResults(allBins.tonnageBins, allBins.metalBins, info.gradeMin, info.binWidth);
    var groupResults = null;
    if (groupByColName) {
      groupResults = {};
      for (var gv in info.groups) {
        if (gv === '__all__') continue;
        var gb = info.groups[gv];
        groupResults[gv] = buildResults(gb.tonnageBins, gb.metalBins, info.gradeMin, info.binWidth);
      }
    }
    gradeResults.push({
      colIdx: info.colIdx,
      colName: info.colName,
      results: allResult.results,
      totalTonnage: allResult.totalTonnage,
      gradeMin: info.gradeMin,
      gradeMax: info.gradeMax,
      binWidth: info.binWidth,
      groupResults: groupResults
    });
  }

  var elapsed = performance.now() - startTime;
  self.postMessage({
    type: 'gt-complete',
    gradeResults: gradeResults,
    grouped: groupByColName !== null,
    groupByColName: groupByColName,
    elapsed: elapsed
  });
}

self.onmessage = (e) => {
  if (e.data.mode === 'export') {
    exportCSV(e.data);
  } else if (e.data.mode === 'swath') {
    swathAnalysis(e.data);
  } else if (e.data.mode === 'section') {
    sectionAnalysis(e.data);
  } else if (e.data.mode === 'gt') {
    gtAnalysis(e.data);
  } else {
    const { file, xyzOverride, filter, typeOverrides, zipEntry, skipCols, colFilters, calcolCode, calcolMeta, groupBy, groupStatsCols, dxyzOverride } = e.data;
    analyze(file, xyzOverride, filter, typeOverrides, zipEntry, skipCols, colFilters, calcolCode, calcolMeta, groupBy, groupStatsCols, dxyzOverride);
  }
};
`;

// ─── Main App ──────────────────────────────────────────────────────────
const workerBlob = new Blob([WORKER_CODE], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(workerBlob);

let currentFile = null;
let currentHeader = [];
let currentColTypes = [];
let currentXYZ = { x: -1, y: -1, z: -1 };
let detectedXYZ = { x: -1, y: -1, z: -1 };
let currentFilter = null; // { expression: string }
let currentRowVar = 'r';
let worker = null;
let preflightData = null; // { header, sampleRows, autoTypes, delimiter, zipEntries, selectedZipEntry }

var HAS_FSAA = typeof window.showOpenFilePicker === 'function';

// Fuzzy subsequence match — returns true if all chars in query appear in order within target.
// Both should be lowercase. Empty query matches everything.
function fuzzyMatch(query, target) {
  if (!query) return true;
  var qi = 0;
  for (var ti = 0; ti < target.length && qi < query.length; ti++) {
    if (target[ti] === query[qi]) qi++;
  }
  return qi === query.length;
}

const $dropzone = document.getElementById('dropzone');
const $fileInput = document.getElementById('fileInput');
const $recentFiles = document.getElementById('recentFiles');
const $panelPreflight = document.getElementById('panelPreflight');
const $preflightZip = document.getElementById('preflightZip');
const $preflightHead = document.getElementById('preflightHead');
const $preflightPreview = document.getElementById('preflightPreview');
const $results = document.getElementById('results');
const $fileInfo = document.getElementById('fileInfo');
const $geoContent = document.getElementById('geoContent');
const $geoBadge = document.getElementById('geoBadge');
const $geoSection = document.getElementById('geoSection');
const $xyzConfig = document.getElementById('xyzConfig');
const $statsContent = document.getElementById('statsContent');
const $statsBadge = document.getElementById('statsBadge');
const $statsBody = document.getElementById('statsBody');
const $statsSidebar = document.getElementById('statsSidebar');
const $statsMain = document.getElementById('statsMain');
const $statsCdfPanel = document.getElementById('statsCdfPanel');
const $catBadge = document.getElementById('catBadge');
const $catBody = document.getElementById('catBody');
const $catSidebar = document.getElementById('catSidebar');
const $catColList = document.getElementById('catColList');
const $catColSearch = document.getElementById('catColSearch');
const $catMain = document.getElementById('catMain');
const $catToolbar = document.getElementById('catToolbar');
const $catMainContent = document.getElementById('catMainContent');
const $catChart = document.getElementById('catChart');
const $catValueTableWrap = document.getElementById('catValueTableWrap');
const $catValueSearch = document.getElementById('catValueSearch');
const $catValueTable = document.getElementById('catValueTable');
const $catColorPicker = document.getElementById('catColorPicker');
const $appFooter = document.getElementById('appFooter');
const $filterSection = document.getElementById('filterSection');
const $filterExpr = document.getElementById('filterExpr');
const $filterApply = document.getElementById('filterApply');
const $filterClear = document.getElementById('filterClear');
const $filterError = document.getElementById('filterError');
const $errorMsg = document.getElementById('errorMsg');
const $resultsToolbar = document.getElementById('resultsToolbar');
const $resultsFilename = document.getElementById('resultsFilename');
const $resultsRowInfo = document.getElementById('resultsRowInfo');
const $resultsTimeInfo = document.getElementById('resultsTimeInfo');
const $resultsMemInfo = document.getElementById('resultsMemInfo');
const $backToPreflight = document.getElementById('backToPreflight');
const $projectSave = document.getElementById('projectSave');
const $projectLoad = document.getElementById('projectLoad');
const $projectClear = document.getElementById('projectClear');
const $projectFileInput = document.getElementById('projectFileInput');
const $toolbarOverflow = document.getElementById('toolbarOverflow');
const $toolbarMenu = document.getElementById('toolbarMenu');
const $cdfModal = document.getElementById('cdfModal');
const $cdfTitle = document.getElementById('cdfTitle');
const $cdfBody = document.getElementById('cdfBody');
const $cdfClose = document.getElementById('cdfClose');
const $settingsModal = document.getElementById('settingsModal');
const $settingsClose = document.getElementById('settingsClose');
const $settingsBtn = document.getElementById('settingsBtn');
const $resultsTabs = document.getElementById('resultsTabs');
const $statsCatContent = document.getElementById('statsCatContent');
const $statsCatBadge = document.getElementById('statsCatBadge');
const $statsCatGroupBy = document.getElementById('statsCatGroupBy');
const $statsCatVarList = document.getElementById('statsCatVarList');
const $statsCatGroupList = document.getElementById('statsCatGroupList');
const $statsCatVarSearch = document.getElementById('statsCatVarSearch');
const $statsCatGroupSearch = document.getElementById('statsCatGroupSearch');
const $statsCatGroupAll = document.getElementById('statsCatGroupAll');
const $statsCatGroupNone = document.getElementById('statsCatGroupNone');
const $statsCatGroupSort = document.getElementById('statsCatGroupSort');
const $statsCatVarAll = document.getElementById('statsCatVarAll');
const $statsCatVarNone = document.getElementById('statsCatVarNone');
const $statsCatVarFilter = document.getElementById('statsCatVarFilter');
let lastDisplayedStats = null;
let lastDisplayedHeader = null;
let currentCalcolCode = '';
let currentCalcolMeta = []; // [{name, type}]
let currentOrigColCount = 0;
let lastCompleteData = null; // snapshot for cancel
let currentGroupBy = null; // column index for StatsCat grouping
let currentStatsCatVar = null; // selected numeric column index
let currentStatsCatChecked = null; // Set<string> of checked group values (null = all)
let lastStatsCatData = null; // cached full data for re-render
let statsCatGroupSortMode = null; // null = inherit from Categories tab, or 'count-desc'|'count-asc'|'alpha'|'custom'
let statsCatSelectedVars = new Set(); // col indices selected for group stats analysis
let statsCatCdfScale = 'linear'; // 'linear' or 'log'
let statsCatCdfManual = false;
let statsCatCdfMin = null;
let statsCatCdfMax = null;
let statsCatCrossMode = 'count'; // 'count', 'row', 'col'
let statsCatShowSelectedOnly = false;

// Categories tab state
let catFocusedCol = null;           // column index focused in main area
let catSortModes = {};              // { colName: 'count-desc'|'count-asc'|'alpha'|'custom' }
let catCustomOrders = {};           // { colName: [val1, val2, ...] }
let catColorOverrides = {};         // { colName: { value: '#hex' } }
let catChartShowAll = false;        // show all bars vs top 20
let _catEventsWired = false;

function getCategoryColor(colName, value, fallbackIdx) {
  if (catColorOverrides[colName] && catColorOverrides[colName][value])
    return catColorOverrides[colName][value];
  return STATSCAT_PALETTE[(fallbackIdx || 0) % STATSCAT_PALETTE.length];
}

// Statistics tab state
let statsSelectedVars = null;     // Set<colIdx> or null (= all)
let statsVisibleMetrics = null;   // Set<string> or null (= all)
let statsPercentiles = [25, 50, 75]; // current percentile list
let statsCdfSelected = new Set(); // Set<colIdx> toggled for CDF overlay
let statsCdfScale = 'linear';     // 'linear' | 'log'

// Export
let exportWorker = null;
let exportColumns = []; // [{name, outputName, type, selected, isCalcol}]
let exportDelimiter = ',';
let exportIncludeHeader = true;
let exportCommentHeader = false;
let exportCommentText = '';
let exportQuoteChar = '"';       // '"', "'", '' (none)
let exportLineEnding = '\n';     // '\n' or '\r\n'
let exportNullValue = '';        // string to write for NaN/null
let exportPrecision = null;      // null = auto (passthrough), or integer (decimal places)
let exportDecimalSep = '.';      // '.' or ','
let exportSourcePrecision = {};  // {colName: maxDp} detected from preflight
const $exportColList = document.getElementById('exportColList');
const $exportBadge = document.getElementById('exportBadge');
const $exportDownload = document.getElementById('exportDownload');
const $exportInfo = document.getElementById('exportInfo');
const $exportProgress = document.getElementById('exportProgress');
const $exportProgressLabel = document.getElementById('exportProgressLabel');
const $exportProgressFill = document.getElementById('exportProgressFill');
const $exportColSearch = document.getElementById('exportColSearch');
const $exportBody = document.getElementById('exportBody');
const $exportToolbar = document.getElementById('exportToolbar');
const $exportRowPreview = document.getElementById('exportRowPreview');
const $exportIncludeHeader = document.getElementById('exportIncludeHeader');
const $exportCommentHeader = document.getElementById('exportCommentHeader');
const $exportCommentSection = document.getElementById('exportCommentSection');
const $exportCommentText = document.getElementById('exportCommentText');
const $exportCommentGenerate = document.getElementById('exportCommentGenerate');
const $exportCustomDelim = document.getElementById('exportCustomDelim');
const $exportFormatSection = document.getElementById('exportFormatSection');
const $exportPreview = document.getElementById('exportPreview');
const $exportPreviewPre = document.getElementById('exportPreviewPre');
const $exportPreviewInfo = document.getElementById('exportPreviewInfo');
const $exportPrecisionSelect = document.getElementById('exportPrecisionSelect');
const $exportPrecisionInput = document.getElementById('exportPrecisionInput');
const $exportNullSelect = document.getElementById('exportNullSelect');
const $exportNullInput = document.getElementById('exportNullInput');
const $exportPrecisionWarn = document.getElementById('exportPrecisionWarn');

// DXYZ state
let currentDXYZ = { dx: -1, dy: -1, dz: -1 };

// Swath state
let swathWorker = null;
let lastSwathData = null;
let swathExprController = null;

// GT state
let gtWorker = null;
let lastGtData = null;
let gtExprController = null;

// Section state
let sectionBlocks = null;
let sectionTransform = null;
let sectionDefaultBlockSize = null;
let sectionWorker = null;
let sectionExprController = null;

// Project save/load
let pendingProjectRestore = null;
let autoSaveTimer = null;

const STATSCAT_PALETTE = [
  '#4a9eff','#34d399','#f87171','#a78bfa','#fb923c',
  '#22d3ee','#f472b6','#facc15','#818cf8','#2dd4bf',
  '#e879f9','#84cc16','#f97316','#38bdf8','#c084fc',
  '#a3e635','#fb7185','#67e8f9','#d946ef','#fbbf24'
];

// Calcol editor DOM refs
const $calcolBadge = document.getElementById('calcolBadge');
const $calcolCodeArea = document.getElementById('calcolCodeArea');
const $calcolCodePre = document.getElementById('calcolCodePre');
const $calcolSimBtn = document.getElementById('calcolSimBtn');
const $calcolError = document.getElementById('calcolError');
const $calcolVarBrowser = document.getElementById('calcolVarBrowser');
const $calcolVarSearch = document.getElementById('calcolVarSearch');
const $calcolVarList = document.getElementById('calcolVarList');
const $calcolFnList = document.getElementById('calcolFnList');
const $calcolDetected = document.getElementById('calcolDetected');
const $calcolPreviewTable = document.getElementById('calcolPreviewTable');
const $calcolDataSrc = document.getElementById('calcolDataSrc');
const $calcolAc = document.getElementById('calcolAc');

// Tab switching
function switchTab(tabId) {
  $resultsTabs.querySelectorAll('.results-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tabId));
  document.querySelectorAll('.results-panel').forEach(p => p.classList.toggle('active', p.dataset.tab === tabId));
}
$resultsTabs.addEventListener('click', (e) => {
  const tab = e.target.closest('.results-tab');
  if (tab) {
    switchTab(tab.dataset.tab);
    if (typeof autoSaveProject === 'function') autoSaveProject();
  }
});

// ─── Preflight: main-thread helpers ────────────────────────────────────

const DELIMITERS_MAIN = [',', '\t', ';', '|', ' '];
const NULL_SENTINELS_MAIN = new Set(['', 'NA', 'NaN', 'na', 'nan', 'N/A', 'n/a', 'null', 'NULL', '*', '-', '-999', '-99', '#N/A', 'VOID', 'void', '-1.0e+32', '-1e+32', '1e+31', '-9999', '-99999']);

function detectDelimiterMain(lines) {
  let best = ',', bestScore = -1;
  for (const d of DELIMITERS_MAIN) {
    const counts = lines.map(l => l.split(d).length);
    if (counts[0] < 2) continue;
    const allSame = counts.every(c => c === counts[0]);
    const score = allSame ? counts[0] * 1000 + counts.length : counts[0];
    if (score > bestScore) { bestScore = score; best = d; }
  }
  return best;
}

function autoDetectTypes(header, rows) {
  const types = [];
  for (let col = 0; col < header.length; col++) {
    let num = 0, nonNum = 0;
    for (const row of rows) {
      if (col >= row.length) continue;
      const v = row[col].trim();
      if (NULL_SENTINELS_MAIN.has(v)) continue;
      if (!isNaN(Number(v))) num++;
      else nonNum++;
    }
    const total = num + nonNum;
    if (total === 0) types.push('numeric');
    else if (nonNum === 0) types.push('numeric');
    else if (num === 0) types.push('categorical');
    else types.push((num / total > 0.8) ? 'numeric' : 'categorical');
  }
  return types;
}

function readUint16(buf, off) { return buf[off] | (buf[off+1] << 8); }
function readUint32(buf, off) { return (buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24)) >>> 0; }

async function listZipEntries(file) {
  const tailSize = Math.min(65557, file.size);
  const tail = new Uint8Array(await file.slice(file.size - tailSize).arrayBuffer());
  let eocdPos = -1;
  for (let i = tail.length - 22; i >= 0; i--) {
    if (readUint32(tail, i) === 0x06054b50) { eocdPos = i; break; }
  }
  if (eocdPos < 0) throw new Error('Not a valid ZIP file');
  const cdEntries = readUint16(tail, eocdPos + 8);
  const cdSize = readUint32(tail, eocdPos + 12);
  const cdOffset = readUint32(tail, eocdPos + 16);
  const cd = new Uint8Array(await file.slice(cdOffset, cdOffset + cdSize).arrayBuffer());
  const entries = [];
  let pos = 0;
  for (let i = 0; i < cdEntries && pos < cd.length; i++) {
    if (readUint32(cd, pos) !== 0x02014b50) break;
    const method = readUint16(cd, pos + 10);
    const compSize = readUint32(cd, pos + 20);
    const uncompSize = readUint32(cd, pos + 24);
    const nameLen = readUint16(cd, pos + 28);
    const extraLen = readUint16(cd, pos + 30);
    const commentLen = readUint16(cd, pos + 32);
    const localOffset = readUint32(cd, pos + 42);
    const name = new TextDecoder().decode(cd.slice(pos + 46, pos + 46 + nameLen));
    if (!name.endsWith('/') && !name.startsWith('__MACOSX') && !name.startsWith('.')) {
      entries.push({ name, method, compSize, uncompSize, localOffset });
    }
    pos += 46 + nameLen + extraLen + commentLen;
  }
  return entries;
}

async function readPreviewFromZipEntry(file, entry, maxLines) {
  const lh = new Uint8Array(await file.slice(entry.localOffset, entry.localOffset + 30).arrayBuffer());
  const lhNameLen = readUint16(lh, 26);
  const lhExtraLen = readUint16(lh, 28);
  const dataStart = entry.localOffset + 30 + lhNameLen + lhExtraLen;
  const compSlice = file.slice(dataStart, dataStart + entry.compSize);
  let stream;
  if (entry.method === 0) stream = compSlice.stream();
  else if (entry.method === 8) stream = compSlice.stream().pipeThrough(new DecompressionStream('deflate-raw'));
  else throw new Error('Unsupported compression method');
  return readLinesFromStream(stream, maxLines);
}

async function readLinesFromStream(stream, maxLines, captureComments) {
  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();
  let buf = '', lines = [], commentLines = [], headerReached = false;
  while (lines.length < maxLines + 1) {
    const { done, value } = await reader.read();
    if (done) break;
    buf += value;
    const parts = buf.split('\n');
    buf = parts.pop();
    for (const p of parts) {
      const trimmed = p.replace(/\r$/, '');
      if (trimmed.startsWith('#')) {
        if (captureComments && !headerReached) commentLines.push(trimmed.replace(/^#\s?/, ''));
        continue;
      }
      headerReached = true;
      lines.push(trimmed);
      if (lines.length >= maxLines + 1) break;
    }
  }
  if (buf && lines.length < maxLines + 1) {
    const trimmed = buf.replace(/\r$/, '');
    if (trimmed.startsWith('#')) {
      if (captureComments && !headerReached) commentLines.push(trimmed.replace(/^#\s?/, ''));
    } else {
      lines.push(trimmed);
    }
  }
  reader.cancel();
  if (captureComments) return { lines, commentLines };
  return lines;
}

const CSV_EXTENSIONS_MAIN = /\.(csv|txt|dat|tsv)$/i;

// Columns that should NOT get default >0 filtering
const NOFILT_RE = /^(id|index|row|block.?id|parent|d[xyz]|dim[xyz]?|size[xyz]?|n[xyz]|i[xyz]|ij[k]?|count|flag|code|mask|domain|[xyz]inc|[xyz]dis|[xyz]len|[xyz]size|d[_-]?[xyz]|[xyz][_-]?dim|[xyz][_-]?size|size[_-]?[xyz])$/i;

function buildDefaultColFilters(header, autoTypes, xyz) {
  const xyzSet = new Set([xyz.x, xyz.y, xyz.z].filter(v => v >= 0));
  const filters = {};
  for (let i = 0; i < header.length; i++) {
    if (autoTypes[i] !== 'numeric') continue;
    if (xyzSet.has(i)) continue;
    if (NOFILT_RE.test(header[i])) continue;
    filters[i] = { skipZeros: true, skipNeg: true };
  }
  return filters;
}

function isFilterableCol(header, i, autoTypes, typeOverrides, xyz, skipCols) {
  const t = typeOverrides[i] || autoTypes[i];
  if (t !== 'numeric') return false;
  if (skipCols.has(i)) return false;
  const xyzSet = new Set([xyz.x, xyz.y, xyz.z].filter(v => v >= 0));
  if (xyzSet.has(i)) return false;
  if (NOFILT_RE.test(header[i])) return false;
  return true;
}

const XYZ_PATTERNS_MAIN = {
  x: [/^x$/i, /^xc$/i, /^x[_-]?cent/i, /^mid[_-]?x$/i, /^centroid[_-]?x$/i, /^east/i, /^x[_-]?coord$/i],
  y: [/^y$/i, /^yc$/i, /^y[_-]?cent/i, /^mid[_-]?y$/i, /^centroid[_-]?y$/i, /^north/i, /^y[_-]?coord$/i],
  z: [/^z$/i, /^zc$/i, /^z[_-]?cent/i, /^mid[_-]?z$/i, /^centroid[_-]?z$/i, /^elev/i, /^rl$/i, /^z[_-]?coord$/i, /^level$/i, /^bench$/i]
};

function guessXYZMain(header, types) {
  const result = { x: -1, y: -1, z: -1 };
  for (const axis of ['x', 'y', 'z']) {
    for (const pat of XYZ_PATTERNS_MAIN[axis]) {
      const idx = header.findIndex((h, i) => types[i] === 'numeric' && pat.test(h.trim()));
      if (idx >= 0) { result[axis] = idx; break; }
    }
  }
  if (result.x < 0 || result.y < 0 || result.z < 0) {
    const numCols = header.map((_, i) => i).filter(i => types[i] === 'numeric');
    if (numCols.length >= 3 && result.x < 0 && result.y < 0 && result.z < 0) {
      result.x = numCols[0]; result.y = numCols[1]; result.z = numCols[2];
    }
  }
  return result;
}

const DXYZ_PATTERNS_MAIN = {
  dx: [/^dx$/i, /^xinc$/i, /^xdis$/i, /^xsize$/i, /^dimx$/i, /^xlen$/i, /^x[_-]?dim$/i, /^x[_-]?size$/i, /^d[_-]?x$/i, /^size[_-]?x$/i],
  dy: [/^dy$/i, /^yinc$/i, /^ydis$/i, /^ysize$/i, /^dimy$/i, /^ylen$/i, /^y[_-]?dim$/i, /^y[_-]?size$/i, /^d[_-]?y$/i, /^size[_-]?y$/i],
  dz: [/^dz$/i, /^zinc$/i, /^zdis$/i, /^zsize$/i, /^dimz$/i, /^zlen$/i, /^z[_-]?dim$/i, /^z[_-]?size$/i, /^d[_-]?z$/i, /^size[_-]?z$/i]
};

function guessDXYZMain(header, types) {
  const result = { dx: -1, dy: -1, dz: -1 };
  for (const axis of ['dx', 'dy', 'dz']) {
    for (const pat of DXYZ_PATTERNS_MAIN[axis]) {
      const idx = header.findIndex((h, i) => types[i] === 'numeric' && pat.test(h.trim()));
      if (idx >= 0) { result[axis] = idx; break; }
    }
  }
  return result;
}

async function runPreflight(file) {
  const isZip = file.name.toLowerCase().endsWith('.zip') || file.type === 'application/zip';
  let zipEntries = null;
  let lines;

  let commentLines = [];
  if (isZip) {
    zipEntries = await listZipEntries(file);
    const csvEntries = zipEntries.filter(e => CSV_EXTENSIONS_MAIN.test(e.name));
    if (csvEntries.length === 0) throw new Error('No CSV/TXT/DAT files found in ZIP. Contents: ' + zipEntries.map(e => e.name).join(', '));
    // Preview the first CSV entry
    lines = await readPreviewFromZipEntry(file, csvEntries[0], 100);
  } else {
    // Read first ~64KB for preview, capture leading comment lines
    const result = await readLinesFromStream(file.slice(0, 256 * 1024).stream(), 100, true);
    lines = result.lines;
    commentLines = result.commentLines;
  }

  if (lines.length < 2) throw new Error('File appears empty or has no data rows.');

  const delimiter = detectDelimiterMain(lines.slice(0, 20));
  const header = lines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
  const sampleRows = lines.slice(1)
    .filter(l => l.trim())
    .map(l => l.split(delimiter).map(f => f.trim().replace(/^["']|["']$/g, '')));
  const autoTypes = autoDetectTypes(header, sampleRows);
  const xyzGuess = guessXYZMain(header, autoTypes);
  const dxyzGuess = guessDXYZMain(header, autoTypes);

  // Determine which numeric columns should default to >0 filtering
  const defaultFilters = buildDefaultColFilters(header, autoTypes, xyzGuess);

  return {
    header,
    sampleRows,
    autoTypes,
    delimiter,
    zipEntries: zipEntries ? zipEntries.filter(e => CSV_EXTENSIONS_MAIN.test(e.name)) : null,
    selectedZipEntry: zipEntries ? zipEntries.filter(e => CSV_EXTENSIONS_MAIN.test(e.name))[0]?.name : null,
    typeOverrides: {},
    xyz: { ...xyzGuess },
    dxyz: { ...dxyzGuess },
    skipCols: new Set(),
    colFilters: defaultFilters,
    commentLines
  };
}

function renderPreflight(data) {
  preflightData = data;
  if (!data.colFilters) data.colFilters = {};

  // ZIP file selector
  if (data.zipEntries && data.zipEntries.length > 1) {
    const opts = data.zipEntries.map(e =>
      `<option value="${esc(e.name)}" ${e.name === data.selectedZipEntry ? 'selected' : ''}>${esc(e.name)}</option>`
    ).join('');
    $preflightZip.innerHTML = `ZIP: <select id="zipSelect">${opts}</select>` +
      `<span class="zip-size">${data.zipEntries.length} files</span>`;
    document.getElementById('zipSelect').addEventListener('change', async (e) => {
      const name = e.target.value;
      data.selectedZipEntry = name;
      const entry = data.zipEntries.find(z => z.name === name);
      try {
        const lines = await readPreviewFromZipEntry(currentFile, entry, 100);
        const delimiter = detectDelimiterMain(lines.slice(0, 20));
        data.header = lines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
        data.sampleRows = lines.slice(1).filter(l => l.trim())
          .map(l => l.split(delimiter).map(f => f.trim().replace(/^["']|["']$/g, '')));
        data.delimiter = delimiter;
        data.autoTypes = autoDetectTypes(data.header, data.sampleRows);
        data.typeOverrides = {};
        data.skipCols = new Set();
        data.xyz = guessXYZMain(data.header, data.autoTypes);
        data.colFilters = buildDefaultColFilters(data.header, data.autoTypes, data.xyz);
        renderPreflightSidebar(data);
        renderPreflightTable(data);
      } catch(err) {
        $preflightPreview.innerHTML = `<div style="padding:1rem;color:var(--red)">${esc(err.message)}</div>`;
      }
    });
  } else if (data.zipEntries && data.zipEntries.length === 1) {
    $preflightZip.innerHTML = `ZIP: <strong style="color:var(--fg-bright)">${esc(data.zipEntries[0].name)}</strong>` +
      `<span class="zip-size">${formatSize(data.zipEntries[0].uncompSize)}</span>`;
  } else {
    $preflightZip.innerHTML = '';
  }
  $preflightHead.style.display = $preflightZip.innerHTML ? '' : 'none';

  renderPreflightSidebar(data);
  renderPreflightTable(data);
}

const $preflightSidebar = document.getElementById('preflightSidebar');

function renderPreflightSidebar(data) {
  const { header, autoTypes, typeOverrides, skipCols, colFilters } = data;
  const enabledCount = header.length - skipCols.size;

  let html = `<div class="pf-sidebar-section">
    <div class="pf-sidebar-section-title">Coordinate Axes</div>
    <div id="pfXyzWrap"></div>
  </div>`;

  html += `<div class="pf-sidebar-section">
    <div class="pf-sidebar-section-title">Block Dimensions</div>
    <div id="pfDxyzWrap"></div>
  </div>`;

  // Column list header with search
  html += `<div class="pf-sidebar-section" style="padding-bottom:0.3rem">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.35rem">
      <div class="pf-sidebar-section-title" style="margin:0">Columns</div>
      <div class="pf-sidebar-actions">
        <button id="pfSelectAll">all</button>
        <button id="pfSelectNone">none</button>
        <span class="pf-col-count"><span id="pfEnabledCount">${enabledCount}</span>/${header.length}</span>
      </div>
    </div>
    <input type="text" class="pf-search" id="pfSearch" placeholder="Search columns…" autocomplete="off" spellcheck="false">
    <div class="pf-bulk-filters">
      <button id="pfFilterAllGt0" title="Set >0 filter on all grade columns">&gt;0 all</button>
      <button id="pfFilterClear" title="Clear all value filters">clear filters</button>
      <span class="pf-filter-count"></span>
    </div>
  </div>`;

  // Column list — always render both filter buttons; hide via class when not filterable
  html += '<div class="pf-col-list" id="pfColList">';
  for (let i = 0; i < header.length; i++) {
    const currentType = typeOverrides[i] || autoTypes[i];
    const label = currentType === 'numeric' ? 'NUM' : 'CAT';
    const isSkipped = skipCols.has(i);
    const cf = colFilters[i] || {};
    const filterable = isFilterableCol(header, i, autoTypes, typeOverrides, data.xyz, skipCols);
    const hideCls = filterable ? '' : ' pf-filter-hidden';
    html += `<div class="pf-col-item${isSkipped ? ' skipped' : ''}" data-col="${i}" data-name="${esc(header[i]).toLowerCase()}">
      <span class="col-idx">${i}</span>
      <input type="checkbox" class="pf-col-check" data-col="${i}" ${!isSkipped ? 'checked' : ''}>
      <span class="pf-col-name" title="${esc(header[i])}">${esc(header[i])}</span>
      <div class="pf-col-controls">
        <button class="pf-filter-btn${cf.skipNeg ? ' active' : ''}${hideCls}" data-col="${i}" data-filter="skipNeg" title="Exclude negatives">≥0</button>
        <button class="pf-filter-btn${cf.skipZeros ? ' active' : ''}${hideCls}" data-col="${i}" data-filter="skipZeros" title="Exclude zeros">≠0</button>
        <button class="type-toggle" data-col="${i}" data-type="${currentType}">${label}</button>
      </div>
    </div>`;
  }
  html += '</div>';


  $preflightSidebar.innerHTML = html;

  // Build XYZ and DXYZ dropdowns and update counts
  rebuildPfXyz(data);
  rebuildPfDxyz(data);
  updatePfCounts(data);

  // === Wire event delegation (once per render) ===

  const $pfColList = document.getElementById('pfColList');

  // Delegated click on column list: type toggles + filter buttons
  $pfColList.addEventListener('click', (e) => {
    const btn = e.target.closest('.type-toggle');
    if (btn) { handlePfTypeToggle(btn, data); return; }
    const fbtn = e.target.closest('.pf-filter-btn');
    if (fbtn) { handlePfFilterBtn(fbtn, data); return; }
  });

  // Delegated change on column list: checkboxes
  $pfColList.addEventListener('change', (e) => {
    const cb = e.target.closest('.pf-col-check');
    if (cb) handlePfCheckbox(cb, data);
  });

  // Search
  const $search = document.getElementById('pfSearch');
  $search.addEventListener('input', () => {
    const q = $search.value.toLowerCase().trim();
    $pfColList.querySelectorAll('.pf-col-item').forEach(el => {
      el.style.display = (!q || el.dataset.name.includes(q)) ? '' : 'none';
    });
    // Update All/None labels based on search state
    const $all = document.getElementById('pfSelectAll');
    const $none = document.getElementById('pfSelectNone');
    if ($all) $all.textContent = q ? 'all visible' : 'all';
    if ($none) $none.textContent = q ? 'none visible' : 'none';
  });
  $search.addEventListener('keydown', (e) => { if (e.key === 'Enter') e.stopPropagation(); });

  // Select all / none — search-aware
  document.getElementById('pfSelectAll').addEventListener('click', () => handlePfSelectAll(data));
  document.getElementById('pfSelectNone').addEventListener('click', () => handlePfSelectNone(data));

  // Bulk filter buttons
  document.getElementById('pfFilterAllGt0').addEventListener('click', () => handlePfBulkFilterAll(data));
  document.getElementById('pfFilterClear').addEventListener('click', () => handlePfBulkFilterClear(data));

}

// --- Preflight sidebar helper functions ---

function rebuildPfXyz(data) {
  const { header, autoTypes, typeOverrides, skipCols } = data;
  const types = header.map((_, i) => typeOverrides[i] || autoTypes[i]);
  const numCols = header.map((_, i) => i).filter(i => types[i] === 'numeric' && !skipCols.has(i));

  function makeAxisSelect(axis) {
    const current = data.xyz[axis];
    let opts = `<option value="-1" ${current < 0 ? 'selected' : ''}>—</option>`;
    for (const i of numCols) {
      opts += `<option value="${i}" ${i === current ? 'selected' : ''}>${esc(header[i])}</option>`;
    }
    return `<label><span class="axis-label">${axis.toUpperCase()}</span><select data-axis="${axis}">${opts}</select></label>`;
  }

  const wrap = document.getElementById('pfXyzWrap');
  if (!wrap) return;
  wrap.innerHTML = `<div class="pf-xyz-row">${makeAxisSelect('x')}${makeAxisSelect('y')}${makeAxisSelect('z')}</div>`;
  wirePfXyzHandlers(data);
}

function wirePfXyzHandlers(data) {
  const wrap = document.getElementById('pfXyzWrap');
  if (!wrap) return;
  wrap.querySelectorAll('select').forEach(sel => {
    sel.addEventListener('change', () => {
      data.xyz[sel.dataset.axis] = parseInt(sel.value);
      updateAllFilterButtonVisibility(data);
      updatePfCounts(data);
      markAnalysisStale();
    });
  });
}

function rebuildPfDxyz(data) {
  const { header, autoTypes, typeOverrides, skipCols } = data;
  if (!data.dxyz) data.dxyz = { dx: -1, dy: -1, dz: -1 };
  const types = header.map((_, i) => typeOverrides[i] || autoTypes[i]);
  const numCols = header.map((_, i) => i).filter(i => types[i] === 'numeric' && !skipCols.has(i));

  function makeDAxisSelect(axis) {
    const current = data.dxyz[axis];
    let opts = `<option value="-1" ${current < 0 ? 'selected' : ''}>None</option>`;
    for (const i of numCols) {
      opts += `<option value="${i}" ${i === current ? 'selected' : ''}>${esc(header[i])}</option>`;
    }
    return `<label><span class="axis-label">${axis.toUpperCase()}</span><select data-daxis="${axis}">${opts}</select></label>`;
  }

  const wrap = document.getElementById('pfDxyzWrap');
  if (!wrap) return;
  wrap.innerHTML = `<div class="pf-xyz-row">${makeDAxisSelect('dx')}${makeDAxisSelect('dy')}${makeDAxisSelect('dz')}</div>`;
  wrap.querySelectorAll('select').forEach(sel => {
    sel.addEventListener('change', () => {
      data.dxyz[sel.dataset.daxis] = parseInt(sel.value);
      markAnalysisStale();
    });
  });
}

function updatePfCounts(data) {
  const { header, autoTypes, typeOverrides, skipCols, colFilters } = data;
  // Enabled count
  const $en = document.getElementById('pfEnabledCount');
  if ($en) $en.textContent = header.length - skipCols.size;
  // Filter count
  const filterableCols = header.map((_, i) => i).filter(i => isFilterableCol(header, i, autoTypes, typeOverrides, data.xyz, skipCols));
  const activeFilterCount = filterableCols.filter(i => colFilters[i] && (colFilters[i].skipZeros || colFilters[i].skipNeg)).length;
  const $fc = $preflightSidebar.querySelector('.pf-filter-count');
  if ($fc) $fc.textContent = `${activeFilterCount}/${filterableCols.length} filtered`;
}

function updateAllFilterButtonVisibility(data) {
  const { header, autoTypes, typeOverrides, skipCols } = data;
  const $pfColList = document.getElementById('pfColList');
  if (!$pfColList) return;
  $pfColList.querySelectorAll('.pf-col-item').forEach(item => {
    const col = parseInt(item.dataset.col);
    const filterable = isFilterableCol(header, col, autoTypes, typeOverrides, data.xyz, skipCols);
    item.querySelectorAll('.pf-filter-btn').forEach(btn => {
      btn.classList.toggle('pf-filter-hidden', !filterable);
    });
  });
}

function updateItemFilterability(item, col, data) {
  const { header, autoTypes, typeOverrides, skipCols } = data;
  const filterable = isFilterableCol(header, col, autoTypes, typeOverrides, data.xyz, skipCols);
  item.querySelectorAll('.pf-filter-btn').forEach(btn => {
    btn.classList.toggle('pf-filter-hidden', !filterable);
  });
}

// --- Preflight sidebar handler functions ---

function handlePfTypeToggle(btn, data) {
  const { autoTypes, typeOverrides, colFilters } = data;
  const col = parseInt(btn.dataset.col);
  const current = btn.dataset.type;
  const next = current === 'numeric' ? 'categorical' : 'numeric';
  if (next !== autoTypes[col]) {
    typeOverrides[col] = next;
  } else {
    delete typeOverrides[col];
  }
  if (next === 'categorical') {
    for (const axis of ['x', 'y', 'z']) {
      if (data.xyz[axis] === col) data.xyz[axis] = -1;
    }
    delete colFilters[col];
    // Clear active state on filter buttons for this column
    const item = btn.closest('.pf-col-item');
    item.querySelectorAll('.pf-filter-btn').forEach(fb => fb.classList.remove('active'));
  }
  // Update button text and data attribute
  btn.dataset.type = next;
  btn.textContent = next === 'numeric' ? 'NUM' : 'CAT';
  // Update filter button visibility for this item
  updateItemFilterability(btn.closest('.pf-col-item'), col, data);
  rebuildPfXyz(data);
  updatePfCounts(data);
  markAnalysisStale();
}

function handlePfCheckbox(cb, data) {
  const { header, skipCols, colFilters } = data;
  const col = parseInt(cb.dataset.col);
  if (cb.checked) {
    skipCols.delete(col);
  } else {
    skipCols.add(col);
    for (const axis of ['x', 'y', 'z']) {
      if (data.xyz[axis] === col) data.xyz[axis] = -1;
    }
    delete colFilters[col];
    // Clear active state on filter buttons
    const item = cb.closest('.pf-col-item');
    item.querySelectorAll('.pf-filter-btn').forEach(fb => fb.classList.remove('active'));
  }
  cb.closest('.pf-col-item').classList.toggle('skipped', !cb.checked);
  updateItemFilterability(cb.closest('.pf-col-item'), col, data);
  rebuildPfXyz(data);
  updatePfCounts(data);
  updatePreviewDimming(data);
  markAnalysisStale();
}

function handlePfFilterBtn(btn, data) {
  const { colFilters } = data;
  const col = parseInt(btn.dataset.col);
  const filter = btn.dataset.filter;
  if (!colFilters[col]) colFilters[col] = {};
  colFilters[col][filter] = !colFilters[col][filter];
  if (!colFilters[col][filter]) delete colFilters[col][filter];
  if (Object.keys(colFilters[col]).length === 0) delete colFilters[col];
  btn.classList.toggle('active');
  updatePfCounts(data);
  markAnalysisStale();
}

function handlePfSelectAll(data) {
  const { header, skipCols } = data;
  const $pfColList = document.getElementById('pfColList');
  if (!$pfColList) return;
  // Only affect visible (search-matched) items
  $pfColList.querySelectorAll('.pf-col-item').forEach(item => {
    if (item.style.display === 'none') return; // hidden by search
    const col = parseInt(item.dataset.col);
    skipCols.delete(col);
    item.classList.remove('skipped');
    const cb = item.querySelector('.pf-col-check');
    if (cb) cb.checked = true;
    updateItemFilterability(item, col, data);
  });
  rebuildPfXyz(data);
  updatePfCounts(data);
  updatePreviewDimming(data);
  markAnalysisStale();
}

function handlePfSelectNone(data) {
  const { header, skipCols, colFilters } = data;
  const $pfColList = document.getElementById('pfColList');
  if (!$pfColList) return;
  // Only affect visible (search-matched) items
  $pfColList.querySelectorAll('.pf-col-item').forEach(item => {
    if (item.style.display === 'none') return; // hidden by search
    const col = parseInt(item.dataset.col);
    skipCols.add(col);
    // Clear XYZ assignments for this column
    for (const axis of ['x', 'y', 'z']) {
      if (data.xyz[axis] === col) data.xyz[axis] = -1;
    }
    delete colFilters[col];
    item.classList.add('skipped');
    const cb = item.querySelector('.pf-col-check');
    if (cb) cb.checked = false;
    // Clear filter active states and hide buttons
    item.querySelectorAll('.pf-filter-btn').forEach(fb => {
      fb.classList.remove('active');
      fb.classList.add('pf-filter-hidden');
    });
  });
  rebuildPfXyz(data);
  updatePfCounts(data);
  updatePreviewDimming(data);
  markAnalysisStale();
}

function handlePfBulkFilterAll(data) {
  const { header, autoTypes, typeOverrides, skipCols, colFilters } = data;
  const filterableCols = header.map((_, i) => i).filter(i => isFilterableCol(header, i, autoTypes, typeOverrides, data.xyz, skipCols));
  for (const i of filterableCols) {
    colFilters[i] = { skipZeros: true, skipNeg: true };
  }
  // Set active class on all visible filter buttons for filterable cols
  const $pfColList = document.getElementById('pfColList');
  if ($pfColList) {
    $pfColList.querySelectorAll('.pf-filter-btn').forEach(btn => {
      const col = parseInt(btn.dataset.col);
      if (filterableCols.includes(col)) btn.classList.add('active');
    });
  }
  updatePfCounts(data);
  markAnalysisStale();
}

function handlePfBulkFilterClear(data) {
  const { colFilters } = data;
  for (const key of Object.keys(colFilters)) delete colFilters[key];
  // Remove active class from all filter buttons
  const $pfColList = document.getElementById('pfColList');
  if ($pfColList) {
    $pfColList.querySelectorAll('.pf-filter-btn').forEach(btn => btn.classList.remove('active'));
  }
  updatePfCounts(data);
  markAnalysisStale();
}

function updatePreviewDimming(data) {
  const table = $preflightPreview.querySelector('table');
  if (!table) return;
  for (let c = 0; c < data.header.length; c++) {
    const colIdx = c + 1;
    const isSkipped = data.skipCols.has(c);
    table.querySelectorAll(`th:nth-child(${colIdx + 1}), td:nth-child(${colIdx + 1})`).forEach(el => {
      el.classList.toggle('col-skipped', isSkipped);
    });
  }
}

function renderPreflightTable(data) {
  const { header, sampleRows, skipCols } = data;

  let thead = '<tr><th style="color:var(--fg-dim);opacity:0.5">#</th>';
  for (let i = 0; i < header.length; i++) {
    const dimClass = skipCols.has(i) ? ' class="col-skipped"' : '';
    thead += `<th${dimClass}>${esc(header[i])}</th>`;
  }
  thead += '</tr>';

  let tbody = '';
  for (let r = 0; r < sampleRows.length; r++) {
    tbody += `<tr><td>${r}</td>`;
    for (let c = 0; c < header.length; c++) {
      const val = (sampleRows[r] && sampleRows[r][c]) || '';
      const dimClass = skipCols.has(c) ? ' class="col-skipped"' : '';
      tbody += `<td${dimClass}>${esc(val)}</td>`;
    }
    tbody += '</tr>';
  }

  $preflightPreview.innerHTML = `<table><thead>${thead}</thead><tbody>${tbody}</tbody></table>`;
}

function addThousandsSep(s) {
  var sep = (typeof bmaSettings !== 'undefined' && bmaSettings && bmaSettings.thousandsSep) || 'space';
  if (sep === 'none') return s;
  var sepChar = sep === 'comma' ? ',' : '\u2009'; // thin space
  var parts = s.split('.');
  var intPart = parts[0];
  var neg = '';
  if (intPart.startsWith('-')) { neg = '-'; intPart = intPart.substring(1); }
  if (intPart.length <= 3) return s;
  var result = '';
  for (var i = intPart.length - 1, count = 0; i >= 0; i--, count++) {
    if (count > 0 && count % 3 === 0) result = sepChar + result;
    result = intPart[i] + result;
  }
  return neg + result + (parts.length > 1 ? '.' + parts[1] : '');
}

function formatNum(v, decimals) {
  if (v === null || v === undefined) return '\u2014';
  var d = decimals;
  if (d === undefined && typeof bmaSettings !== 'undefined' && bmaSettings && bmaSettings.sigFigs !== null) {
    d = bmaSettings.sigFigs;
  }
  // Sci notation check
  var sciMode = (typeof bmaSettings !== 'undefined' && bmaSettings && bmaSettings.sciNotation) || 'auto';
  var useSci = false;
  if (sciMode === 'auto') {
    useSci = Math.abs(v) >= 1e6 || (Math.abs(v) < 0.001 && v !== 0);
  } else if (sciMode !== 'never') {
    var threshold = parseFloat(sciMode);
    useSci = isFinite(threshold) && (Math.abs(v) >= threshold || (Math.abs(v) < 0.001 && v !== 0));
  }
  if (useSci) return v.toExponential(d != null ? d : 3);
  // Fixed-point formatting
  var fracDigits = d != null ? d : (Math.abs(v) >= 100 ? 2 : Math.abs(v) >= 1 ? 3 : 4);
  if (Number.isInteger(v)) return addThousandsSep(String(v));
  var s = v.toFixed(fracDigits);
  // Trim trailing zeros to min 2
  var fparts = s.split('.');
  if (fparts.length === 2) {
    var minFrac = d != null ? d : 2;
    while (fparts[1].length > minFrac && fparts[1].endsWith('0')) fparts[1] = fparts[1].slice(0, -1);
    s = fparts[0] + '.' + fparts[1];
  }
  return addThousandsSep(s);
}

function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
}

function delimName(d) {
  if (d === ',') return 'comma';
  if (d === '\t') return 'tab';
  if (d === ';') return 'semicolon';
  if (d === '|') return 'pipe';
  if (d === ' ') return 'space';
  return JSON.stringify(d);
}

// ─── Result Cache (IndexedDB) ──────────────────────────────────────────

function openCacheDB() {
  return new Promise(function(resolve, reject) {
    var req = indexedDB.open('bma-cache', 2);
    req.onupgradeneeded = function(e) {
      var db = req.result;
      if (!db.objectStoreNames.contains('results'))
        db.createObjectStore('results');
      if (!db.objectStoreNames.contains('recents'))
        db.createObjectStore('recents');
    };
    req.onsuccess = function() { resolve(req.result); };
    req.onerror = function() { reject(req.error); };
  });
}

// ─── Recent Files (IndexedDB) ───────────────────────────────────────────

var RECENTS_MAX = 20;

function recentKey(f) { return 'bma:' + f.name + ':' + f.size; }

function recentList() {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('recents', 'readonly');
      var store = tx.objectStore('recents');
      var req = store.getAll();
      var keyReq = store.getAllKeys();
      tx.oncomplete = function() {
        var items = req.result || [];
        var keys = keyReq.result || [];
        var result = items.map(function(item, i) { item._key = keys[i]; return item; });
        result.sort(function(a, b) { return (b.lastOpened || 0) - (a.lastOpened || 0); });
        resolve(result);
      };
      tx.onerror = function() { reject(tx.error); };
    });
  });
}

function recentPut(key, entry) {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('recents', 'readwrite');
      var store = tx.objectStore('recents');
      store.put(entry, key);
      tx.oncomplete = function() { resolve(); };
      tx.onerror = function() { reject(tx.error); };
    });
  }).then(function() {
    // Prune to max entries
    return recentList().then(function(items) {
      if (items.length <= RECENTS_MAX) return;
      return openCacheDB().then(function(db) {
        var tx = db.transaction('recents', 'readwrite');
        var store = tx.objectStore('recents');
        for (var i = RECENTS_MAX; i < items.length; i++) {
          store.delete(items[i]._key);
        }
        return new Promise(function(resolve) { tx.oncomplete = resolve; });
      });
    });
  });
}

function recentDelete(key) {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('recents', 'readwrite');
      tx.objectStore('recents').delete(key);
      tx.oncomplete = function() { resolve(); };
      tx.onerror = function() { reject(tx.error); };
    });
  });
}

function timeAgo(ts) {
  var diff = Date.now() - ts;
  var sec = Math.floor(diff / 1000);
  if (sec < 60) return 'just now';
  var min = Math.floor(sec / 60);
  if (min < 60) return min + (min === 1 ? ' min ago' : ' mins ago');
  var hrs = Math.floor(min / 60);
  if (hrs < 24) return hrs + (hrs === 1 ? ' hour ago' : ' hours ago');
  var days = Math.floor(hrs / 24);
  if (days < 14) return days + (days === 1 ? ' day ago' : ' days ago');
  var weeks = Math.floor(days / 7);
  if (weeks < 8) return weeks + (weeks === 1 ? ' week ago' : ' weeks ago');
  var months = Math.floor(days / 30);
  return months + (months === 1 ? ' month ago' : ' months ago');
}

function renderRecentFiles() {
  recentList().then(function(items) {
    if (items.length === 0) {
      $recentFiles.innerHTML = '';
      return;
    }
    var html = '<div class="recent-files-title">Recent Files</div>';
    for (var i = 0; i < items.length; i++) {
      var it = items[i];
      var hasProj = false;
      try { hasProj = localStorage.getItem(it._key) !== null; } catch(e) {}
      html += '<div class="recent-item" data-key="' + esc(it._key) + '">';
      html += '<span class="recent-item-name">' + esc(it.name) + '</span>';
      html += '<span class="recent-item-size">' + formatBytes(it.size) + '</span>';
      if (hasProj) html += '<span class="recent-item-project">project</span>';
      html += '<span class="recent-item-time">' + timeAgo(it.lastOpened) + '</span>';
      html += '<button class="recent-item-remove" data-key="' + esc(it._key) + '" title="Remove">\u2715</button>';
      html += '</div>';
    }
    $recentFiles.innerHTML = html;

    // Wire click handlers
    $recentFiles.querySelectorAll('.recent-item').forEach(function(el) {
      el.addEventListener('click', function(e) {
        if (e.target.closest('.recent-item-remove')) return;
        var key = el.dataset.key;
        reopenRecent(key);
      });
    });
    $recentFiles.querySelectorAll('.recent-item-remove').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        var key = btn.dataset.key;
        recentDelete(key).then(renderRecentFiles);
      });
    });
  }).catch(function() {
    $recentFiles.innerHTML = '';
  });
}

function reopenRecent(key) {
  openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('recents', 'readonly');
      var req = tx.objectStore('recents').get(key);
      req.onsuccess = function() { resolve(req.result || null); };
      req.onerror = function() { reject(req.error); };
    });
  }).then(function(entry) {
    if (!entry) return;
    if (entry.handle && typeof entry.handle.queryPermission === 'function') {
      // FSAA path — check permission first, only prompt if needed
      entry.handle.queryPermission({ mode: 'read' }).then(function(perm) {
        if (perm === 'granted') {
          return entry.handle.getFile().then(function(file) {
            handleFile(file, entry.handle);
          });
        }
        // Permission not yet granted — request it for just this handle
        return entry.handle.requestPermission({ mode: 'read' }).then(function(perm2) {
          if (perm2 === 'granted') {
            return entry.handle.getFile().then(function(file) {
              handleFile(file, entry.handle);
            });
          }
          promptReselect(entry.name);
        });
      }).catch(function() {
        promptReselect(entry.name);
      });
    } else {
      // No handle — prompt user to re-select
      promptReselect(entry.name);
    }
  });
}

function promptReselect(name) {
  if (HAS_FSAA) {
    // Use file picker
    window.showOpenFilePicker({
      types: [
        { description: 'CSV files', accept: { 'text/*': ['.csv', '.txt', '.dat'] } },
        { description: 'ZIP files', accept: { 'application/zip': ['.zip'] } }
      ],
      multiple: false
    }).then(function(handles) {
      var handle = handles[0];
      return handle.getFile().then(function(file) {
        handleFile(file, handle);
      });
    }).catch(function() { /* user cancelled */ });
  } else {
    // Trigger classic file input
    $fileInput.click();
  }
}

function saveToRecents(file, handle) {
  var key = recentKey(file);
  var entry = {
    name: file.name,
    size: file.size,
    handle: handle || null,
    lastOpened: Date.now()
  };
  recentPut(key, entry).catch(function() { /* silent */ });
}

function cacheGet(key) {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('results', 'readonly');
      var req = tx.objectStore('results').get(key);
      req.onsuccess = function() { resolve(req.result || null); };
      req.onerror = function() { reject(req.error); };
    });
  });
}

function cachePut(key, value) {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('results', 'readwrite');
      tx.objectStore('results').put(value, key);
      tx.oncomplete = function() { resolve(); };
      tx.onerror = function() { reject(tx.error); };
    });
  });
}

function cacheDelete(key) {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('results', 'readwrite');
      tx.objectStore('results').delete(key);
      tx.oncomplete = function() { resolve(); };
      tx.onerror = function() { reject(tx.error); };
    });
  });
}

function analysisFingerprint() {
  return JSON.stringify({
    filter: currentFilter,
    typeOverrides: currentTypeOverrides || null,
    skipCols: currentSkipCols || null,
    colFilters: currentColFilters || null,
    zipEntry: currentZipEntry || null,
    calcolCode: currentCalcolCode || '',
    calcolMeta: currentCalcolMeta || [],
    groupBy: currentGroupBy,
    groupStatsCols: currentGroupBy !== null && statsCatSelectedVars.size > 0 ? Array.from(statsCatSelectedVars).sort() : null
  });
}

// ─── Project Save/Load ─────────────────────────────────────────────────

function estimateResultBytes(data) {
  var bytes = 0;
  // Stats: per-column fixed fields + centroids
  if (data.stats) {
    var keys = Object.keys(data.stats);
    for (var i = 0; i < keys.length; i++) {
      var s = data.stats[keys[i]];
      bytes += 10 * 8; // ~10 numeric fields (count, min, max, mean, std, skew, kurt, nulls, zeros + quantiles obj)
      if (s.centroids) bytes += s.centroids.length * 16; // 2 floats × 8 bytes
    }
  }
  // Categories: string keys + counts
  if (data.categories) {
    var catKeys = Object.keys(data.categories);
    for (var i = 0; i < catKeys.length; i++) {
      var cc = data.categories[catKeys[i]].counts;
      if (cc) {
        var valKeys = Object.keys(cc);
        for (var j = 0; j < valKeys.length; j++) {
          bytes += valKeys[j].length * 2 + 8; // string (UTF-16) + count number
        }
      }
    }
  }
  // Geometry
  if (data.geometry) {
    var g = data.geometry;
    if (g.bounds) bytes += 6 * 8;
    if (g.spacing) bytes += 3 * 8;
    if (g.transitions) {
      if (g.transitions.x) bytes += g.transitions.x.length * 8;
      if (g.transitions.y) bytes += g.transitions.y.length * 8;
      if (g.transitions.z) bytes += g.transitions.z.length * 8;
    }
    if (g.subBlockSizes) bytes += g.subBlockSizes.length * 24;
  }
  // Header + colTypes strings
  if (data.header) {
    for (var i = 0; i < data.header.length; i++) bytes += data.header[i].length * 2;
  }
  // Group stats (same structure as stats, per group)
  if (data.groupStats) {
    var gKeys = Object.keys(data.groupStats);
    for (var i = 0; i < gKeys.length; i++) {
      var gs = data.groupStats[gKeys[i]];
      var gsKeys = Object.keys(gs);
      for (var j = 0; j < gsKeys.length; j++) {
        var s = gs[gsKeys[j]];
        bytes += 10 * 8;
        if (s.centroids) bytes += s.centroids.length * 16;
      }
    }
  }
  return bytes;
}

function formatBytes(b) {
  if (b < 1024) return b + ' B';
  if (b < 1024 * 1024) return (b / 1024).toFixed(1) + ' KB';
  return (b / (1024 * 1024)).toFixed(1) + ' MB';
}

function projectKey(f) { return 'bma:' + f.name + ':' + f.size; }

function serializeProject() {
  return {
    _bma: 1,
    _ts: Date.now(),
    activeTab: document.querySelector('.results-tab.active')?.dataset.tab || null,
    file: { name: currentFile.name, size: currentFile.size },
    preflight: {
      typeOverrides: preflightData?.typeOverrides || {},
      skipCols: preflightData ? Array.from(preflightData.skipCols) : [],
      colFilters: preflightData?.colFilters || {},
      xyz: preflightData?.xyz || { x: -1, y: -1, z: -1 },
      dxyz: preflightData?.dxyz || { dx: -1, dy: -1, dz: -1 },
      selectedZipEntry: preflightData?.selectedZipEntry || null
    },
    calcolCode: currentCalcolCode,
    calcolMeta: currentCalcolMeta,
    filter: currentFilter,
    filterText: $filterExpr.value,
    statsCat: {
      groupBy: currentGroupBy,
      selectedVars: Array.from(statsCatSelectedVars),
      sortMode: statsCatGroupSortMode,
      cdfScale: statsCatCdfScale,
      cdfManual: statsCatCdfManual,
      cdfMin: statsCatCdfMin,
      cdfMax: statsCatCdfMax,
      crossMode: statsCatCrossMode,
      displayVar: currentStatsCatVar,
      checkedGroups: currentStatsCatChecked ? Array.from(currentStatsCatChecked) : null,
      showSelectedOnly: statsCatShowSelectedOnly
    },
    statsTab: {
      selectedVars: statsSelectedVars ? Array.from(statsSelectedVars) : null,
      visibleMetrics: statsVisibleMetrics ? Array.from(statsVisibleMetrics) : null,
      percentiles: statsPercentiles,
      cdfSelected: Array.from(statsCdfSelected),
      cdfScale: statsCdfScale
    },
    categories: {
      focusedCol: catFocusedCol !== null && currentHeader[catFocusedCol] ? currentHeader[catFocusedCol] : null,
      sortModes: catSortModes,
      customOrders: catCustomOrders,
      colorOverrides: catColorOverrides
    },
    exportCols: exportColumns.map(c => ({
      name: c.name, outputName: c.outputName, selected: c.selected
    })),
    exportSettings: {
      delimiter: exportDelimiter,
      includeHeader: exportIncludeHeader,
      commentHeader: exportCommentHeader,
      commentText: exportCommentText,
      quoteChar: exportQuoteChar,
      lineEnding: exportLineEnding,
      nullValue: exportNullValue,
      precision: exportPrecision,
      decimalSep: exportDecimalSep
    },
    gt: (function() {
      var varList = document.getElementById('gtVarList');
      if (!varList) return null;
      var checked = varList.querySelectorAll('input[type="checkbox"]:checked');
      var gradeCols = [];
      for (var ci = 0; ci < checked.length; ci++) gradeCols.push(checked[ci].parentElement.querySelector('span').textContent);
      var mode = 'range';
      var modeRadio = document.querySelector('input[name="gtCutoffMode"]:checked');
      if (modeRadio) mode = modeRadio.value;
      var gb = document.getElementById('gtGroupBy');
      return {
        gradeCols: gradeCols,
        groupByCol: gb && gb.value !== '-1' && gb.options[gb.selectedIndex] ? gb.options[gb.selectedIndex].textContent : null,
        densityCol: (function() { var d = document.getElementById('gtDensityCol'); return d && d.value !== '-1' && d.options[d.selectedIndex] ? d.options[d.selectedIndex].textContent : null; })(),
        weightCol: (function() { var w = document.getElementById('gtWeightCol'); return w && w.value !== '-1' && w.options[w.selectedIndex] ? w.options[w.selectedIndex].textContent : null; })(),
        localFilter: (document.getElementById('gtLocalFilter') || {}).value || '',
        cutoffMode: mode,
        cutoffMin: parseFloat((document.getElementById('gtCutoffMin') || {}).value) || 0,
        cutoffMax: parseFloat((document.getElementById('gtCutoffMax') || {}).value) || 1,
        cutoffStep: parseFloat((document.getElementById('gtCutoffStep') || {}).value) || 0.05,
        cutoffCustom: (document.getElementById('gtCutoffCustomText') || {}).value || '',
        volumeOverride: parseFloat((document.getElementById('gtVolOverride') || {}).value) || null,
        tonnageUnit: parseInt((document.getElementById('gtTonnageUnit') || {}).value) || 0,
        customTonnageSym: (document.getElementById('gtCustomTonnageSym') || {}).value || '',
        customTonnageDiv: parseFloat((document.getElementById('gtCustomTonnageDiv') || {}).value) || null,
        gradeUnits: (function() {
          var gu = {};
          document.querySelectorAll('.gt-var-unit').forEach(function(sel) {
            var colIdx = parseInt(sel.dataset.col);
            var colName = currentHeader[colIdx];
            if (colName && parseInt(sel.value) !== 0) gu[colName] = parseInt(sel.value);
          });
          return Object.keys(gu).length > 0 ? gu : null;
        })(),
        selectedGroups: (function() {
          var list = document.getElementById('gtGrpList');
          if (!list) return null;
          var checked = [];
          var hasTotal = false;
          list.querySelectorAll('input:checked').forEach(function(cb) {
            if (cb.value === '__total__') hasTotal = true;
            else checked.push(cb.value);
          });
          return { values: checked, showTotal: hasTotal };
        })()
      };
    })()
  };
}

function autoSaveProject() {
  clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(() => {
    if (!currentFile || !preflightData) return;
    try {
      localStorage.setItem(projectKey(currentFile), JSON.stringify(serializeProject()));
    } catch (e) { /* quota — silent fail */ }
  }, 2000);
}

async function applyProject(project) {
  if (!project || !project._bma) return;

  // Restore preflight config
  if (preflightData) {
    const pf = project.preflight || {};

    // If saved project used a different zip entry, re-read its preview first
    if (pf.selectedZipEntry && preflightData.zipEntries &&
        pf.selectedZipEntry !== preflightData.selectedZipEntry) {
      const entry = preflightData.zipEntries.find(z => z.name === pf.selectedZipEntry);
      if (entry) {
        try {
          const lines = await readPreviewFromZipEntry(currentFile, entry, 100);
          const delimiter = detectDelimiterMain(lines.slice(0, 20));
          preflightData.header = lines[0].split(delimiter).map(h => h.trim().replace(/^["']|["']$/g, ''));
          preflightData.sampleRows = lines.slice(1).filter(l => l.trim())
            .map(l => l.split(delimiter).map(f => f.trim().replace(/^["']|["']$/g, '')));
          preflightData.delimiter = delimiter;
          preflightData.autoTypes = autoDetectTypes(preflightData.header, preflightData.sampleRows);
          preflightData.selectedZipEntry = pf.selectedZipEntry;
          // Update zip dropdown to reflect restored selection
          const zipSelect = document.getElementById('zipSelect');
          if (zipSelect) zipSelect.value = pf.selectedZipEntry;
        } catch (e) { /* failed to read entry — continue with current */ }
      }
    }

    preflightData.typeOverrides = pf.typeOverrides || {};
    preflightData.skipCols = new Set(pf.skipCols || []);
    preflightData.colFilters = pf.colFilters || {};
    if (pf.xyz) preflightData.xyz = pf.xyz;
    if (pf.dxyz) preflightData.dxyz = pf.dxyz;
    renderPreflightSidebar(preflightData);
    renderPreflightTable(preflightData);
  }

  // Restore calcols — support both new (calcolCode) and old (calcols array) formats
  if (project.calcolCode !== undefined) {
    currentCalcolCode = project.calcolCode || '';
    currentCalcolMeta = project.calcolMeta || [];
  } else if (project.calcols && project.calcols.length > 0) {
    // Backward compat: convert old [{name, expr, type}] to code block
    const rv = currentRowVar || 'r';
    currentCalcolCode = project.calcols.map(c => rv + '.' + c.name + ' = ' + c.expr + ';').join('\n');
    currentCalcolMeta = project.calcols.map(c => ({ name: c.name, type: c.type || 'numeric' }));
  } else {
    currentCalcolCode = '';
    currentCalcolMeta = [];
  }
  setCalcolCode(currentCalcolCode);
  simulateCalcol();

  // Restore categories tab state
  catSortModes = project.categories?.sortModes || {};
  catCustomOrders = project.categories?.customOrders || {};
  catColorOverrides = project.categories?.colorOverrides || {};

  // Restore filter
  currentFilter = project.filter || null;
  $filterExpr.value = project.filterText || '';

  // Restore StatsCat groupBy + selectedVars NOW (before executeAnalysis)
  // so the worker includes grouped stats in its analysis
  const sc = project.statsCat || {};
  if (sc.groupBy != null) currentGroupBy = sc.groupBy;
  if (sc.selectedVars) statsCatSelectedVars = new Set(sc.selectedVars);

  // Stash remaining post-analysis config for when displayResults runs
  pendingProjectRestore = project;
}

function applyExportRestore(savedCols) {
  const reordered = [];
  const used = new Set();
  for (const sc of savedCols) {
    const idx = exportColumns.findIndex(c => c.name === sc.name);
    if (idx >= 0) {
      exportColumns[idx].outputName = sc.outputName || exportColumns[idx].name;
      exportColumns[idx].selected = sc.selected !== false;
      reordered.push(exportColumns[idx]);
      used.add(idx);
    }
  }
  for (let i = 0; i < exportColumns.length; i++) {
    if (!used.has(i)) reordered.push(exportColumns[i]);
  }
  exportColumns = reordered;
  renderExportColumns();
}

function saveProjectFile() {
  if (!currentFile || !preflightData) return;
  const json = JSON.stringify(serializeProject(), null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = currentFile.name.replace(/\.[^.]+$/, '') + '.bma.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

function clearProject() {
  if (!currentFile) return;
  try { localStorage.removeItem(projectKey(currentFile)); } catch (e) {}
  cacheDelete(projectKey(currentFile)).catch(function() {});

  currentCalcolCode = '';
  currentCalcolMeta = [];
  currentFilter = null;
  $filterExpr.value = '';
  currentGroupBy = null;
  currentStatsCatVar = null;
  currentStatsCatChecked = null;
  statsCatGroupSortMode = null;
  statsCatSelectedVars = new Set();
  statsCatCdfScale = 'linear';
  statsCatCdfManual = false;
  statsCatCdfMin = null;
  statsCatCdfMax = null;
  statsCatCrossMode = 'count';
  statsCatShowSelectedOnly = false;
  catFocusedCol = null;
  catSortModes = {};
  catCustomOrders = {};
  catColorOverrides = {};
  catChartShowAll = false;
  statsSelectedVars = null;
  statsVisibleMetrics = null;
  statsPercentiles = [25, 50, 75];
  statsCdfSelected = new Set();
  statsCdfScale = 'linear';
  exportColumns = [];
  pendingProjectRestore = null;
  resetExportSettings();

  runPreflight(currentFile).then(data => {
    renderPreflight(data);
    setCalcolCode('');
    simulateCalcol();
    markAnalysisStale();
    switchTab('preflight');
  });
}

// Toolbar overflow menu
$toolbarOverflow.addEventListener('click', (e) => {
  e.stopPropagation();
  $toolbarMenu.classList.toggle('open');
});
document.addEventListener('click', () => $toolbarMenu.classList.remove('open'));

// Toolbar menu items
$toolbarMenu.addEventListener('click', (e) => {
  const item = e.target.closest('.toolbar-menu-item');
  if (!item) return;
  $toolbarMenu.classList.remove('open');
  const action = item.dataset.action;
  if (action === 'save') saveProjectFile();
  else if (action === 'load') $projectFileInput.click();
  else if (action === 'clear') clearProject();
  else if (action === 'settings') openSettings();
});

// Toolbar buttons
$projectSave.addEventListener('click', saveProjectFile);
$projectLoad.addEventListener('click', () => $projectFileInput.click());
$projectClear.addEventListener('click', clearProject);

// Load project file
$projectFileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const project = JSON.parse(reader.result);
      applyProject(project);
    } catch (err) {
      $errorMsg.textContent = 'Invalid project file: ' + err.message;
      $errorMsg.classList.add('active');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

function handleFile(file, handle) {
  if (!file) return;
  currentFile = file;
  saveToRecents(file, handle);
  currentFilter = null;
  currentGroupBy = null;
  currentStatsCatVar = null;
  currentStatsCatChecked = null;
  lastStatsCatData = null;
  statsCatGroupSortMode = null;
  statsCatSelectedVars = new Set();
  statsCatShowSelectedOnly = false;
  statsCatCdfScale = 'linear';
  statsCatCdfManual = false;
  statsCatCdfMin = null;
  statsCatCdfMax = null;
  statsCatCrossMode = 'count';
  catFocusedCol = null;
  catSortModes = {};
  catCustomOrders = {};
  catColorOverrides = {};
  catChartShowAll = false;
  statsSelectedVars = null;
  statsVisibleMetrics = null;
  statsPercentiles = [25, 50, 75];
  statsCdfSelected = new Set();
  statsCdfScale = 'linear';
  exportColumns = [];
  pendingProjectRestore = null;
  resetExportSettings();
  currentTypeOverrides = null;
  currentZipEntry = null;
  currentSkipCols = null;
  currentColFilters = null;
  lastCompleteData = null;
  if (worker) { worker.terminate(); worker = null; }
  if (exportWorker) { exportWorker.terminate(); exportWorker = null; }
  if (swathWorker) { swathWorker.terminate(); swathWorker = null; }
  if (sectionWorker) { sectionWorker.terminate(); sectionWorker = null; }
  var staleOverlay = document.querySelector('.reanalysis-overlay');
  if (staleOverlay) staleOverlay.remove();
  lastSwathData = null;
  sectionBlocks = null;
  sectionTransform = null;
  sectionDefaultBlockSize = null;
  currentDXYZ = { dx: -1, dy: -1, dz: -1 };
  hasResults = false;
  $filterExpr.value = '';
  $filterSection.classList.remove('active');
  $appFooter.classList.remove('active');
  $filterError.classList.remove('active');
  $errorMsg.classList.remove('active');

  // Collapse dropzone
  $dropzone.classList.add('collapsed');
  $dropzone.querySelector('.label').innerHTML = 'Load different file:';
  let loadedSpan = $dropzone.querySelector('.loaded-name');
  if (!loadedSpan) {
    loadedSpan = document.createElement('span');
    loadedSpan.className = 'loaded-name';
    $dropzone.insertBefore(loadedSpan, $dropzone.querySelector('input'));
  }
  loadedSpan.textContent = file.name;

  // Show results container with preflight tab
  $results.classList.add('active');
  document.querySelector('.app').classList.add('has-results');
  $resultsFilename.textContent = file.name;
  $resultsRowInfo.textContent = '';
  $resultsTimeInfo.textContent = '';
  $resultsMemInfo.textContent = '';
  switchTab('preflight');

  // Show action bar with execute button and filter
  $appFooter.classList.add('active');
  $filterSection.classList.add('active');
  markAnalysisStale();

  // Set placeholder content for tabs before first analysis
  const placeholder = '<div style="color:var(--fg-dim);font-size:0.78rem;padding:2rem;text-align:center;opacity:0.5;">Click Analyze to run analysis.</div>';
  $geoContent.innerHTML = placeholder;
  $geoBadge.textContent = '';
  $fileInfo.innerHTML = '';
  $statsContent.innerHTML = placeholder;
  $statsBadge.textContent = '';
  document.getElementById('statsVarList').innerHTML = '';
  document.getElementById('statsVarSearch').value = '';
  document.getElementById('statsMetricToggles').innerHTML = '';
  document.getElementById('statsCdfChart').innerHTML = '<div class="stats-cdf-hint">Click column names to add CDF curves</div>';
  $statsCatContent.innerHTML = placeholder;
  $statsCatBadge.textContent = '';
  $statsCatVarList.innerHTML = '';
  $statsCatGroupList.innerHTML = '';
  $statsCatVarSearch.value = '';
  $statsCatGroupSearch.value = '';
  $catColList.innerHTML = '';
  $catToolbar.innerHTML = '';
  $catChart.innerHTML = '';
  $catValueTable.innerHTML = '';
  $catBadge.textContent = '';
  $exportColList.innerHTML = '';
  $exportBadge.textContent = '0';
  $exportInfo.textContent = '';
  $exportProgress.classList.remove('active');
  setCalcolCode('');
  simulateCalcol();

  // Run preflight
  runPreflight(file).then(async data => {
    renderPreflight(data);
    // Auto-restore saved project config
    const saved = localStorage.getItem(projectKey(file));
    if (saved) {
      try {
        const project = JSON.parse(saved);
        await applyProject(project);
        executeAnalysis();
      } catch (e) { /* corrupt — ignore */ }
    }
  }).catch(err => {
    $errorMsg.textContent = err.message;
    $errorMsg.classList.add('active');
  });
}

let analysisStale = true;

function markAnalysisStale() {
  analysisStale = true;
  const btn = document.getElementById('executeBtn');
  if (btn) btn.classList.remove('clean');
}

function executeAnalysis() {
  if (!preflightData || !currentFile) return;
  const typeOv = Object.keys(preflightData.typeOverrides).length > 0 ? preflightData.typeOverrides : null;
  const zipEntry = preflightData.selectedZipEntry || null;
  const xyz = preflightData.xyz;
  const xyzOv = (xyz.x >= 0 && xyz.y >= 0 && xyz.z >= 0) ? xyz : null;
  const skip = preflightData.skipCols.size > 0 ? Array.from(preflightData.skipCols) : null;
  const colFilters = Object.keys(preflightData.colFilters).length > 0 ? preflightData.colFilters : null;
  const dxyz = preflightData.dxyz || { dx: -1, dy: -1, dz: -1 };
  const dxyzOv = (dxyz.dx >= 0 || dxyz.dy >= 0 || dxyz.dz >= 0) ? dxyz : null;
  currentDXYZ = { ...dxyz };
  startAnalysis(xyzOv, currentFilter, typeOv, zipEntry, skip, colFilters, dxyzOv);
}

let hasResults = false; // Track whether analysis has been run

// Back button in toolbar — go back to dropzone
$backToPreflight.addEventListener('click', () => {
  $results.classList.remove('active');
  document.querySelector('.app').classList.remove('has-results');
  $appFooter.classList.remove('active');
  $filterSection.classList.remove('active');
  $dropzone.classList.remove('collapsed');
  const loadedSpan = $dropzone.querySelector('.loaded-name');
  if (loadedSpan) loadedSpan.remove();
  $dropzone.querySelector('.label').innerHTML = 'Drop a CSV file here, or <strong>click to browse</strong>';
  renderRecentFiles();
  currentFile = null;
  preflightData = null;
  hasResults = false;
  currentCalcolCode = '';
  currentCalcolMeta = [];
  currentGroupBy = null;
  currentStatsCatVar = null;
  currentStatsCatChecked = null;
  lastStatsCatData = null;
  statsCatGroupSortMode = null;
  statsCatSelectedVars = new Set();
  statsCatShowSelectedOnly = false;
  catFocusedCol = null;
  catSortModes = {};
  catCustomOrders = {};
  catColorOverrides = {};
  catChartShowAll = false;
  statsSelectedVars = null;
  statsVisibleMetrics = null;
  statsPercentiles = [25, 50, 75];
  statsCdfSelected = new Set();
  statsCdfScale = 'linear';
  exportColumns = [];
  pendingProjectRestore = null;
  if (exportWorker) { exportWorker.terminate(); exportWorker = null; }
  if (swathWorker) { swathWorker.terminate(); swathWorker = null; }
  if (sectionWorker) { sectionWorker.terminate(); sectionWorker = null; }
  lastSwathData = null;
  sectionBlocks = null;
  sectionTransform = null;
  sectionDefaultBlockSize = null;
  currentDXYZ = { dx: -1, dy: -1, dz: -1 };
});

// Allow dropping new files onto results area
$results.addEventListener('dragover', (e) => { e.preventDefault(); });
$results.addEventListener('drop', async (e) => {
  e.preventDefault();
  var handle = null;
  if (HAS_FSAA && e.dataTransfer.items && e.dataTransfer.items[0] && e.dataTransfer.items[0].getAsFileSystemHandle) {
    try { handle = await e.dataTransfer.items[0].getAsFileSystemHandle(); } catch (ex) {}
  }
  var file = handle ? await handle.getFile() : (e.dataTransfer.files[0] || null);
  if (file) handleFile(file, handle);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Enter triggers Analyze (when not in text fields)
  if (e.key === 'Enter' && !e.shiftKey && document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'INPUT') {
    if (preflightData && currentFile) {
      e.preventDefault();
      executeAnalysis();
    }
  }
});

// Wire unified execute button
document.getElementById('executeBtn').addEventListener('click', executeAnalysis);

let currentTypeOverrides = null;
let currentZipEntry = null;
let currentSkipCols = null;
let currentColFilters = null;

function startAnalysis(xyzOverride, filter, typeOverrides, zipEntry, skipCols, colFilters, dxyzOverride) {
  if (!currentFile) return;

  // Store for re-analysis (filters, xyz changes)
  if (typeOverrides !== undefined) currentTypeOverrides = typeOverrides;
  if (zipEntry !== undefined) currentZipEntry = zipEntry;
  if (skipCols !== undefined) currentSkipCols = skipCols;
  if (colFilters !== undefined) currentColFilters = colFilters;

  var cacheKey = projectKey(currentFile);
  var fingerprint = analysisFingerprint();

  // Check IndexedDB cache before spawning worker
  cacheGet(cacheKey).then(function(cached) {
    if (cached && cached.fingerprint === fingerprint && cached.lastModified === currentFile.lastModified) {
      // Cache hit — restore results without re-analysis
      var msg = cached.data;
      currentHeader = msg.header;
      currentColTypes = msg.colTypes;
      currentRowVar = msg.rowVarName || 'r';
      if (msg.origColCount) currentOrigColCount = msg.origColCount;
      if (!xyzOverride) {
        currentXYZ = { ...msg.xyzGuess };
        detectedXYZ = { ...msg.xyzGuess };
      } else {
        currentXYZ = { ...xyzOverride };
        detectedXYZ = { ...xyzOverride };
      }
      lastCompleteData = msg;
      msg._cached = true;
      displayResults(msg);
      return;
    }
    runWorkerAnalysis(xyzOverride, filter, dxyzOverride, cacheKey, fingerprint);
  }).catch(function() {
    runWorkerAnalysis(xyzOverride, filter, dxyzOverride, cacheKey, fingerprint);
  });
}

function runWorkerAnalysis(xyzOverride, filter, dxyzOverride, cacheKey, fingerprint) {
  if (worker) worker.terminate();
  worker = new Worker(workerUrl);

  // Always use overlay on the results panels
  const panelsEl = $results.querySelector('.results-panels');
  // Remove any stale overlay
  const old = panelsEl.querySelector('.reanalysis-overlay');
  if (old) old.remove();
  const $overlay = document.createElement('div');
  $overlay.className = 'reanalysis-overlay';
  $overlay.innerHTML = `
    <div class="re-label">Analyzing…</div>
    <div class="re-progress"><div class="re-bar"></div></div>
    <button class="re-cancel">Cancel</button>
  `;
  panelsEl.appendChild($overlay);
  const $reBar = $overlay.querySelector('.re-bar');
  const $reLabel = $overlay.querySelector('.re-label');
  $overlay.querySelector('.re-cancel').addEventListener('click', () => {
    if (worker) worker.terminate();
    $overlay.remove();
    if (lastCompleteData) displayResults(lastCompleteData);
  });

  worker.onerror = (e) => {
    $reLabel.textContent = 'Worker error: ' + (e.message || 'unknown error');
    $reLabel.style.color = 'var(--red)';
    $reBar.parentElement.style.display = 'none';
    var btn = $overlay.querySelector('.re-cancel');
    btn.textContent = 'Dismiss';
    var newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    newBtn.addEventListener('click', () => {
      $overlay.remove();
      if (lastCompleteData) displayResults(lastCompleteData);
    });
  };

  worker.onmessage = (e) => {
    const msg = e.data;
    if (msg.type === 'header') {
      currentHeader = msg.header;
      currentColTypes = msg.colTypes;
      currentRowVar = msg.rowVarName || 'r';
      if (msg.origColCount) currentOrigColCount = msg.origColCount;
      if (!xyzOverride) {
        currentXYZ = { ...msg.xyzGuess };
        detectedXYZ = { ...msg.xyzGuess };
      } else {
        currentXYZ = { ...xyzOverride };
        detectedXYZ = { ...xyzOverride };
      }
    } else if (msg.type === 'progress') {
      const pct = Math.min(99, msg.percent);
      $reBar.style.width = pct.toFixed(1) + '%';
      $reLabel.textContent = 'Analyzing… ' + pct.toFixed(0) + '%';
    } else if (msg.type === 'complete') {
      if (msg.origColCount) currentOrigColCount = msg.origColCount;
      $overlay.remove();
      lastCompleteData = msg;
      displayResults(msg);
      // Store in IndexedDB cache (async, fire-and-forget)
      cachePut(cacheKey, {
        fingerprint: fingerprint,
        lastModified: currentFile.lastModified,
        data: msg
      }).catch(function() { /* ignore cache write errors */ });
    } else if (msg.type === 'error') {
      if (msg.message.startsWith('Filter expression')) {
        $overlay.remove();
        $filterError.textContent = msg.message;
        $filterError.classList.add('active');
        if (lastCompleteData) displayResults(lastCompleteData);
      } else {
        $reLabel.textContent = msg.message;
        $reLabel.style.color = 'var(--red)';
        $reBar.parentElement.style.display = 'none';
        var btn = $overlay.querySelector('.re-cancel');
        btn.textContent = 'Dismiss';
        var newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
        newBtn.addEventListener('click', () => {
          $overlay.remove();
          if (lastCompleteData) displayResults(lastCompleteData);
        });
      }
    }
  };

  const filterPayload = filter ? { expression: filter.expression } : null;
  worker.postMessage({
    file: currentFile,
    xyzOverride: xyzOverride || null,
    dxyzOverride: dxyzOverride || null,
    filter: filterPayload,
    typeOverrides: currentTypeOverrides || null,
    zipEntry: currentZipEntry || null,
    skipCols: currentSkipCols || null,
    colFilters: currentColFilters || null,
    calcolCode: currentCalcolCode || null,
    calcolMeta: currentCalcolMeta.length > 0 ? currentCalcolMeta : null,
    groupBy: currentGroupBy,
    groupStatsCols: currentGroupBy !== null && statsCatSelectedVars.size > 0 ? Array.from(statsCatSelectedVars) : null
  });
}

function displayResults(data) {
  const isFirstAnalysis = !hasResults;
  hasResults = true;
  const { stats, geometry, coordOrder, maxDecimals, categories, rowCount, totalRowCount, commentCount, elapsed, header, colTypes, xyzGuess, rowVarName, zipName } = data;
  currentRowVar = rowVarName || 'r';
  $results.classList.add('active');
  document.querySelector('.app').classList.add('has-results');

  // Toolbar info
  const dispName = zipName ? `${currentFile.name} / ${zipName}` : currentFile.name;
  $resultsFilename.textContent = dispName;

  const isFiltered = currentFilter !== null;
  const rowsDisplay = isFiltered
    ? `${rowCount.toLocaleString()} / ${totalRowCount.toLocaleString()}`
    : totalRowCount.toLocaleString();
  $resultsRowInfo.textContent = rowsDisplay + ' rows · ' + header.length + ' cols';
  $resultsTimeInfo.textContent = data._cached ? 'cached' : (elapsed / 1000).toFixed(1) + 's';
  $resultsMemInfo.textContent = '~' + formatBytes(estimateResultBytes(data));

  // Apply default percentile preset from settings (only on first analysis, not project restore)
  if (isFirstAnalysis && !pendingProjectRestore && typeof bmaSettings !== 'undefined' && bmaSettings) {
    var preset = bmaSettings.defaultPercentilePreset;
    if (preset === 'custom' && bmaSettings.customPercentiles) {
      statsPercentiles = bmaSettings.customPercentiles.slice();
    } else if (STATS_PRESETS[preset]) {
      statsPercentiles = STATS_PRESETS[preset].slice();
    }
  }

  // Jump to summary only if still on preflight tab
  var activeTab = $resultsTabs.querySelector('.results-tab.active');
  if (isFirstAnalysis || (activeTab && activeTab.dataset.tab === 'preflight')) switchTab('summary');

  // Mark analysis as clean
  analysisStale = false;
  const execBtn = document.getElementById('executeBtn');
  if (execBtn) execBtn.classList.add('clean');

  // Show filter section (action bar already visible from handleFile)
  $filterSection.classList.add('active');
  const infoItems = [
    fi('File', currentFile.name),
  ];
  if (zipName) infoItems.push(fi('Inner', zipName));
  infoItems.push(
    fi('Size', formatSize(currentFile.size)),
    fi('Rows', rowsDisplay),
    fi('Columns', header.length),
    fi('Delimiter', delimName(data.delimiter || ',')),
    fi('Time', (elapsed / 1000).toFixed(2) + 's'),
  );
  if (commentCount > 0) infoItems.splice(zipName ? 4 : 3, 0, fi('Comments', commentCount.toLocaleString()));
  $fileInfo.innerHTML = infoItems.join('');

  // XYZ Config
  renderXYZConfig(header, colTypes, xyzGuess);

  // Geometry
  if (geometry && geometry.x && geometry.y && geometry.z) {
    $geoSection.style.display = '';
    lastGeoData = geometry;
    const gx = geometry.x, gy = geometry.y, gz = geometry.z;
    const anySubBlocked = gx.isSubBlocked || gy.isSubBlocked || gz.isSubBlocked;
    const totalGrid = gx.gridCount * gy.gridCount * gz.gridCount;
    const fillPct = totalGrid > 0 ? (totalRowCount / totalGrid * 100) : 0;
    $geoBadge.textContent = anySubBlocked ? 'SUB-BLOCKED' : fillPct.toFixed(1) + '% filled';
    if (anySubBlocked) $geoBadge.style.background = 'var(--blue)';
    else $geoBadge.style.background = '';

    // Build sub-block row if needed
    const subRow = anySubBlocked
      ? geoRowT('Min Block',
          gx.isSubBlocked ? gx.minBlockSize : '—',
          gy.isSubBlocked ? gy.minBlockSize : '—',
          gz.isSubBlocked ? gz.minBlockSize : '—')
      : '';

    // Sub-block detail text
    let subDetail = '';
    if (anySubBlocked) {
      const parts = [];
      for (const [label, g] of [['X', gx], ['Y', gy], ['Z', gz]]) {
        if (g.isSubBlocked) {
          const ratios = g.subBlockSizes.map(s => `1/${s.ratio}`).join(', ');
          parts.push(`${label}: ${g.blockSize} → ${ratios}`);
        }
      }
      subDetail = `<div style="margin-top:0.5rem; font-size:0.75rem; color:var(--blue)">
        Sub-blocks: ${parts.join(' &nbsp;|&nbsp; ')}
      </div>`;
    }

    $geoContent.innerHTML = `
      <div class="geo-grid geo-grid-t">
        <div class="gh"></div><div class="gh">X</div><div class="gh">Y</div><div class="gh">Z</div>
        ${geoRowT('Origin', gx.origin, gy.origin, gz.origin)}
        ${geoRowT('Block Size', gx.blockSize, gy.blockSize, gz.blockSize)}
        ${subRow}
        ${geoRowT('Unique', gx.uniqueCount, gy.uniqueCount, gz.uniqueCount)}
        ${geoRowT('Grid Count', gx.gridCount, gy.gridCount, gz.gridCount)}
        ${geoRowT('Extent', gx.extent, gy.extent, gz.extent)}
      </div>
      <div style="margin-top:0.8rem; font-size:0.75rem; color:var(--fg-dim)">
        Parent grid cells: <strong style="color:var(--fg)">${totalGrid.toLocaleString()}</strong> &nbsp;|&nbsp;
        Total blocks: <strong style="color:var(--fg)">${totalRowCount.toLocaleString()}</strong>
        ${!anySubBlocked ? `&nbsp;|&nbsp; Fill ratio: <strong style="color:var(--amber)">${fillPct.toFixed(1)}%</strong>` : ''}
      </div>
      ${subDetail}
      ${coordOrder ? `<div style="margin-top:0.5rem; font-size:0.75rem; color:var(--fg-dim)">
        Loop order: <strong style="color:var(--fg)">${coordOrder.slowest}</strong> <span style="color:var(--fg-dim)">→</span> <strong style="color:var(--fg)">${coordOrder.middle}</strong> <span style="color:var(--fg-dim)">→</span> <strong style="color:var(--fg)">${coordOrder.fastest}</strong>
        <span style="opacity:0.6">&nbsp;(${coordOrder.slowest} slowest, ${coordOrder.fastest} fastest)</span>
      </div>` : ''}
      ${maxDecimals ? `<div style="margin-top:0.5rem; font-size:0.75rem; color:var(--fg-dim)">
        Rounding: X=${maxDecimals.x}dp, Y=${maxDecimals.y}dp, Z=${maxDecimals.z}dp <span style="opacity:0.5">(detected from data)</span>
      </div>` : ''}
      ${anySubBlocked && currentDXYZ.dx < 0 && currentDXYZ.dy < 0 && currentDXYZ.dz < 0 ? `<div style="margin-top:0.5rem; padding:0.4rem 0.6rem; border-radius:4px; background:rgba(255,180,0,0.12); border:1px solid rgba(255,180,0,0.3); font-size:0.75rem; color:#e5a800;">
        ⚠ This model appears sub-blocked. Assign DX/DY/DZ columns in Preflight for accurate block sizes.
      </div>` : ''}`;
  } else {
    lastGeoData = null;
    $geoSection.style.display = (xyzGuess.x < 0 || xyzGuess.y < 0 || xyzGuess.z < 0) ? '' : 'none';
    $geoBadge.textContent = '';
    $geoContent.innerHTML = '<div style="color:var(--fg-dim);font-size:0.78rem;">Could not detect XYZ columns — select them manually above.</div>';
  }

  // OBJ export button visibility
  document.getElementById('exportObjBtn').style.display = lastGeoData ? '' : 'none';

  // Column Overview
  const $colOverview = document.getElementById('colOverviewSection');
  const $colOverviewContent = document.getElementById('colOverviewContent');
  const $colOverviewBadge = document.getElementById('colOverviewBadge');
  if (header.length > 0) {
    $colOverview.style.display = '';
    let numCount = 0, catCount = 0;
    let ovHtml = '<div class="col-overview-wrap"><table class="col-overview"><thead><tr><th>Column</th><th>Type</th><th>Count</th><th>Nulls</th><th>Zeros</th><th>Completeness</th><th>Range / Unique</th></tr></thead><tbody>';
    for (let ci = 0; ci < header.length; ci++) {
      const cName = header[ci];
      const cType = colTypes[ci];
      const isNum = cType === 'numeric';
      if (isNum) numCount++; else catCount++;
      const s = isNum ? stats[ci] : null;
      const cat = !isNum ? categories[ci] : null;
      let count = 0, nulls = 0, zeros = null, rangeStr = '';
      if (s) {
        count = s.count; nulls = s.nulls; zeros = s.zeros;
        rangeStr = formatNum(s.min) + ' \u2192 ' + formatNum(s.max);
      } else if (cat) {
        const total = Object.values(cat.counts).reduce((a, b) => a + b, 0);
        const uniqueCount = Object.keys(cat.counts).length + (cat.overflow ? '+' : '');
        count = total; nulls = rowCount - total;
        rangeStr = uniqueCount + ' unique';
      } else {
        count = rowCount; nulls = 0;
        rangeStr = '\u2014';
      }
      const completePct = rowCount > 0 ? (count / rowCount * 100) : 0;
      const barW = Math.round(completePct * 48 / 100);
      const nullWarn = nulls > 0 && rowCount > 0 && (nulls / rowCount) > 0.1;
      const typeClass = isNum ? 'col-type-num' : 'col-type-cat';
      const typeLabel = isNum ? 'NUM' : 'CAT';
      ovHtml += '<tr>'
        + '<td class="col-name" title="' + esc(cName) + '">' + esc(cName) + '</td>'
        + '<td><span class="col-type ' + typeClass + '">' + typeLabel + '</span></td>'
        + '<td>' + count.toLocaleString() + '</td>'
        + '<td' + (nullWarn ? ' class="null-warn"' : '') + '>' + (nulls > 0 ? nulls.toLocaleString() : '\u2014') + '</td>'
        + '<td>' + (zeros !== null ? (zeros > 0 ? zeros.toLocaleString() : '\u2014') : '\u2014') + '</td>'
        + '<td><span class="completeness-track"><span class="completeness-bar" style="width:' + barW + 'px"></span></span> ' + completePct.toFixed(1) + '%</td>'
        + '<td>' + rangeStr + '</td>'
        + '</tr>';
    }
    ovHtml += '</tbody></table></div>';
    $colOverviewContent.innerHTML = ovHtml;
    $colOverviewBadge.textContent = numCount + ' num \u00B7 ' + catCount + ' cat';
  } else {
    $colOverview.style.display = 'none';
  }

  // Stats
  const origColCount = data.origColCount || header.length;
  const numCols = Object.keys(stats).map(Number).sort((a, b) => a - b);
  renderStatsTab(stats, header, origColCount, isFiltered, rowCount);

  // Categories
  const catCols = Object.keys(categories).map(Number).sort((a, b) => a - b);
  renderCategoriesTab(categories, header, origColCount, rowCount);

  // Restore pending project state (phase 2 — post-analysis)
  const restoredProject = pendingProjectRestore;
  if (restoredProject) {
    pendingProjectRestore = null;

    // StatsCat display state — restore before renderStatsCat() so UI renders correctly
    const sc = restoredProject.statsCat || {};
    // groupBy and selectedVars already restored in applyProject() (phase 1)
    if (sc.sortMode !== undefined) statsCatGroupSortMode = sc.sortMode;
    if (sc.cdfScale) statsCatCdfScale = sc.cdfScale;
    if (sc.cdfManual !== undefined) statsCatCdfManual = sc.cdfManual;
    if (sc.cdfMin !== undefined) statsCatCdfMin = sc.cdfMin;
    if (sc.cdfMax !== undefined) statsCatCdfMax = sc.cdfMax;
    if (sc.crossMode) statsCatCrossMode = sc.crossMode;
    if (sc.displayVar != null) currentStatsCatVar = sc.displayVar;
    if (sc.checkedGroups) currentStatsCatChecked = new Set(sc.checkedGroups);
    if (sc.showSelectedOnly !== undefined) statsCatShowSelectedOnly = sc.showSelectedOnly;

    // Stats tab
    const st = restoredProject.statsTab || {};
    if (st.selectedVars) statsSelectedVars = new Set(st.selectedVars);
    if (st.visibleMetrics) statsVisibleMetrics = new Set(st.visibleMetrics);
    if (st.percentiles) statsPercentiles = st.percentiles;
    if (st.cdfSelected) statsCdfSelected = new Set(st.cdfSelected);
    if (st.cdfScale) statsCdfScale = st.cdfScale;

    // Re-render stats tab with restored state
    if (lastDisplayedStats && lastDisplayedHeader) {
      renderStatsTab(lastDisplayedStats, lastDisplayedHeader, currentOrigColCount || lastDisplayedHeader.length, currentFilter !== null, data.rowCount);
    }

    // Restore categories focused column by name
    const catP = restoredProject.categories || {};
    if (catP.focusedCol) {
      const idx = header.indexOf(catP.focusedCol);
      if (idx >= 0 && categories[idx]) {
        catFocusedCol = idx;
        renderCatSidebar();
        renderCatMain();
      }
    }
  }

  // StatsCat — render after display state is restored (or with defaults)
  renderStatsCat(data);

  // Export
  initExportColumns();
  if (restoredProject) {
    if (restoredProject.exportCols) applyExportRestore(restoredProject.exportCols);
    if (restoredProject.exportSettings) restoreExportSettings(restoredProject.exportSettings);
  }

  // GT, Swath & Section
  // Snapshot current GT config before renderGtConfig rebuilds the sidebar
  var gtSnapshot = null;
  if (!restoredProject && document.getElementById('gtVarList')) {
    gtSnapshot = serializeProject().gt;
  }
  renderGtConfig(data);
  renderSwathConfig(data);
  renderSectionConfig(data);

  // Restore GT sidebar from project or snapshot
  var gtp = (restoredProject && restoredProject.gt) ? restoredProject.gt : gtSnapshot;
  if (gtp) {
    // Multi-grade checkbox restore (backward compat: old gradeCol string)
    var $gVarList = document.getElementById('gtVarList');
    if ($gVarList) {
      var names = gtp.gradeCols || (gtp.gradeCol ? [gtp.gradeCol] : []);
      var nameSet = {};
      for (var ni = 0; ni < names.length; ni++) nameSet[names[ni]] = true;
      var cbs = $gVarList.querySelectorAll('input[type="checkbox"]');
      for (var ci = 0; ci < cbs.length; ci++) {
        var lbl = cbs[ci].parentElement.querySelector('span').textContent;
        cbs[ci].checked = !!nameSet[lbl];
      }
    }
    // Group-by restore
    var $gGroupBy = document.getElementById('gtGroupBy');
    if ($gGroupBy && gtp.groupByCol) {
      for (var gbi = 0; gbi < $gGroupBy.options.length; gbi++) {
        if ($gGroupBy.options[gbi].textContent === gtp.groupByCol) { $gGroupBy.value = $gGroupBy.options[gbi].value; break; }
      }
    }
    var $gDensity = document.getElementById('gtDensityCol');
    var $gWeight = document.getElementById('gtWeightCol');
    if ($gDensity && gtp.densityCol) {
      for (var di = 0; di < $gDensity.options.length; di++) {
        if ($gDensity.options[di].textContent === gtp.densityCol) { $gDensity.value = $gDensity.options[di].value; break; }
      }
    }
    if ($gWeight && gtp.weightCol) {
      for (var wi = 0; wi < $gWeight.options.length; wi++) {
        if ($gWeight.options[wi].textContent === gtp.weightCol) { $gWeight.value = $gWeight.options[wi].value; break; }
      }
    }
    var $gLocalFilter = document.getElementById('gtLocalFilter');
    if ($gLocalFilter && gtp.localFilter) $gLocalFilter.value = gtp.localFilter;
    var $gCutoffMin = document.getElementById('gtCutoffMin');
    var $gCutoffMax = document.getElementById('gtCutoffMax');
    var $gCutoffStep = document.getElementById('gtCutoffStep');
    if ($gCutoffMin && gtp.cutoffMin != null) $gCutoffMin.value = gtp.cutoffMin;
    if ($gCutoffMax && gtp.cutoffMax != null) $gCutoffMax.value = gtp.cutoffMax;
    if ($gCutoffStep && gtp.cutoffStep != null) $gCutoffStep.value = gtp.cutoffStep;
    if (gtp.cutoffMode === 'custom') {
      var $gRadio = document.querySelector('input[name="gtCutoffMode"][value="custom"]');
      if ($gRadio) { $gRadio.checked = true; $gRadio.dispatchEvent(new Event('change')); }
      var $gCustomText = document.getElementById('gtCutoffCustomText');
      if ($gCustomText && gtp.cutoffCustom) $gCustomText.value = gtp.cutoffCustom;
    }
    var $gVolOverride = document.getElementById('gtVolOverride');
    if ($gVolOverride && gtp.volumeOverride) $gVolOverride.value = gtp.volumeOverride;
    var $gTonnageUnit = document.getElementById('gtTonnageUnit');
    if ($gTonnageUnit && gtp.tonnageUnit != null) {
      $gTonnageUnit.value = gtp.tonnageUnit;
      $gTonnageUnit.dispatchEvent(new Event('change'));
    }
    var $gCTSym = document.getElementById('gtCustomTonnageSym');
    var $gCTDiv = document.getElementById('gtCustomTonnageDiv');
    if ($gCTSym && gtp.customTonnageSym) $gCTSym.value = gtp.customTonnageSym;
    if ($gCTDiv && gtp.customTonnageDiv) $gCTDiv.value = gtp.customTonnageDiv;

    // Per-variable grade units
    var gradeUnits = gtp.gradeUnits || null;
    // Backward compat: old single gradeUnit → apply to all
    if (!gradeUnits && gtp.gradeUnit != null && gtp.gradeUnit > 0) {
      gradeUnits = {};
      document.querySelectorAll('.gt-var-unit').forEach(function(sel) {
        var colIdx = parseInt(sel.dataset.col);
        var colName = currentHeader[colIdx];
        if (colName) gradeUnits[colName] = gtp.gradeUnit;
      });
    }
    if (gradeUnits) {
      document.querySelectorAll('.gt-var-unit').forEach(function(sel) {
        var colIdx = parseInt(sel.dataset.col);
        var colName = currentHeader[colIdx];
        if (colName && gradeUnits[colName] != null) sel.value = gradeUnits[colName];
      });
    }

    // Restore group-by values and trigger checkbox population
    if (gtp.groupByCol && $gGroupBy && $gGroupBy.value !== '-1') {
      updateGroupByValues();
      // Restore selected groups
      if (gtp.selectedGroups) {
        var sg = gtp.selectedGroups;
        var valSet = new Set(sg.values || []);
        document.querySelectorAll('#gtGrpList input[type="checkbox"]').forEach(function(cb) {
          if (cb.value === '__total__') cb.checked = !!sg.showTotal;
          else cb.checked = valSet.has(cb.value);
        });
      }
    }
  }

  // Restore active tab
  if (restoredProject && restoredProject.activeTab) {
    switchTab(restoredProject.activeTab);
  }

  // Auto-save project
  autoSaveProject();

  // Update tab badges
  const statsTab = $resultsTabs.querySelector('[data-tab="statistics"]');
  const catTab = $resultsTabs.querySelector('[data-tab="categories"]');
  const calcolTab = $resultsTabs.querySelector('[data-tab="calcols"]');
  const statsCatTab = $resultsTabs.querySelector('[data-tab="statscat"]');
  const exportTab = $resultsTabs.querySelector('[data-tab="export"]');
  statsTab.innerHTML = `Statistics <span class="tab-badge">${numCols.length}</span>`;
  catTab.innerHTML = `Categories <span class="tab-badge">${catCols.length}</span>`;
  calcolTab.innerHTML = `Calc <span class="tab-badge">${currentCalcolMeta.length}</span>`;
  exportTab.innerHTML = `Export <span class="tab-badge">${currentHeader.length}</span>`;
  if (currentGroupBy !== null && (data.groupStats || data.groupCategories)) {
    const gbName = header[currentGroupBy] || '?';
    const firstGS = data.groupStats && Object.keys(data.groupStats)[0] ? data.groupStats[Object.keys(data.groupStats)[0]] : null;
    const firstGC = data.groupCategories && Object.keys(data.groupCategories)[0] ? data.groupCategories[Object.keys(data.groupCategories)[0]] : null;
    const groupCount = firstGS ? Object.keys(firstGS).length : (firstGC ? Object.keys(firstGC).length : 0);
    statsCatTab.innerHTML = `StatsCat <span class="tab-badge">${groupCount}</span>`;
    $statsCatBadge.textContent = gbName + ' \u00B7 ' + groupCount + ' groups';
  } else {
    statsCatTab.innerHTML = 'StatsCat';
    $statsCatBadge.textContent = '';
  }

  // Swath/Section tab labels (no badge until generated)
  const swathTab = $resultsTabs.querySelector('[data-tab="swath"]');
  const sectionTab = $resultsTabs.querySelector('[data-tab="section"]');
  if (swathTab) swathTab.textContent = 'Swath';
  if (sectionTab) sectionTab.textContent = 'Section';

  // Render calcol editor
  renderVariableBrowser();
  enableSimulatedDataSource();
}

function renderStatsCat(data) {
  const { header, colTypes, groupStats, groupCategories } = data;
  const origColCount = data.origColCount || header.length;
  lastStatsCatData = data;

  // Populate dropdown with categorical columns
  const catColIdxs = [];
  for (let i = 0; i < header.length; i++) {
    if (colTypes[i] === 'categorical') catColIdxs.push(i);
  }
  let opts = '<option value="">— select grouping column —</option>';
  for (const i of catColIdxs) {
    const sel = currentGroupBy === i ? ' selected' : '';
    const isCalcol = i >= origColCount;
    opts += '<option value="' + i + '"' + sel + '>' + esc(header[i]) + (isCalcol ? ' (calc)' : '') + '</option>';
  }
  $statsCatGroupBy.innerHTML = opts;

  // If no groupBy selected or no groupStats, show empty states
  if (currentGroupBy === null || !groupStats) {
    $statsCatVarList.innerHTML = '';
    $statsCatGroupList.innerHTML = '';
    $statsCatContent.innerHTML = '<div class="statscat-empty">Select a categorical column to see statistics broken down by group.</div>';
    return;
  }

  // Build combined variable list: numeric + categorical (excluding groupBy)
  const numCols = Object.keys(data.stats).map(Number).sort((a, b) => a - b);
  const catVarCols = [];
  for (let i = 0; i < header.length; i++) {
    if (colTypes[i] === 'categorical' && i !== currentGroupBy) catVarCols.push(i);
  }
  const allVarCols = [...numCols, ...catVarCols].sort((a, b) => a - b);

  if (allVarCols.length === 0) {
    $statsCatVarList.innerHTML = '';
    $statsCatGroupList.innerHTML = '';
    $statsCatContent.innerHTML = '<div class="statscat-empty">No variables available for analysis.</div>';
    return;
  }

  // Initialize selected vars if empty (first time or after file change)
  if (statsCatSelectedVars.size === 0) {
    for (const i of allVarCols) statsCatSelectedVars.add(i);
  }

  // Auto-select first variable that has data for display
  if (currentStatsCatVar === null || (!groupStats[currentStatsCatVar] && !(groupCategories && groupCategories[currentStatsCatVar]))) {
    const analyzed = allVarCols.filter(i => groupStats[i] || (groupCategories && groupCategories[i]));
    currentStatsCatVar = analyzed.length > 0 ? analyzed[0] : allVarCols[0];
  }

  // Populate variable list
  renderStatsCatVarList(allVarCols, header, origColCount, colTypes);

  // Determine group values from selected variable (use whichever data source exists)
  const gs = groupStats[currentStatsCatVar];
  const gc = groupCategories && groupCategories[currentStatsCatVar];
  let allGroupKeys;
  if (gs) {
    allGroupKeys = Object.keys(gs);
  } else if (gc) {
    allGroupKeys = Object.keys(gc);
  } else {
    allGroupKeys = [];
  }

  // Build allGroups with counts for group list
  const allGroups = allGroupKeys.map(gv => {
    if (gs && gs[gv]) return [gv, gs[gv]];
    if (gc && gc[gv]) {
      const total = Object.values(gc[gv]).reduce((s, c) => s + c, 0);
      return [gv, { count: total }];
    }
    return [gv, { count: 0 }];
  });

  // Initialize checked set to all if null
  if (currentStatsCatChecked === null) {
    currentStatsCatChecked = new Set(allGroupKeys);
  }

  // Populate group list
  renderStatsCatGroupList(allGroups);

  // Wire sidebar events
  wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);

  // Render right content
  renderStatsCatContent();
}

function renderStatsCatVarList(allVarCols, header, origColCount, colTypes) {
  const search = $statsCatVarSearch.value.toLowerCase();
  let html = '';
  for (const colIdx of allVarCols) {
    if (statsCatShowSelectedOnly && !statsCatSelectedVars.has(colIdx)) continue;
    const name = header[colIdx];
    if (search && !fuzzyMatch(search, name.toLowerCase())) continue;
    const isCalcol = colIdx >= origColCount;
    const isCat = colTypes[colIdx] === 'categorical';
    const active = colIdx === currentStatsCatVar ? ' active' : '';
    const checked = statsCatSelectedVars.has(colIdx) ? ' checked' : '';
    const unchecked = !statsCatSelectedVars.has(colIdx) ? ' unchecked' : '';
    html += '<div class="statscat-var-item' + active + unchecked + '" data-col="' + colIdx + '">';
    html += '<input type="checkbox"' + checked + ' data-col="' + colIdx + '">';
    html += '<span class="var-name">' + esc(name) + '</span>';
    if (isCalcol) html += '<span class="calcol-tag">CALC</span>';
    html += '<span class="var-type-tag ' + (isCat ? 'cat' : 'num') + '">' + (isCat ? 'CAT' : 'NUM') + '</span>';
    html += '</div>';
  }
  $statsCatVarList.innerHTML = html;
  // Update filter toggle state
  $statsCatVarFilter.textContent = statsCatShowSelectedOnly ? 'Selected' : 'All';
  $statsCatVarFilter.classList.toggle('active', statsCatShowSelectedOnly);
}

function getEffectiveStatsCatSort() {
  if (statsCatGroupSortMode !== null) return statsCatGroupSortMode;
  // Inherit from Categories tab
  const gbColName = currentGroupBy !== null && currentHeader[currentGroupBy] ? currentHeader[currentGroupBy] : null;
  if (gbColName && catSortModes[gbColName]) return catSortModes[gbColName];
  return 'count-desc';
}

function sortStatsCatGroups(groups) {
  const mode = getEffectiveStatsCatSort();
  if (mode === 'alpha') {
    return groups.slice().sort((a, b) => (a[0] || '').localeCompare(b[0] || ''));
  }
  if (mode === 'count-asc') {
    return groups.slice().sort((a, b) => a[1].count - b[1].count);
  }
  if (mode === 'custom') {
    const gbColName = currentGroupBy !== null && currentHeader[currentGroupBy] ? currentHeader[currentGroupBy] : null;
    const order = gbColName && catCustomOrders[gbColName] ? catCustomOrders[gbColName] : null;
    if (order) {
      const pos = {};
      for (let i = 0; i < order.length; i++) pos[order[i]] = i;
      return groups.slice().sort((a, b) => {
        const pa = pos[a[0]] !== undefined ? pos[a[0]] : Infinity;
        const pb = pos[b[0]] !== undefined ? pos[b[0]] : Infinity;
        if (pa !== pb) return pa - pb;
        return b[1].count - a[1].count; // fallback: count-desc for unordered
      });
    }
  }
  // count-desc (default)
  return groups.slice().sort((a, b) => b[1].count - a[1].count);
}

function renderStatsCatGroupList(allGroups) {
  const sorted = sortStatsCatGroups(allGroups);
  const search = $statsCatGroupSearch.value.toLowerCase();
  let html = '';
  for (const [gv, s] of sorted) {
    const label = gv || '(empty)';
    if (search && !fuzzyMatch(search, label.toLowerCase())) continue;
    const checked = currentStatsCatChecked && currentStatsCatChecked.has(gv) ? ' checked' : '';
    html += '<div class="statscat-group-item">';
    html += '<label><input type="checkbox"' + checked + ' data-gv="' + esc(gv) + '"> <span class="gname">' + esc(label) + '</span></label>';
    html += '<span class="gcount">' + s.count.toLocaleString() + '</span>';
    html += '</div>';
  }
  $statsCatGroupList.innerHTML = html;
}

function getStatsCatGroupEntries() {
  const data = lastStatsCatData;
  if (!data) return [];
  const gs = data.groupStats[currentStatsCatVar];
  const gc = data.groupCategories && data.groupCategories[currentStatsCatVar];
  if (gs) return Object.entries(gs);
  if (gc) return Object.entries(gc).map(([gv, counts]) => [gv, { count: Object.values(counts).reduce((s, c) => s + c, 0) }]);
  return [];
}

function wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes) {
  // Variable row click — select for display (ignore if click was on checkbox)
  $statsCatVarList.querySelectorAll('.statscat-var-item').forEach(el => {
    el.addEventListener('click', (e) => {
      if (e.target.tagName === 'INPUT') return;
      const colIdx = parseInt(el.dataset.col);
      if (colIdx === currentStatsCatVar) return;
      currentStatsCatVar = colIdx;

      renderStatsCatVarList(allVarCols, header, origColCount, colTypes);
      renderStatsCatGroupList(getStatsCatGroupEntries());
      wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
      renderStatsCatContent();
      autoSaveProject();
    });
  });

  // Variable checkboxes — toggle inclusion for analysis
  $statsCatVarList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    cb.addEventListener('change', (e) => {
      e.stopPropagation();
      const colIdx = parseInt(cb.dataset.col);
      if (cb.checked) {
        statsCatSelectedVars.add(colIdx);
        // Only mark stale if this column lacks data from last analysis
        if (lastStatsCatData && !(lastStatsCatData.groupStats[colIdx] || (lastStatsCatData.groupCategories && lastStatsCatData.groupCategories[colIdx]))) {
          markAnalysisStale();
        }
      } else {
        statsCatSelectedVars.delete(colIdx);
        // Unchecking never needs re-analysis — data already computed
      }
      renderStatsCatVarList(allVarCols, header, origColCount, colTypes);
      wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
      autoSaveProject();
    });
  });

  // Variable All/None — affect only search-filtered results
  $statsCatVarAll.onclick = () => {
    let needsStale = false;
    $statsCatVarList.querySelectorAll('.statscat-var-item').forEach(el => {
      const ci = parseInt(el.dataset.col);
      statsCatSelectedVars.add(ci);
      if (lastStatsCatData && !(lastStatsCatData.groupStats[ci] || (lastStatsCatData.groupCategories && lastStatsCatData.groupCategories[ci]))) {
        needsStale = true;
      }
    });
    renderStatsCatVarList(allVarCols, header, origColCount, colTypes);
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
    if (needsStale) markAnalysisStale();
    autoSaveProject();
  };
  $statsCatVarNone.onclick = () => {
    $statsCatVarList.querySelectorAll('.statscat-var-item').forEach(el => {
      statsCatSelectedVars.delete(parseInt(el.dataset.col));
    });
    renderStatsCatVarList(allVarCols, header, origColCount, colTypes);
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
    // Unchecking never needs re-analysis
    autoSaveProject();
  };

  // Variable filter toggle (All / Selected)
  $statsCatVarFilter.onclick = () => {
    statsCatShowSelectedOnly = !statsCatShowSelectedOnly;
    renderStatsCatVarList(allVarCols, header, origColCount, colTypes);
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
    autoSaveProject();
  };

  // Group checkboxes
  $statsCatGroupList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    cb.addEventListener('change', () => {
      const gv = cb.dataset.gv;
      if (cb.checked) { currentStatsCatChecked.add(gv); } else { currentStatsCatChecked.delete(gv); }
      renderStatsCatContent();
      autoSaveProject();
    });
  });

  // All/None buttons
  $statsCatGroupAll.onclick = () => {
    const entries = getStatsCatGroupEntries();
    currentStatsCatChecked = new Set(entries.map(e => e[0]));
    renderStatsCatGroupList(entries);
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
    renderStatsCatContent();
    autoSaveProject();
  };
  $statsCatGroupNone.onclick = () => {
    currentStatsCatChecked = new Set();
    renderStatsCatGroupList(getStatsCatGroupEntries());
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
    renderStatsCatContent();
    autoSaveProject();
  };

  // Sort toggle — cycle: count-desc → count-asc → alpha → custom (if exists) → count-desc
  var sortLabels = { 'count-desc': 'Count\u2193', 'count-asc': 'Count\u2191', 'alpha': 'A-Z', 'custom': 'Custom' };
  $statsCatGroupSort.textContent = sortLabels[getEffectiveStatsCatSort()] || 'Count\u2193';
  $statsCatGroupSort.onclick = () => {
    var eff = getEffectiveStatsCatSort();
    var gbColName = currentGroupBy !== null && currentHeader[currentGroupBy] ? currentHeader[currentGroupBy] : null;
    var hasCustom = gbColName && catCustomOrders[gbColName] && catCustomOrders[gbColName].length > 0;
    var cycle = ['count-desc', 'count-asc', 'alpha'];
    if (hasCustom) cycle.push('custom');
    var idx = cycle.indexOf(eff);
    statsCatGroupSortMode = cycle[(idx + 1) % cycle.length];
    $statsCatGroupSort.textContent = sortLabels[getEffectiveStatsCatSort()];
    renderStatsCatGroupList(getStatsCatGroupEntries());
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
    renderStatsCatContent();
    autoSaveProject();
  };

  // Variable search
  $statsCatVarSearch.oninput = () => {
    renderStatsCatVarList(allVarCols, header, origColCount, colTypes);
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
  };

  // Group search
  $statsCatGroupSearch.oninput = () => {
    renderStatsCatGroupList(getStatsCatGroupEntries());
    wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
  };

}

function renderStatsCatContent() {
  const data = lastStatsCatData;
  if (!data) {
    $statsCatContent.innerHTML = '<div class="statscat-empty">No grouped statistics available.</div>';
    return;
  }
  if (currentStatsCatVar === null) {
    $statsCatContent.innerHTML = '<div class="statscat-empty">Select a variable from the sidebar.</div>';
    return;
  }
  if (!currentStatsCatChecked || currentStatsCatChecked.size === 0) {
    $statsCatContent.innerHTML = '<div class="statscat-empty">No groups selected. Check groups in the sidebar to view statistics.</div>';
    return;
  }

  const header = data.header;
  const colTypes = data.colTypes;
  const origColCount = data.origColCount || header.length;
  const varName = header[currentStatsCatVar];
  const isCalcol = currentStatsCatVar >= origColCount;
  const isCatVar = colTypes[currentStatsCatVar] === 'categorical';

  if (isCatVar) {
    renderStatsCatCrossTab(data, varName, isCalcol);
  } else {
    renderStatsCatNumeric(data, varName, isCalcol);
  }
}

function renderStatsCatNumeric(data, varName, isCalcol) {
  const gs = data.groupStats[currentStatsCatVar];
  if (!gs) {
    $statsCatContent.innerHTML = '<div class="statscat-empty">This variable was not included in the analysis. Check its checkbox and click Analyze.</div>';
    return;
  }

  // Filter entries to checked groups, apply current sort
  const entries = sortStatsCatGroups(
    Object.entries(gs).filter(([gv]) => currentStatsCatChecked.has(gv))
  );

  // Header with copy button
  let html = '<div style="display:flex;align-items:center;gap:0.8rem;margin-bottom:0.5rem;">';
  html += '<span style="font-size:0.82rem;font-weight:600;color:var(--fg-bright);">' + esc(varName) + (isCalcol ? ' <span class="calcol-tag">CALC</span>' : '') + '</span>';
  html += '<button class="statscat-copy-btn" id="statsCatCopyBtn">Copy table</button>';
  html += '</div>';

  html += '<div class="statscat-table-wrap"><table class="stats"><thead><tr><th>Group</th><th>Count</th><th>Nulls</th><th>Min</th><th>P10</th><th>P25</th><th>P50</th><th>P75</th><th>P90</th><th>Max</th><th>Mean</th><th>Std</th><th>CV%</th><th>Skew</th><th>Kurt</th></tr></thead><tbody>';

  for (const [gv, s] of entries) {
    const cv = (s.mean && s.std && s.mean !== 0) ? Math.abs(s.std / s.mean * 100) : null;
    const q = s.quantiles;
    html += '<tr>';
    html += '<td>' + esc(gv || '(empty)') + '</td>';
    html += '<td>' + s.count.toLocaleString() + '</td>';
    html += '<td>' + (s.nulls > 0 ? s.nulls.toLocaleString() : '\u2014') + '</td>';
    html += '<td>' + formatNum(s.min) + '</td>';
    html += '<td>' + (q ? formatNum(q.p10) : '\u2014') + '</td>';
    html += '<td>' + (q ? formatNum(q.p25) : '\u2014') + '</td>';
    html += '<td>' + (q ? formatNum(q.p50) : '\u2014') + '</td>';
    html += '<td>' + (q ? formatNum(q.p75) : '\u2014') + '</td>';
    html += '<td>' + (q ? formatNum(q.p90) : '\u2014') + '</td>';
    html += '<td>' + formatNum(s.max) + '</td>';
    html += '<td>' + formatNum(s.mean) + '</td>';
    html += '<td>' + formatNum(s.std) + '</td>';
    html += '<td>' + (cv !== null ? (cv > 9999 ? '>9999' : cv.toFixed(1)) : '\u2014') + '</td>';
    html += '<td>' + (s.skewness !== null ? s.skewness.toFixed(2) : '\u2014') + '</td>';
    html += '<td>' + (s.kurtosis !== null ? s.kurtosis.toFixed(2) : '\u2014') + '</td>';
    html += '</tr>';
  }
  html += '</tbody></table></div>';

  // CDF toolbar
  html += '<div class="statscat-cdf-toolbar">';
  html += '<div class="tb-group"><button class="sc-scale' + (statsCatCdfScale === 'linear' ? ' active' : '') + '" data-scale="linear">Linear</button>';
  html += '<button class="sc-scale' + (statsCatCdfScale === 'log' ? ' active' : '') + '" data-scale="log">Log</button></div>';
  html += '<div class="tb-group"><label><input type="checkbox" id="scManualCb"' + (statsCatCdfManual ? ' checked' : '') + '> Manual</label>';
  if (statsCatCdfManual) {
    html += '<input type="number" id="scManualMin" placeholder="min" step="any"' + (statsCatCdfMin !== null ? ' value="' + statsCatCdfMin + '"' : '') + '>';
    html += '<input type="number" id="scManualMax" placeholder="max" step="any"' + (statsCatCdfMax !== null ? ' value="' + statsCatCdfMax + '"' : '') + '>';
  }
  html += '</div>';
  html += '<div class="tb-group" style="margin-left:auto"><button id="scCopySvg">Copy SVG</button><button id="scDownloadPng">Download PNG</button></div>';
  html += '</div>';

  // CDF plot
  html += renderOverlaidCDF(entries, varName);

  $statsCatContent.innerHTML = html;
  wireStatsCatCopyBtn();
  wireStatsCatCdfToolbar();
}

function renderStatsCatCrossTab(data, varName, isCalcol) {
  const gc = data.groupCategories && data.groupCategories[currentStatsCatVar];
  if (!gc) {
    $statsCatContent.innerHTML = '<div class="statscat-empty">This variable was not included in the analysis. Check its checkbox and click Analyze.</div>';
    return;
  }

  // Get checked groups
  const groupKeys = sortStatsCatGroups(
    Object.entries(gc).filter(([gv]) => currentStatsCatChecked.has(gv)).map(([gv, counts]) => [gv, { count: Object.values(counts).reduce((s, c) => s + c, 0) }])
  ).map(([gv]) => gv);

  // Collect all unique values across checked groups
  const allVals = new Set();
  for (const gv of groupKeys) {
    if (gc[gv]) for (const v of Object.keys(gc[gv])) allVals.add(v);
  }
  const valList = Array.from(allVals).sort();

  // Header
  let html = '<div style="display:flex;align-items:center;gap:0.8rem;margin-bottom:0.5rem;">';
  html += '<span style="font-size:0.82rem;font-weight:600;color:var(--fg-bright);">' + esc(varName) + (isCalcol ? ' <span class="calcol-tag">CALC</span>' : '') + '</span>';
  html += '<button class="statscat-copy-btn" id="statsCatCopyBtn">Copy table</button>';
  html += '</div>';

  // Mode toggle
  html += '<div class="statscat-crosstab-mode">';
  html += '<button class="ct-mode' + (statsCatCrossMode === 'count' ? ' active' : '') + '" data-mode="count">Count</button>';
  html += '<button class="ct-mode' + (statsCatCrossMode === 'row' ? ' active' : '') + '" data-mode="row">Row %</button>';
  html += '<button class="ct-mode' + (statsCatCrossMode === 'col' ? ' active' : '') + '" data-mode="col">Col %</button>';
  html += '</div>';

  // Compute totals
  const rowTotals = {};
  const colTotals = {};
  let grandTotal = 0;
  for (const gv of groupKeys) {
    rowTotals[gv] = 0;
    for (const v of valList) {
      const c = (gc[gv] && gc[gv][v]) || 0;
      rowTotals[gv] += c;
      colTotals[v] = (colTotals[v] || 0) + c;
      grandTotal += c;
    }
  }

  // Find max value for heatmap
  let maxPct = 0;
  if (statsCatCrossMode !== 'count') {
    for (const gv of groupKeys) {
      for (const v of valList) {
        const c = (gc[gv] && gc[gv][v]) || 0;
        const pct = statsCatCrossMode === 'row' ? (rowTotals[gv] > 0 ? c / rowTotals[gv] : 0) : (colTotals[v] > 0 ? c / colTotals[v] : 0);
        if (pct > maxPct) maxPct = pct;
      }
    }
  }

  // Table
  html += '<div class="statscat-table-wrap"><table class="stats"><thead><tr><th>Group</th>';
  for (const v of valList) html += '<th>' + esc(v) + '</th>';
  html += '<th>Total</th></tr></thead><tbody>';

  for (const gv of groupKeys) {
    html += '<tr><td>' + esc(gv || '(empty)') + '</td>';
    for (const v of valList) {
      const c = (gc[gv] && gc[gv][v]) || 0;
      let display, bg = '';
      if (statsCatCrossMode === 'count') {
        display = c > 0 ? c.toLocaleString() : '\u2014';
      } else if (statsCatCrossMode === 'row') {
        const pct = rowTotals[gv] > 0 ? c / rowTotals[gv] * 100 : 0;
        display = c > 0 ? pct.toFixed(1) + '%' : '\u2014';
        if (c > 0) bg = 'background:rgba(232,163,23,' + (pct / 100 * 0.35).toFixed(2) + ')';
      } else {
        const pct = colTotals[v] > 0 ? c / colTotals[v] * 100 : 0;
        display = c > 0 ? pct.toFixed(1) + '%' : '\u2014';
        if (c > 0) bg = 'background:rgba(232,163,23,' + (pct / 100 * 0.35).toFixed(2) + ')';
      }
      html += '<td' + (bg ? ' style="' + bg + '"' : '') + '>' + display + '</td>';
    }
    html += '<td>' + rowTotals[gv].toLocaleString() + '</td></tr>';
  }

  // Column totals row
  html += '<tr style="border-top:2px solid var(--border);font-weight:600"><td>Total</td>';
  for (const v of valList) html += '<td>' + (colTotals[v] || 0).toLocaleString() + '</td>';
  html += '<td>' + grandTotal.toLocaleString() + '</td></tr>';

  html += '</tbody></table></div>';

  $statsCatContent.innerHTML = html;
  wireStatsCatCopyBtn();
  wireStatsCatCrossMode();
}

function wireStatsCatCrossMode() {
  $statsCatContent.querySelectorAll('.ct-mode').forEach(btn => {
    btn.addEventListener('click', () => {
      statsCatCrossMode = btn.dataset.mode;
      renderStatsCatContent();
      autoSaveProject();
    });
  });
}

function renderOverlaidCDF(entries, varName) {
  const plotEntries = entries.filter(([, s]) => s.centroids && s.centroids.length > 0);
  if (plotEntries.length === 0) return '';

  const isLog = statsCatCdfScale === 'log';
  const W = 700, plotBaseH = 380;
  const pad = { top: 20, right: 30, bottom: 50, left: 60 };
  const plotW = W - pad.left - pad.right;
  const plotH = plotBaseH - pad.top - pad.bottom;

  // Legend layout: 3 columns, wrapping rows
  const legCols = 3;
  const legRowH = 16;
  const legPadTop = 12;
  const legRows = Math.ceil(plotEntries.length / legCols);
  const legendH = legPadTop + legRows * legRowH + 6;
  const H = plotBaseH + legendH;

  // Determine x-axis range
  let globalMin = Infinity, globalMax = -Infinity;
  for (const [, s] of plotEntries) {
    if (s.min < globalMin) globalMin = s.min;
    if (s.max > globalMax) globalMax = s.max;
  }
  if (statsCatCdfManual) {
    if (statsCatCdfMin !== null) globalMin = statsCatCdfMin;
    if (statsCatCdfMax !== null) globalMax = statsCatCdfMax;
  }

  // For log scale, clamp min to positive
  let logMin, logMax;
  if (isLog) {
    logMin = Math.log10(Math.max(globalMin, 1e-10));
    logMax = Math.log10(Math.max(globalMax, 1e-9));
    if (logMax <= logMin) logMax = logMin + 1;
  }
  const xRange = isLog ? (logMax - logMin) : (globalMax - globalMin || 1);

  function sx(v) {
    if (isLog) {
      const lv = Math.log10(Math.max(v, 1e-10));
      return pad.left + ((lv - logMin) / xRange) * plotW;
    }
    return pad.left + ((v - globalMin) / xRange) * plotW;
  }
  function sy(v) { return pad.top + (1 - v) * plotH; }

  // Grid
  const yTicks = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0];
  let gridSvg = '';
  for (const yt of yTicks) {
    const y = sy(yt);
    gridSvg += '<line x1="' + pad.left + '" y1="' + y + '" x2="' + (W - pad.right) + '" y2="' + y + '" stroke="#1e2228" stroke-width="1"/>';
    gridSvg += '<text x="' + (pad.left - 8) + '" y="' + (y + 3.5) + '" text-anchor="end" fill="#6a737d" font-size="10">' + (yt * 100).toFixed(0) + '%</text>';
  }
  const nxTicks = 6;
  for (let i = 0; i <= nxTicks; i++) {
    let v;
    if (isLog) {
      v = Math.pow(10, logMin + (xRange * i / nxTicks));
    } else {
      v = globalMin + ((globalMax - globalMin || 1) * i / nxTicks);
    }
    const x = sx(v);
    gridSvg += '<line x1="' + x + '" y1="' + pad.top + '" x2="' + x + '" y2="' + (plotBaseH - pad.bottom) + '" stroke="#1e2228" stroke-width="1"/>';
    const label = Math.abs(v) >= 1e5 || (Math.abs(v) < 0.01 && v !== 0) ? v.toExponential(1) : v.toFixed(Math.abs(v) < 10 ? 2 : 0);
    gridSvg += '<text x="' + x + '" y="' + (plotBaseH - pad.bottom + 16) + '" text-anchor="middle" fill="#6a737d" font-size="10">' + label + '</text>';
  }

  let curvesSvg = '';
  let meansSvg = '';
  const gbColName = currentGroupBy !== null ? currentHeader[currentGroupBy] : '';
  for (let gi = 0; gi < plotEntries.length; gi++) {
    const [gv, s] = plotEntries[gi];
    const color = getCategoryColor(gbColName, gv, gi);
    const points = [];
    let cumCount = 0;
    for (const [mean, count] of s.centroids) {
      if (isLog && mean <= 0) { cumCount += count; continue; }
      cumCount += count;
      const px = sx(mean);
      if (px < pad.left || px > W - pad.right) continue;
      points.push({ x: px, y: sy(cumCount / s.count) });
    }
    if (points.length > 0) {
      const pathParts = points.map((p, i) => (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ',' + p.y.toFixed(1));
      curvesSvg += '<path d="' + pathParts.join(' ') + '" fill="none" stroke="' + color + '" stroke-width="1.5" opacity="0.85"/>';
    }
    if (s.mean !== null && (!isLog || s.mean > 0)) {
      const mx = sx(s.mean);
      if (mx >= pad.left && mx <= W - pad.right) {
        meansSvg += '<line x1="' + mx + '" y1="' + pad.top + '" x2="' + mx + '" y2="' + (plotBaseH - pad.bottom) + '" stroke="' + color + '" stroke-width="1" stroke-dasharray="4,3" opacity="0.5"/>';
      }
    }
  }

  // Legend inside SVG
  const legTop = plotBaseH + legPadTop;
  const colW = (W - pad.left - pad.right) / legCols;
  let legendSvg = '';
  for (let gi = 0; gi < plotEntries.length; gi++) {
    const [gv] = plotEntries[gi];
    const color = getCategoryColor(gbColName, gv, gi);
    const col = gi % legCols;
    const row = Math.floor(gi / legCols);
    const lx = pad.left + col * colW;
    const ly = legTop + row * legRowH;
    legendSvg += '<line x1="' + lx + '" y1="' + (ly + 5) + '" x2="' + (lx + 18) + '" y2="' + (ly + 5) + '" stroke="' + color + '" stroke-width="2.5"/>';
    legendSvg += '<text x="' + (lx + 24) + '" y="' + (ly + 9) + '" fill="#6a737d" font-size="9.5">' + esc(gv || '(empty)') + '</text>';
  }

  const scaleLabel = isLog ? ' (log)' : '';
  const svg = '<svg viewBox="0 0 ' + W + ' ' + H + '" xmlns="http://www.w3.org/2000/svg" style="font-family:var(--mono)" id="statsCatCdfSvg">' +
    '<rect width="' + W + '" height="' + H + '" fill="var(--bg)" rx="4"/>' +
    gridSvg + meansSvg + curvesSvg +
    '<text x="' + (W / 2) + '" y="' + (plotBaseH - 4) + '" text-anchor="middle" fill="#6a737d" font-size="10">CDF' + scaleLabel + ' \u2014 ' + esc(varName) + '</text>' +
    '<text x="12" y="' + (plotBaseH / 2) + '" text-anchor="middle" fill="#6a737d" font-size="10" transform="rotate(-90, 12, ' + (plotBaseH / 2) + ')">Cumulative %</text>' +
    legendSvg +
    '</svg>';

  return '<div class="statscat-cdf-plot">' + svg + '</div>';
}

function wireStatsCatCdfToolbar() {
  // Scale buttons
  $statsCatContent.querySelectorAll('.sc-scale').forEach(btn => {
    btn.addEventListener('click', () => {
      statsCatCdfScale = btn.dataset.scale;
      renderStatsCatContent();
      autoSaveProject();
    });
  });
  // Manual checkbox
  const manualCb = document.getElementById('scManualCb');
  if (manualCb) {
    manualCb.addEventListener('change', () => {
      statsCatCdfManual = manualCb.checked;
      if (!statsCatCdfManual) { statsCatCdfMin = null; statsCatCdfMax = null; }
      renderStatsCatContent();
      autoSaveProject();
    });
  }
  // Manual min/max inputs
  const minInput = document.getElementById('scManualMin');
  const maxInput = document.getElementById('scManualMax');
  if (minInput) {
    minInput.addEventListener('change', () => {
      statsCatCdfMin = minInput.value !== '' ? parseFloat(minInput.value) : null;
      renderStatsCatContent();
      autoSaveProject();
    });
  }
  if (maxInput) {
    maxInput.addEventListener('change', () => {
      statsCatCdfMax = maxInput.value !== '' ? parseFloat(maxInput.value) : null;
      renderStatsCatContent();
      autoSaveProject();
    });
  }
  // Copy SVG
  const copySvg = document.getElementById('scCopySvg');
  if (copySvg) {
    copySvg.addEventListener('click', () => {
      const svgEl = document.getElementById('statsCatCdfSvg');
      if (!svgEl) return;
      navigator.clipboard.writeText(svgEl.outerHTML).then(() => {
        copySvg.textContent = 'Copied!';
        setTimeout(() => { copySvg.textContent = 'Copy SVG'; }, 1500);
      });
    });
  }
  // Download PNG — light theme for documents
  const dlPng = document.getElementById('scDownloadPng');
  if (dlPng) {
    dlPng.addEventListener('click', () => {
      const svgEl = document.getElementById('statsCatCdfSvg');
      if (!svgEl) return;
      let svgData = new XMLSerializer().serializeToString(svgEl);
      // Retheme for light background: white bg, dark text/lines
      svgData = svgData.replace(/fill="var\(--bg\)"/g, 'fill="white"');
      svgData = svgData.replace(/fill="#6a737d"/g, 'fill="#333"');
      svgData = svgData.replace(/stroke="#1e2228"/g, 'stroke="#ddd"');
      svgData = svgData.replace(/style="font-family:var\(--mono\)"/g, 'style="font-family:monospace"');
      const canvas = document.createElement('canvas');
      const scale = 2;
      const vb = svgEl.getAttribute('viewBox').split(' ').map(Number);
      canvas.width = vb[2] * scale;
      canvas.height = vb[3] * scale;
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'cdf_plot.png';
          a.click();
          URL.revokeObjectURL(url);
        }, 'image/png');
      };
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    });
  }
}

function wireStatsCatCopyBtn() {
  const btn = document.getElementById('statsCatCopyBtn');
  if (!btn) return;
  btn.addEventListener('click', () => {
    const table = $statsCatContent.querySelector('table.stats');
    if (!table) return;
    const rows = table.querySelectorAll('tr');
    const lines = [];
    rows.forEach(row => {
      const cells = row.querySelectorAll('th, td');
      const vals = [];
      cells.forEach(c => vals.push(c.textContent));
      lines.push(vals.join('\t'));
    });
    navigator.clipboard.writeText(lines.join('\n')).then(() => {
      btn.textContent = 'Copied!';
      setTimeout(() => { btn.textContent = 'Copy table'; }, 1500);
    });
  });
}

// Pre-populate variable list from known column metadata (no analysis needed)
function prePopulateStatsCatVars() {
  const header = currentHeader;
  const colTypes = currentColTypes;
  const origColCount = currentOrigColCount || header.length;
  if (header.length === 0) return;

  // Build combined variable list: numeric + categorical (excluding groupBy)
  const allVarCols = [];
  for (let i = 0; i < header.length; i++) {
    if (i === currentGroupBy) continue;
    if (colTypes[i] === 'numeric' || colTypes[i] === 'categorical') allVarCols.push(i);
  }
  allVarCols.sort((a, b) => a - b);

  // Initialize selected vars if empty
  if (statsCatSelectedVars.size === 0) {
    for (const i of allVarCols) statsCatSelectedVars.add(i);
  }

  // Auto-select first variable for display
  if (currentStatsCatVar === null) {
    currentStatsCatVar = allVarCols.length > 0 ? allVarCols[0] : null;
  }

  // Render variable list
  renderStatsCatVarList(allVarCols, header, origColCount, colTypes);

  // Clear group list (no data yet)
  $statsCatGroupList.innerHTML = '';

  // Show prompt in content
  $statsCatContent.innerHTML = '<div class="statscat-empty">Configure variables and click Analyze to compute grouped statistics.</div>';

  // Wire sidebar events (variable clicks, checkboxes, search, analyze button)
  wireStatsCatSidebarEvents(allVarCols, header, origColCount, colTypes);
}

// StatsCat dropdown handler
$statsCatGroupBy.addEventListener('change', () => {
  const val = $statsCatGroupBy.value;
  currentGroupBy = val ? parseInt(val) : null;
  currentStatsCatVar = null;
  currentStatsCatChecked = null;
  statsCatGroupSortMode = null; // re-inherit from Categories
  statsCatShowSelectedOnly = false;
  $statsCatVarSearch.value = '';
  $statsCatGroupSearch.value = '';
  if (currentGroupBy !== null) {
    prePopulateStatsCatVars();
  } else {
    $statsCatVarList.innerHTML = '';
    $statsCatGroupList.innerHTML = '';
    $statsCatContent.innerHTML = '<div class="statscat-empty">Select a categorical column to see statistics broken down by group.</div>';
  }
  markAnalysisStale();
  autoSaveProject();
});

// Mobile collapsible StatsCat sections (one-time delegation)
if (window.matchMedia('(max-width: 700px)').matches) {
  document.querySelector('.statscat-sidebar').addEventListener('click', (e) => {
    const title = e.target.closest('.statscat-sidebar-section--grow > .statscat-sidebar-title');
    if (!title) return;
    const section = title.closest('.statscat-sidebar-section--grow');
    const wasCollapsed = section.classList.contains('collapsed');
    document.querySelectorAll('.statscat-sidebar-section--grow').forEach(s => s.classList.add('collapsed'));
    if (wasCollapsed) section.classList.remove('collapsed');
  });
}

// ─── Statistics Tab ───────────────────────────────────────────────────

const STATS_PRESETS = {
  quartiles: [25, 50, 75],
  deciles: [10, 20, 30, 40, 50, 60, 70, 80, 90],
  ventiles: [5, 10, 25, 50, 75, 90, 95]
};

const STATS_ALL_METRICS = [
  { key: 'count', label: 'Count' },
  { key: 'nulls', label: 'Nulls' },
  { key: 'zeros', label: 'Zeros' },
  { key: 'min', label: 'Min' },
  // percentile metrics injected dynamically
  { key: 'max', label: 'Max' },
  { key: 'mean', label: 'Mean' },
  { key: 'std', label: 'Std' },
  { key: 'cv', label: 'CV%' },
  { key: 'skew', label: 'Skew' },
  { key: 'kurt', label: 'Kurt' }
];

const STATS_DEFAULT_VISIBLE = new Set(['count', 'min', 'max', 'mean', 'std', 'cv']);

// Module-level state so delegation handlers can access current data
let _statsNumCols = [];
let _statsHeader = [];
let _statsOrigColCount = 0;
let _statsEventsWired = false;
let _statsCdfParams = null; // coordinate system for CDF tooltip

function tdQuantileFromCentroids(centroids, totalCount, q) {
  if (!centroids || centroids.length === 0) return null;
  if (centroids.length === 1) return centroids[0][0];
  if (q <= 0) return centroids[0][0];
  if (q >= 1) return centroids[centroids.length - 1][0];
  var target = q * totalCount;
  var cumCount = 0;
  for (var i = 0; i < centroids.length; i++) {
    var mean = centroids[i][0], count = centroids[i][1];
    var lo = cumCount;
    var mid = lo + count / 2;
    if (target < mid) {
      if (i === 0) return mean;
      var prevMean = centroids[i - 1][0], prevCount = centroids[i - 1][1];
      var prevMid = lo - prevCount / 2;
      var t = (target - prevMid) / (mid - prevMid);
      return prevMean + t * (mean - prevMean);
    }
    cumCount += count;
  }
  return centroids[centroids.length - 1][0];
}

function getStatsMetricColumns() {
  var cols = [];
  for (var m of STATS_ALL_METRICS) {
    if (m.key === 'max') {
      for (var p of statsPercentiles) {
        cols.push({ key: 'p' + p, label: 'P' + p, pct: p });
      }
    }
    cols.push(m);
  }
  return cols;
}

function getStatValue(s, metric) {
  if (metric.pct !== undefined) {
    return tdQuantileFromCentroids(s.centroids, s.count, metric.pct / 100);
  }
  switch (metric.key) {
    case 'count': return s.count;
    case 'nulls': return s.nulls;
    case 'zeros': return s.zeros;
    case 'min': return s.min;
    case 'max': return s.max;
    case 'mean': return s.mean;
    case 'std': return s.std;
    case 'cv': return (s.mean && s.std && s.mean !== 0) ? Math.abs(s.std / s.mean * 100) : null;
    case 'skew': return s.skewness;
    case 'kurt': return s.kurtosis;
    default: return null;
  }
}

function formatStatValue(val, metric) {
  if (val === null || val === undefined) return '\u2014';
  if (metric.key === 'count' || metric.key === 'nulls' || metric.key === 'zeros') {
    return val > 0 ? val.toLocaleString() : '\u2014';
  }
  if (metric.key === 'cv') return val.toFixed(1);
  if (metric.key === 'skew' || metric.key === 'kurt') return val.toFixed(2);
  return formatNum(val);
}

function isMetricVisible(key) {
  if (statsVisibleMetrics === null) {
    if (key.startsWith('p') && key.length > 1 && !isNaN(key.slice(1))) return true;
    return STATS_DEFAULT_VISIBLE.has(key);
  }
  return statsVisibleMetrics.has(key);
}

function renderStatsTab(stats, header, origColCount, isFiltered, rowCount) {
  lastDisplayedStats = stats;
  lastDisplayedHeader = header;
  _statsNumCols = Object.keys(stats).map(Number).sort(function(a, b) { return a - b; });
  _statsHeader = header;
  _statsOrigColCount = origColCount;

  $statsBadge.textContent = _statsNumCols.length + ' columns' + (isFiltered ? ' \u00B7 ' + rowCount.toLocaleString() + ' rows' : '');

  if (_statsNumCols.length === 0) {
    $statsContent.innerHTML = '<div style="color:var(--fg-dim);">No numeric columns detected.</div>';
    $statsSidebar.style.display = 'none';
    return;
  }
  $statsSidebar.style.display = '';

  renderStatsSidebar();
  renderStatsTable();
  renderStatsCdfPanel();

  if (!_statsEventsWired) {
    wireStatsEventsOnce();
    _statsEventsWired = true;
  }
}

function renderStatsSidebar() {
  var numCols = _statsNumCols;
  var header = _statsHeader;
  var origColCount = _statsOrigColCount;

  // Metric toggles
  var metrics = getStatsMetricColumns();
  var togglesHtml = '';
  for (var m of metrics) {
    var checked = isMetricVisible(m.key) ? ' checked' : '';
    togglesHtml += '<label class="stats-metric-toggle"><input type="checkbox" data-metric="' + m.key + '"' + checked + '> ' + esc(m.label) + '</label>';
  }
  document.getElementById('statsMetricToggles').innerHTML = togglesHtml;

  // Preset buttons state
  var presetBtns = document.querySelectorAll('#statsPresetBtns .stats-preset');
  var currentPreset = null;
  for (var key in STATS_PRESETS) {
    var pre = STATS_PRESETS[key];
    if (pre.length === statsPercentiles.length && pre.every(function(v, i) { return v === statsPercentiles[i]; })) {
      currentPreset = key;
    }
  }
  presetBtns.forEach(function(btn) {
    btn.classList.toggle('active', btn.dataset.preset === currentPreset || (currentPreset === null && btn.dataset.preset === 'custom'));
  });
  var customInput = document.getElementById('statsCustomPct');
  if (currentPreset === null || currentPreset === 'custom') {
    customInput.style.display = '';
    customInput.value = statsPercentiles.join(',');
  } else {
    customInput.style.display = 'none';
  }

  // Variable list
  var search = document.getElementById('statsVarSearch').value.toLowerCase();
  var html = '';
  for (var ci of numCols) {
    var name = header[ci];
    if (search && !fuzzyMatch(search, name.toLowerCase())) continue;
    var isCalcol = ci >= origColCount;
    var selected = statsSelectedVars === null || statsSelectedVars.has(ci);
    var checkedAttr = selected ? ' checked' : '';
    var uncheckedCls = !selected ? ' unchecked' : '';
    html += '<div class="stats-var-item' + uncheckedCls + '" data-col="' + ci + '">';
    html += '<input type="checkbox"' + checkedAttr + ' data-col="' + ci + '">';
    html += '<span class="var-name">' + esc(name) + '</span>';
    if (isCalcol) html += '<span class="calcol-tag">CALC</span>';
    html += '</div>';
  }
  document.getElementById('statsVarList').innerHTML = html;
}

function renderStatsTable() {
  var stats = lastDisplayedStats;
  var header = lastDisplayedHeader;
  if (!stats || !header) return;

  var numCols = Object.keys(stats).map(Number).sort(function(a, b) { return a - b; });
  var origColCount = currentOrigColCount || header.length;
  var metrics = getStatsMetricColumns().filter(function(m) { return isMetricVisible(m.key); });

  var visCols = numCols.filter(function(ci) {
    return statsSelectedVars === null || statsSelectedVars.has(ci);
  });

  if (visCols.length === 0) {
    $statsContent.innerHTML = '<div style="color:var(--fg-dim);padding:1rem;">No variables selected.</div>';
    return;
  }

  var html = '<table class="stats"><thead><tr><th>Column</th>';
  for (var m of metrics) html += '<th>' + esc(m.label) + '</th>';
  html += '</tr></thead><tbody>';

  for (var ci of visCols) {
    var s = stats[ci];
    var isCalcol = ci >= origColCount;
    var cdfActive = statsCdfSelected.has(ci);
    var nameClass = cdfActive ? 'cdf-link cdf-active' : 'cdf-link';
    var nameHtml = '<a class="' + nameClass + '" data-col="' + ci + '" href="#">' + esc(header[ci]) + '</a>';
    if (isCalcol) nameHtml += '<span class="calcol-tag">CALC</span>';

    html += '<tr' + (isCalcol ? ' class="calcol-row"' : '') + '><td>' + nameHtml + '</td>';
    for (var m of metrics) {
      var val = getStatValue(s, m);
      html += '<td>' + formatStatValue(val, m) + '</td>';
    }
    html += '</tr>';
  }
  html += '</tbody></table>';
  $statsContent.innerHTML = html;
}

function renderStatsCdfPanel() {
  var chart = document.getElementById('statsCdfChart');
  if (!chart) return;

  if (statsCdfSelected.size === 0) {
    chart.innerHTML = '<div class="stats-cdf-hint">Click column names to add CDF curves</div>';
    return;
  }

  var stats = lastDisplayedStats;
  var header = lastDisplayedHeader;
  if (!stats || !header) return;

  var entries = [];
  statsCdfSelected.forEach(function(ci) {
    if (stats[ci] && stats[ci].centroids && stats[ci].centroids.length > 0) {
      entries.push([header[ci], stats[ci]]);
    }
  });

  if (entries.length === 0) {
    chart.innerHTML = '<div class="stats-cdf-hint">No centroid data for selected columns</div>';
    return;
  }

  chart.innerHTML = renderStatsCdfSvg(entries);
  wireStatsCdfTooltip();

  // Update scale buttons
  document.querySelectorAll('#statsCdfToolbar .stats-scale').forEach(function(btn) {
    btn.classList.toggle('active', btn.dataset.scale === statsCdfScale);
  });
}

function renderStatsCdfSvg(entries) {
  var isLog = statsCdfScale === 'log';
  var W = 700, plotBaseH = 380;
  var pad = { top: 20, right: 30, bottom: 50, left: 60 };
  var plotW = W - pad.left - pad.right;
  var plotH = plotBaseH - pad.top - pad.bottom;

  var legCols = 3;
  var legRowH = 16;
  var legPadTop = 12;
  var legRows = Math.ceil(entries.length / legCols);
  var legendH = legPadTop + legRows * legRowH + 6;
  var H = plotBaseH + legendH;

  var globalMin = Infinity, globalMax = -Infinity;
  for (var ei = 0; ei < entries.length; ei++) {
    var s = entries[ei][1];
    if (s.min < globalMin) globalMin = s.min;
    if (s.max > globalMax) globalMax = s.max;
  }

  var logMin, logMax;
  if (isLog) {
    logMin = Math.log10(Math.max(globalMin, 1e-10));
    logMax = Math.log10(Math.max(globalMax, 1e-9));
    if (logMax <= logMin) logMax = logMin + 1;
  }
  var xRange = isLog ? (logMax - logMin) : (globalMax - globalMin || 1);

  function sx(v) {
    if (isLog) {
      var lv = Math.log10(Math.max(v, 1e-10));
      return pad.left + ((lv - logMin) / xRange) * plotW;
    }
    return pad.left + ((v - globalMin) / xRange) * plotW;
  }
  function sy(v) { return pad.top + (1 - v) * plotH; }

  var yTicks = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0];
  var gridSvg = '';
  for (var yi = 0; yi < yTicks.length; yi++) {
    var yt = yTicks[yi];
    var y = sy(yt);
    gridSvg += '<line x1="' + pad.left + '" y1="' + y + '" x2="' + (W - pad.right) + '" y2="' + y + '" stroke="#1e2228" stroke-width="1"/>';
    gridSvg += '<text x="' + (pad.left - 8) + '" y="' + (y + 3.5) + '" text-anchor="end" fill="#6a737d" font-size="10">' + (yt * 100).toFixed(0) + '%</text>';
  }
  var nxTicks = 6;
  for (var xi = 0; xi <= nxTicks; xi++) {
    var v;
    if (isLog) {
      v = Math.pow(10, logMin + (xRange * xi / nxTicks));
    } else {
      v = globalMin + ((globalMax - globalMin || 1) * xi / nxTicks);
    }
    var x = sx(v);
    gridSvg += '<line x1="' + x + '" y1="' + pad.top + '" x2="' + x + '" y2="' + (plotBaseH - pad.bottom) + '" stroke="#1e2228" stroke-width="1"/>';
    var label = Math.abs(v) >= 1e5 || (Math.abs(v) < 0.01 && v !== 0) ? v.toExponential(1) : v.toFixed(Math.abs(v) < 10 ? 2 : 0);
    gridSvg += '<text x="' + x + '" y="' + (plotBaseH - pad.bottom + 16) + '" text-anchor="middle" fill="#6a737d" font-size="10">' + label + '</text>';
  }

  var curvesSvg = '';
  var meansSvg = '';
  for (var gi = 0; gi < entries.length; gi++) {
    var eName = entries[gi][0], eStats = entries[gi][1];
    var color = STATSCAT_PALETTE[gi % STATSCAT_PALETTE.length];
    var points = [];
    var cumCount = 0;
    for (var ci = 0; ci < eStats.centroids.length; ci++) {
      var cMean = eStats.centroids[ci][0], cCount = eStats.centroids[ci][1];
      if (isLog && cMean <= 0) { cumCount += cCount; continue; }
      cumCount += cCount;
      var px = sx(cMean);
      if (px < pad.left || px > W - pad.right) continue;
      points.push({ x: px, y: sy(cumCount / eStats.count) });
    }
    if (points.length > 0) {
      var pathParts = points.map(function(p, i) { return (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ',' + p.y.toFixed(1); });
      curvesSvg += '<path d="' + pathParts.join(' ') + '" fill="none" stroke="' + color + '" stroke-width="1.5" opacity="0.85"/>';
    }
    if (eStats.mean !== null && (!isLog || eStats.mean > 0)) {
      var mx = sx(eStats.mean);
      if (mx >= pad.left && mx <= W - pad.right) {
        meansSvg += '<line x1="' + mx + '" y1="' + pad.top + '" x2="' + mx + '" y2="' + (plotBaseH - pad.bottom) + '" stroke="' + color + '" stroke-width="1" stroke-dasharray="4,3" opacity="0.5"/>';
      }
    }
  }

  var legTop = plotBaseH + legPadTop;
  var colW = (W - pad.left - pad.right) / legCols;
  var legendSvg = '';
  for (var li = 0; li < entries.length; li++) {
    var lName = entries[li][0];
    var lColor = STATSCAT_PALETTE[li % STATSCAT_PALETTE.length];
    var col = li % legCols;
    var row = Math.floor(li / legCols);
    var lx = pad.left + col * colW;
    var ly = legTop + row * legRowH;
    legendSvg += '<line x1="' + lx + '" y1="' + (ly + 5) + '" x2="' + (lx + 18) + '" y2="' + (ly + 5) + '" stroke="' + lColor + '" stroke-width="2.5"/>';
    legendSvg += '<text x="' + (lx + 24) + '" y="' + (ly + 9) + '" fill="#6a737d" font-size="9.5">' + esc(lName) + '</text>';
  }

  // Store params for tooltip interaction
  _statsCdfParams = {
    entries: entries, isLog: isLog,
    globalMin: globalMin, globalMax: globalMax,
    logMin: isLog ? logMin : 0, logMax: isLog ? logMax : 0,
    xRange: xRange, pad: pad, plotW: plotW, plotH: plotH,
    W: W, plotBaseH: plotBaseH
  };

  // Overlay elements for tooltip interaction
  var overlaySvg = '<line id="statsCdfCrosshair" x1="0" y1="' + pad.top + '" x2="0" y2="' + (plotBaseH - pad.bottom) + '" stroke="var(--amber)" stroke-width="1" stroke-dasharray="3,2" visibility="hidden"/>';
  for (var di = 0; di < entries.length; di++) {
    var dColor = STATSCAT_PALETTE[di % STATSCAT_PALETTE.length];
    overlaySvg += '<circle class="cdf-dot" data-idx="' + di + '" cx="0" cy="0" r="3.5" fill="' + dColor + '" stroke="var(--bg)" stroke-width="1" visibility="hidden"/>';
  }
  overlaySvg += '<rect x="' + pad.left + '" y="' + pad.top + '" width="' + plotW + '" height="' + plotH + '" fill="transparent" id="statsCdfOverlay" style="cursor:crosshair"/>';

  var scaleLabel = isLog ? ' (log)' : '';
  return '<svg viewBox="0 0 ' + W + ' ' + H + '" xmlns="http://www.w3.org/2000/svg" style="font-family:var(--mono)" id="statsCdfSvg">' +
    '<rect width="' + W + '" height="' + H + '" fill="var(--bg)" rx="4"/>' +
    gridSvg + meansSvg + curvesSvg + overlaySvg +
    '<text x="' + (W / 2) + '" y="' + (plotBaseH - 4) + '" text-anchor="middle" fill="#6a737d" font-size="10">CDF' + scaleLabel + '</text>' +
    '<text x="12" y="' + (plotBaseH / 2) + '" text-anchor="middle" fill="#6a737d" font-size="10" transform="rotate(-90, 12, ' + (plotBaseH / 2) + ')">Cumulative %</text>' +
    legendSvg +
    '</svg>';
}

// CDF tooltip: interpolate cumulative % at a given value
function getCdfAtValue(centroids, totalCount, value, isLog) {
  if (!centroids || centroids.length === 0) return null;
  var pts = [];
  var cum = 0;
  for (var i = 0; i < centroids.length; i++) {
    var m = centroids[i][0], c = centroids[i][1];
    if (isLog && m <= 0) { cum += c; continue; }
    cum += c;
    pts.push([m, cum / totalCount]);
  }
  if (pts.length === 0) return null;
  if (value <= pts[0][0]) return 0;
  if (value >= pts[pts.length - 1][0]) return pts[pts.length - 1][1];
  for (var i = 1; i < pts.length; i++) {
    if (value <= pts[i][0]) {
      var t = (value - pts[i - 1][0]) / (pts[i][0] - pts[i - 1][0]);
      return pts[i - 1][1] + t * (pts[i][1] - pts[i - 1][1]);
    }
  }
  return pts[pts.length - 1][1];
}

function wireStatsCdfTooltip() {
  var svg = document.getElementById('statsCdfSvg');
  var overlay = document.getElementById('statsCdfOverlay');
  if (!svg || !overlay || !_statsCdfParams) return;

  var p = _statsCdfParams;
  var crosshair = document.getElementById('statsCdfCrosshair');
  var dots = svg.querySelectorAll('.cdf-dot');
  var chart = document.getElementById('statsCdfChart');

  // Create or reuse tooltip div
  var tip = chart.querySelector('.stats-cdf-tooltip');
  if (!tip) {
    tip = document.createElement('div');
    tip.className = 'stats-cdf-tooltip';
    chart.appendChild(tip);
  }
  tip.style.display = 'none';

  function svgXFromMouse(e) {
    var pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse()).x;
  }

  function valueFromSvgX(svgX) {
    var frac = (svgX - p.pad.left) / p.plotW;
    if (p.isLog) return Math.pow(10, p.logMin + frac * p.xRange);
    return p.globalMin + frac * (p.globalMax - p.globalMin || 1);
  }

  function syFromCdf(cdf) {
    return p.pad.top + (1 - cdf) * p.plotH;
  }

  overlay.addEventListener('mousemove', function(e) {
    var svgX = svgXFromMouse(e);
    var value = valueFromSvgX(svgX);

    // Position crosshair
    crosshair.setAttribute('x1', svgX);
    crosshair.setAttribute('x2', svgX);
    crosshair.setAttribute('visibility', 'visible');

    // Build tooltip content and position dots
    var label = Math.abs(value) >= 1e5 || (Math.abs(value) < 0.01 && value !== 0)
      ? value.toExponential(2) : formatNum(value);
    var lines = '<div style="color:var(--fg-dim);margin-bottom:3px">' + esc(String(label)) + '</div>';

    for (var i = 0; i < p.entries.length; i++) {
      var eName = p.entries[i][0], eStats = p.entries[i][1];
      var color = STATSCAT_PALETTE[i % STATSCAT_PALETTE.length];
      var cdf = getCdfAtValue(eStats.centroids, eStats.count, value, p.isLog);
      if (cdf !== null) {
        var dotY = syFromCdf(cdf);
        dots[i].setAttribute('cx', svgX);
        dots[i].setAttribute('cy', dotY);
        dots[i].setAttribute('visibility', 'visible');
        lines += '<div><span style="color:' + color + '">\u25CF</span> ' + esc(eName) + ': ' + (cdf * 100).toFixed(1) + '%</div>';
      } else {
        dots[i].setAttribute('visibility', 'hidden');
      }
    }
    tip.innerHTML = lines;
    tip.style.display = '';

    // Position tooltip relative to chart container
    var chartRect = chart.getBoundingClientRect();
    var svgRect = svg.getBoundingClientRect();
    var mouseXInChart = e.clientX - chartRect.left;
    var mouseYInChart = e.clientY - chartRect.top;
    var tipW = tip.offsetWidth;
    // Flip to left side if near right edge
    var xOff = mouseXInChart + 16 + tipW > chartRect.width ? -tipW - 12 : 16;
    tip.style.left = (mouseXInChart + xOff) + 'px';
    tip.style.top = (mouseYInChart - 20) + 'px';
  });

  overlay.addEventListener('mouseleave', function() {
    crosshair.setAttribute('visibility', 'hidden');
    for (var i = 0; i < dots.length; i++) dots[i].setAttribute('visibility', 'hidden');
    tip.style.display = 'none';
  });
}

// Wire all events ONCE using delegation — survives innerHTML rebuilds
function wireStatsEventsOnce() {
  // --- Preset buttons (static template elements) ---
  document.getElementById('statsPresetBtns').addEventListener('click', function(e) {
    var btn = e.target.closest('.stats-preset');
    if (!btn) return;
    var preset = btn.dataset.preset;
    if (preset === 'custom') {
      var customInput = document.getElementById('statsCustomPct');
      customInput.style.display = '';
      document.querySelectorAll('#statsPresetBtns .stats-preset').forEach(function(b) { b.classList.remove('active'); });
      btn.classList.add('active');
      customInput.focus();
    } else if (STATS_PRESETS[preset]) {
      statsPercentiles = STATS_PRESETS[preset].slice();
      renderStatsSidebar();
      renderStatsTable();
      autoSaveProject();
    }
  });

  // --- Custom percentile input (static template element) ---
  document.getElementById('statsCustomPct').addEventListener('change', function() {
    var input = document.getElementById('statsCustomPct');
    var parts = input.value.split(',').map(function(s) { return parseInt(s.trim()); }).filter(function(n) { return !isNaN(n) && n >= 1 && n <= 99; });
    if (parts.length > 0) {
      parts.sort(function(a, b) { return a - b; });
      statsPercentiles = parts.filter(function(v, i, arr) { return i === 0 || v !== arr[i - 1]; });
      renderStatsSidebar();
      renderStatsTable();
      autoSaveProject();
    }
  });

  // --- Metric toggles (delegation on container — innerHTML changes) ---
  document.getElementById('statsMetricToggles').addEventListener('change', function(e) {
    var cb = e.target.closest('input[data-metric]');
    if (!cb) return;
    if (statsVisibleMetrics === null) {
      statsVisibleMetrics = new Set();
      var allMetrics = getStatsMetricColumns();
      for (var m of allMetrics) {
        if (isMetricVisible(m.key)) statsVisibleMetrics.add(m.key);
      }
    }
    if (cb.checked) statsVisibleMetrics.add(cb.dataset.metric);
    else statsVisibleMetrics.delete(cb.dataset.metric);
    renderStatsTable();
    autoSaveProject();
  });

  // --- Variable checkboxes (delegation on container — innerHTML changes) ---
  document.getElementById('statsVarList').addEventListener('change', function(e) {
    var cb = e.target.closest('input[data-col]');
    if (!cb) return;
    var colIdx = parseInt(cb.dataset.col);
    if (statsSelectedVars === null) {
      statsSelectedVars = new Set(_statsNumCols);
    }
    if (cb.checked) statsSelectedVars.add(colIdx);
    else statsSelectedVars.delete(colIdx);
    var item = cb.closest('.stats-var-item');
    if (item) item.classList.toggle('unchecked', !cb.checked);
    renderStatsTable();
    autoSaveProject();
  });

  // --- All/None buttons (static template elements) ---
  document.getElementById('statsVarAll').addEventListener('click', function() {
    if (statsSelectedVars === null) statsSelectedVars = new Set(_statsNumCols);
    document.getElementById('statsVarList').querySelectorAll('.stats-var-item').forEach(function(el) {
      statsSelectedVars.add(parseInt(el.dataset.col));
    });
    renderStatsSidebar();
    renderStatsTable();
    autoSaveProject();
  });
  document.getElementById('statsVarNone').addEventListener('click', function() {
    if (statsSelectedVars === null) statsSelectedVars = new Set(_statsNumCols);
    document.getElementById('statsVarList').querySelectorAll('.stats-var-item').forEach(function(el) {
      statsSelectedVars.delete(parseInt(el.dataset.col));
    });
    renderStatsSidebar();
    renderStatsTable();
    autoSaveProject();
  });

  // --- Variable search (static template element) ---
  document.getElementById('statsVarSearch').addEventListener('input', function() {
    renderStatsSidebar();
  });

  // --- CDF links in table (delegation on container — innerHTML changes) ---
  $statsContent.addEventListener('click', function(e) {
    var link = e.target.closest('.cdf-link');
    if (!link) return;
    e.preventDefault();
    var col = parseInt(link.dataset.col);
    if (statsCdfSelected.has(col)) statsCdfSelected.delete(col);
    else statsCdfSelected.add(col);
    renderStatsTable();
    renderStatsCdfPanel();
    autoSaveProject();
  });

  // --- CDF scale buttons (static template elements) ---
  document.getElementById('statsCdfToolbar').addEventListener('click', function(e) {
    var btn = e.target.closest('.stats-scale');
    if (!btn) return;
    statsCdfScale = btn.dataset.scale;
    renderStatsCdfPanel();
    autoSaveProject();
  });

  // --- Copy table (static template element) ---
  document.getElementById('statsCopyBtn').addEventListener('click', copyStatsTable);

  // --- Download SVG/PNG (static template elements) ---
  document.getElementById('statsDownloadSvg').addEventListener('click', downloadStatsSvg);
  document.getElementById('statsDownloadPng').addEventListener('click', downloadStatsPng);

  // --- Mobile collapsible sidebar ---
  if (window.matchMedia('(max-width: 700px)').matches) {
    $statsSidebar.addEventListener('click', function(e) {
      var title = e.target.closest('.stats-sidebar-section--grow > .stats-sidebar-title');
      if (!title) return;
      var section = title.closest('.stats-sidebar-section--grow');
      var wasCollapsed = section.classList.contains('collapsed');
      $statsSidebar.querySelectorAll('.stats-sidebar-section--grow').forEach(function(s) { s.classList.add('collapsed'); });
      if (wasCollapsed) section.classList.remove('collapsed');
    });
  }
}

function copyStatsTable() {
  var table = $statsContent.querySelector('table.stats');
  if (!table) return;
  var rows = table.querySelectorAll('tr');
  var lines = [];
  rows.forEach(function(row) {
    var cells = row.querySelectorAll('th, td');
    var vals = [];
    cells.forEach(function(c) { vals.push(c.textContent); });
    lines.push(vals.join('\t'));
  });
  navigator.clipboard.writeText(lines.join('\n')).then(function() {
    var btn = document.getElementById('statsCopyBtn');
    btn.textContent = 'Copied!';
    setTimeout(function() { btn.textContent = 'Copy table'; }, 1500);
  });
}

function cleanSvgForExport(svgEl) {
  var clone = svgEl.cloneNode(true);
  // Remove interactive tooltip elements
  var overlay = clone.querySelector('#statsCdfOverlay');
  var crosshair = clone.querySelector('#statsCdfCrosshair');
  if (overlay) overlay.remove();
  if (crosshair) crosshair.remove();
  clone.querySelectorAll('.cdf-dot').forEach(function(d) { d.remove(); });
  var svgData = new XMLSerializer().serializeToString(clone);
  svgData = svgData.replace(/fill="var\(--bg\)"/g, 'fill="white"');
  svgData = svgData.replace(/fill="#6a737d"/g, 'fill="#333"');
  svgData = svgData.replace(/stroke="#1e2228"/g, 'stroke="#ddd"');
  svgData = svgData.replace(/style="font-family:var\(--mono\)"/g, 'style="font-family:monospace"');
  return svgData;
}

function downloadStatsSvg() {
  var svgEl = document.getElementById('statsCdfSvg');
  if (!svgEl) return;
  var svgData = cleanSvgForExport(svgEl);
  var blob = new Blob([svgData], { type: 'image/svg+xml' });
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'statistics_cdf.svg';
  a.click();
  URL.revokeObjectURL(a.href);
}

function downloadStatsPng() {
  var svgEl = document.getElementById('statsCdfSvg');
  if (!svgEl) return;
  var svgData = cleanSvgForExport(svgEl);
  var canvas = document.createElement('canvas');
  var scale = 2;
  var vb = svgEl.getAttribute('viewBox').split(' ').map(Number);
  canvas.width = vb[2] * scale;
  canvas.height = vb[3] * scale;
  var ctx = canvas.getContext('2d');
  var img = new Image();
  img.onload = function() {
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    canvas.toBlob(function(blob) {
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'statistics_cdf.png';
      a.click();
      URL.revokeObjectURL(url);
    }, 'image/png');
  };
  img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
}

// ─── Export Tab ────────────────────────────────────────────────────────

function initExportColumns() {
  exportColumns = [];
  for (let i = 0; i < currentHeader.length; i++) {
    const isCalcol = i >= currentOrigColCount;
    exportColumns.push({
      name: currentHeader[i],
      outputName: currentHeader[i],
      type: currentColTypes[i] || 'numeric',
      selected: true,
      isCalcol
    });
  }
  detectSourcePrecision();
  renderExportColumns();
  updateExportRowPreview();
  updateExportPreview();
}

function detectSourcePrecision() {
  exportSourcePrecision = {};
  if (!preflightData || !preflightData.sampleRows || !preflightData.header) return;
  const hdr = preflightData.header;
  for (let ci = 0; ci < hdr.length; ci++) {
    let maxDp = 0;
    for (let ri = 0; ri < preflightData.sampleRows.length; ri++) {
      const raw = (preflightData.sampleRows[ri][ci] || '').trim();
      const dot = raw.indexOf('.');
      if (dot >= 0) {
        const dp = raw.length - dot - 1;
        if (dp > maxDp) maxDp = dp;
      }
    }
    if (maxDp > 0) exportSourcePrecision[hdr[ci]] = maxDp;
  }
}

function renderExportColumns() {
  const search = $exportColSearch.value.toLowerCase();
  let html = '';
  for (let i = 0; i < exportColumns.length; i++) {
    const col = exportColumns[i];
    const checked = col.selected ? ' checked' : '';
    const typeClass = col.isCalcol ? 'calcol' : (col.type === 'numeric' ? 'num' : 'cat');
    const typeLabel = col.isCalcol ? 'calc' : (col.type === 'numeric' ? 'num' : 'cat');
    const hidden = search && !fuzzyMatch(search, col.name.toLowerCase()) && !fuzzyMatch(search, col.outputName.toLowerCase());
    html += '<div class="export-col-item' + (hidden ? ' export-col-hidden' : '') + '" data-idx="' + i + '" draggable="true">';
    html += '<span class="ecol-grip" title="Drag to reorder"></span>';
    html += '<input type="checkbox"' + checked + '>';
    html += '<span class="ecol-name" title="' + esc(col.name) + '">' + esc(col.name) + '</span>';
    html += '<input type="text" class="ecol-rename" value="' + esc(col.outputName) + '" placeholder="output name">';
    html += '<span class="ecol-type ' + typeClass + '">' + typeLabel + '</span>';
    html += '</div>';
  }
  $exportColList.innerHTML = html;
  updateExportBadge();
  wireExportColumnEvents();
}

function updateExportBadge() {
  const sel = exportColumns.filter(c => c.selected).length;
  $exportBadge.textContent = sel + ' / ' + exportColumns.length;
}

function updateExportRowPreview() {
  if (!lastCompleteData) { $exportRowPreview.textContent = ''; return; }
  const rc = lastCompleteData.rowCount;
  const trc = lastCompleteData.totalRowCount;
  if (currentFilter) {
    $exportRowPreview.textContent = rc.toLocaleString() + ' / ' + trc.toLocaleString() + ' rows';
  } else {
    $exportRowPreview.textContent = trc.toLocaleString() + ' rows';
  }
}

let exportDragIdx = null;

function wireExportColumnEvents() {
  $exportColList.querySelectorAll('.export-col-item').forEach(el => {
    const idx = parseInt(el.dataset.idx);
    const cb = el.querySelector('input[type="checkbox"]');
    cb.addEventListener('change', () => {
      exportColumns[idx].selected = cb.checked;
      updateExportBadge();
      updateExportPreview();
      autoSaveProject();
    });
    const renameInput = el.querySelector('.ecol-rename');
    renameInput.addEventListener('input', () => {
      exportColumns[idx].outputName = renameInput.value || exportColumns[idx].name;
      updateExportPreview();
      autoSaveProject();
    });

    el.addEventListener('dragstart', (e) => {
      exportDragIdx = idx;
      el.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });
    el.addEventListener('dragend', () => {
      el.classList.remove('dragging');
      $exportColList.querySelectorAll('.drag-over-top,.drag-over-bottom').forEach(x => {
        x.classList.remove('drag-over-top', 'drag-over-bottom');
      });
      exportDragIdx = null;
    });
    el.addEventListener('dragover', (e) => {
      if (exportDragIdx === null || exportDragIdx === idx) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const rect = el.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      el.classList.toggle('drag-over-top', e.clientY < midY);
      el.classList.toggle('drag-over-bottom', e.clientY >= midY);
    });
    el.addEventListener('dragleave', () => {
      el.classList.remove('drag-over-top', 'drag-over-bottom');
    });
    el.addEventListener('drop', (e) => {
      e.preventDefault();
      if (exportDragIdx === null || exportDragIdx === idx) return;
      const rect = el.getBoundingClientRect();
      const dropAfter = e.clientY >= rect.top + rect.height / 2;
      const item = exportColumns.splice(exportDragIdx, 1)[0];
      let targetIdx = dropAfter ? idx : idx;
      if (exportDragIdx < idx) targetIdx--;
      const insertAt = dropAfter ? targetIdx + 1 : targetIdx;
      exportColumns.splice(insertAt, 0, item);
      exportDragIdx = null;
      renderExportColumns();
      updateExportPreview();
      autoSaveProject();
    });
  });
}

// Column search
$exportColSearch.addEventListener('input', () => {
  const search = $exportColSearch.value.toLowerCase();
  $exportColList.querySelectorAll('.export-col-item').forEach(el => {
    const idx = parseInt(el.dataset.idx);
    const col = exportColumns[idx];
    const hidden = search && !fuzzyMatch(search, col.name.toLowerCase()) && !fuzzyMatch(search, col.outputName.toLowerCase());
    el.classList.toggle('export-col-hidden', hidden);
  });
});

// Selection buttons
document.getElementById('exportSelAll').addEventListener('click', () => {
  exportColumns.forEach(c => c.selected = true);
  renderExportColumns();
  updateExportPreview();
  autoSaveProject();
});
document.getElementById('exportSelNone').addEventListener('click', () => {
  exportColumns.forEach(c => c.selected = false);
  renderExportColumns();
  updateExportPreview();
  autoSaveProject();
});
document.getElementById('exportSelOrig').addEventListener('click', () => {
  exportColumns.forEach(c => c.selected = !c.isCalcol);
  renderExportColumns();
  updateExportPreview();
  autoSaveProject();
});
document.getElementById('exportSelCalc').addEventListener('click', () => {
  exportColumns.forEach(c => c.selected = c.isCalcol);
  renderExportColumns();
  updateExportPreview();
  autoSaveProject();
});

// ─── Format controls ──────────────────────────────────────────────────

// Delimiter presets
$exportFormatSection.addEventListener('click', (e) => {
  const delimBtn = e.target.closest('.export-delim');
  if (delimBtn) {
    $exportFormatSection.querySelectorAll('.export-delim').forEach(b => b.classList.remove('active'));
    delimBtn.classList.add('active');
    exportDelimiter = delimBtn.dataset.delim === 'tab' ? '\t' : delimBtn.dataset.delim;
    $exportCustomDelim.value = '';
    updateExportWarnings();
    updateExportPreview();
    autoSaveProject();
    return;
  }
  const quoteBtn = e.target.closest('.export-quote');
  if (quoteBtn) {
    $exportFormatSection.querySelectorAll('.export-quote').forEach(b => b.classList.remove('active'));
    quoteBtn.classList.add('active');
    exportQuoteChar = quoteBtn.dataset.quote;
    updateExportPreview();
    autoSaveProject();
    return;
  }
  const endingBtn = e.target.closest('.export-ending');
  if (endingBtn) {
    $exportFormatSection.querySelectorAll('.export-ending').forEach(b => b.classList.remove('active'));
    endingBtn.classList.add('active');
    exportLineEnding = endingBtn.dataset.ending === 'crlf' ? '\r\n' : '\n';
    autoSaveProject();
    return;
  }
  const decsepBtn = e.target.closest('.export-decsep');
  if (decsepBtn) {
    $exportFormatSection.querySelectorAll('.export-decsep').forEach(b => b.classList.remove('active'));
    decsepBtn.classList.add('active');
    exportDecimalSep = decsepBtn.dataset.sep;
    updateExportWarnings();
    updateExportPreview();
    autoSaveProject();
    return;
  }
});

// Custom delimiter input
$exportCustomDelim.addEventListener('input', () => {
  const v = $exportCustomDelim.value;
  if (v) {
    $exportFormatSection.querySelectorAll('.export-delim').forEach(b => b.classList.remove('active'));
    exportDelimiter = v;
    updateExportWarnings();
    updateExportPreview();
    autoSaveProject();
  }
});

// Header row toggle
$exportIncludeHeader.addEventListener('change', () => {
  exportIncludeHeader = $exportIncludeHeader.checked;
  updateExportPreview();
  autoSaveProject();
});

// Comment header toggle
$exportCommentHeader.addEventListener('change', () => {
  exportCommentHeader = $exportCommentHeader.checked;
  $exportCommentSection.style.display = exportCommentHeader ? '' : 'none';
  if (exportCommentHeader && !exportCommentText && preflightData && preflightData.commentLines && preflightData.commentLines.length > 0) {
    exportCommentText = preflightData.commentLines.join('\n');
    $exportCommentText.value = exportCommentText;
  }
  updateExportPreview();
  autoSaveProject();
});

// Comment text changes
$exportCommentText.addEventListener('input', () => {
  exportCommentText = $exportCommentText.value;
  updateExportPreview();
  autoSaveProject();
});

// Generate from geometry
$exportCommentGenerate.addEventListener('click', () => {
  if (!lastGeoData) {
    $exportCommentText.value = '(No geometry detected)';
    exportCommentText = $exportCommentText.value;
    return;
  }
  const gx = lastGeoData.x, gy = lastGeoData.y, gz = lastGeoData.z;
  if (!gx || !gy || !gz) {
    $exportCommentText.value = '(Incomplete geometry)';
    exportCommentText = $exportCommentText.value;
    return;
  }
  const total = gx.gridCount * gy.gridCount * gz.gridCount;
  const lines = [
    currentFile.name,
    '  exported from BMA',
    '  encoding: UTF-8',
    '  block size: ' + gx.blockSize + ' ' + gy.blockSize + ' ' + gz.blockSize,
    '  size in blocks: ' + gx.gridCount + ' ' + gy.gridCount + ' ' + gz.gridCount + ' = ' + total,
    '  minimum centroid: ' + gx.origin + ' ' + gy.origin + ' ' + gz.origin,
    '  maximum centroid: ' + gx.max + ' ' + gy.max + ' ' + gz.max
  ];
  exportCommentText = lines.join('\n');
  $exportCommentText.value = exportCommentText;
  updateExportPreview();
  autoSaveProject();
});

// Null select
$exportNullSelect.addEventListener('change', () => {
  if ($exportNullSelect.value === 'custom') {
    $exportNullInput.style.display = '';
    $exportNullInput.focus();
  } else {
    $exportNullInput.style.display = 'none';
    exportNullValue = $exportNullSelect.value;
    updateExportPreview();
    autoSaveProject();
  }
});
$exportNullInput.addEventListener('input', () => {
  exportNullValue = $exportNullInput.value;
  updateExportPreview();
  autoSaveProject();
});

// Precision select
$exportPrecisionSelect.addEventListener('change', () => {
  if ($exportPrecisionSelect.value === 'custom') {
    $exportPrecisionInput.style.display = '';
    $exportPrecisionInput.focus();
  } else if ($exportPrecisionSelect.value === 'auto') {
    $exportPrecisionInput.style.display = 'none';
    exportPrecision = null;
    updateExportWarnings();
    updateExportPreview();
    autoSaveProject();
  } else {
    $exportPrecisionInput.style.display = 'none';
    exportPrecision = parseInt($exportPrecisionSelect.value);
    updateExportWarnings();
    updateExportPreview();
    autoSaveProject();
  }
});
$exportPrecisionInput.addEventListener('input', () => {
  const v = parseInt($exportPrecisionInput.value);
  exportPrecision = (isNaN(v) || v < 0) ? null : Math.min(v, 20);
  updateExportWarnings();
  updateExportPreview();
  autoSaveProject();
});

// ─── Warnings ─────────────────────────────────────────────────────────

function updateExportWarnings() {
  const warnings = [];

  // Delimiter-decsep conflict
  if (exportDelimiter === exportDecimalSep) {
    warnings.push('Delimiter matches decimal separator \u2014 numeric values will be quoted');
  }

  // Precision warning
  if (exportPrecision !== null) {
    const affected = [];
    for (const col of exportColumns) {
      if (!col.selected || col.type !== 'numeric') continue;
      const srcDp = exportSourcePrecision[col.name];
      if (srcDp !== undefined && srcDp > exportPrecision) {
        affected.push(col.outputName || col.name);
      }
    }
    if (affected.length > 0) {
      const names = affected.length > 5 ? affected.slice(0, 5).join(', ') + ' +' + (affected.length - 5) + ' more' : affected.join(', ');
      warnings.push('Columns ' + names + ' have up to ' + Math.max(...affected.map(n => {
        const col = exportColumns.find(c => (c.outputName || c.name) === n);
        return col ? (exportSourcePrecision[col.name] || 0) : 0;
      })) + ' dp \u2014 output will use ' + exportPrecision + ' dp');
    }
  }

  if (warnings.length > 0) {
    $exportPrecisionWarn.style.display = '';
    $exportPrecisionWarn.textContent = warnings.join(' | ');
  } else {
    $exportPrecisionWarn.style.display = 'none';
    $exportPrecisionWarn.textContent = '';
  }
}

// ─── Live Preview ─────────────────────────────────────────────────────

function updateExportPreview() {
  if (!preflightData || !preflightData.sampleRows || !preflightData.header) {
    $exportPreviewPre.textContent = '';
    $exportPreviewInfo.textContent = '';
    return;
  }

  const selected = exportColumns.filter(c => c.selected);
  if (selected.length === 0) {
    $exportPreviewPre.textContent = '(No columns selected)';
    $exportPreviewInfo.textContent = '';
    return;
  }

  const hdr = preflightData.header;
  const rows = preflightData.sampleRows;
  const maxRows = Math.min(rows.length, 100);
  const delim = exportDelimiter;
  const qc = exportQuoteChar;
  const le = exportLineEnding;

  // Build column index map: selected col name -> index in preflight header
  const colMap = [];
  for (const col of selected) {
    const idx = hdr.indexOf(col.name);
    colMap.push({ idx, col });
  }

  function previewEscape(v, isNum) {
    if (v === null || v === undefined || v === '' || v === 'NaN' || v === 'NA' || v === 'na' || v === 'nan' || v === 'null' || v === 'NULL') {
      return exportNullValue;
    }
    let s = String(v);
    // Apply precision to numbers
    if (isNum && exportPrecision !== null) {
      const n = Number(v);
      if (isFinite(n)) {
        s = n.toFixed(exportPrecision);
      }
    }
    // Apply decimal separator
    if (isNum && exportDecimalSep !== '.') {
      s = s.replace('.', exportDecimalSep);
    }
    // Quoting
    if (qc && (s.indexOf(delim) >= 0 || s.indexOf(qc) >= 0 || s.indexOf('\n') >= 0 || s.indexOf('\r') >= 0)) {
      return qc + s.replace(new RegExp(qc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), qc + qc) + qc;
    }
    return s;
  }

  const lines = [];

  // Comment lines
  if (exportCommentHeader && exportCommentText.trim()) {
    const commentLines = exportCommentText.split('\n');
    for (const cl of commentLines) {
      lines.push('# ' + cl);
    }
  }

  // Header row
  if (exportIncludeHeader) {
    lines.push(selected.map(c => previewEscape(c.outputName, false)).join(delim));
  }

  // Data rows
  for (let ri = 0; ri < maxRows; ri++) {
    const row = rows[ri];
    const cells = [];
    for (const cm of colMap) {
      if (cm.idx < 0) {
        cells.push(exportNullValue); // calcol column — not in preflight
      } else {
        const raw = row[cm.idx] || '';
        const isNum = cm.col.type === 'numeric';
        cells.push(previewEscape(raw, isNum));
      }
    }
    lines.push(cells.join(delim));
  }

  $exportPreviewPre.textContent = lines.join(le);

  // Info text
  const totalRows = lastCompleteData ? (currentFilter ? lastCompleteData.rowCount : lastCompleteData.totalRowCount) : rows.length;
  if (totalRows > maxRows) {
    $exportPreviewInfo.textContent = 'Showing ' + maxRows + ' of ' + totalRows.toLocaleString() + ' rows';
  } else {
    $exportPreviewInfo.textContent = maxRows + ' rows';
  }
}

// ─── Export ───────────────────────────────────────────────────────────

function startExport() {
  const selected = exportColumns.filter(c => c.selected);
  if (selected.length === 0) {
    $exportInfo.textContent = 'No columns selected.';
    return;
  }

  const exportCols = selected.map(c => ({ name: c.name, outputName: c.outputName }));
  const baseName = currentFile.name.replace(/\.[^.]+$/, '');
  const ext = exportDelimiter === '\t' ? '.tsv' : '.csv';
  const suggestedName = baseName + '_export' + ext;

  const resolvedTypes = currentColTypes.slice(0, currentOrigColCount);

  const filterPayload = currentFilter ? { expression: currentFilter.expression } : null;
  const zipEntry = preflightData ? (preflightData.selectedZipEntry || null) : null;

  let commentLines = null;
  if (exportCommentHeader && exportCommentText.trim()) {
    commentLines = exportCommentText.split('\n');
  }

  const msg = {
    mode: 'export',
    file: currentFile,
    filter: filterPayload,
    zipEntry,
    calcolCode: currentCalcolCode || null,
    calcolMeta: currentCalcolMeta.length > 0 ? currentCalcolMeta : null,
    resolvedTypes,
    exportCols,
    delimiter: exportDelimiter,
    includeHeader: exportIncludeHeader,
    commentLines,
    quoteChar: exportQuoteChar,
    lineEnding: exportLineEnding,
    nullValue: exportNullValue,
    precision: exportPrecision,
    decimalSep: exportDecimalSep
  };

  $exportDownload.disabled = true;
  $exportProgress.classList.add('active');
  $exportProgressFill.style.width = '0%';
  $exportProgressLabel.textContent = 'Exporting...';
  $exportInfo.textContent = '';

  if (exportWorker) exportWorker.terminate();

  if (window.showSaveFilePicker) {
    window.showSaveFilePicker({
      suggestedName,
      types: [{ description: 'CSV', accept: { 'text/csv': ['.csv', '.tsv'] } }]
    }).then(async (handle) => {
      const writable = await handle.createWritable();
      exportWorker = new Worker(workerUrl);
      exportWorker.onerror = async (e) => {
        await writable.abort();
        $exportInfo.textContent = 'Worker error: ' + (e.message || 'unknown error');
        $exportProgress.classList.remove('active');
        $exportDownload.disabled = false;
        exportWorker.terminate();
        exportWorker = null;
      };
      exportWorker.onmessage = async (e) => {
        const m = e.data;
        if (m.type === 'export-chunk') {
          await writable.write(m.csv);
        } else if (m.type === 'export-progress') {
          const pct = Math.min(99, m.percent);
          $exportProgressFill.style.width = pct.toFixed(1) + '%';
          $exportProgressLabel.textContent = 'Exporting... ' + pct.toFixed(0) + '% (' + m.rowCount.toLocaleString() + ' rows)';
        } else if (m.type === 'export-complete') {
          await writable.close();
          $exportProgressFill.style.width = '100%';
          $exportProgressLabel.textContent = 'Done \u2014 ' + m.rowCount.toLocaleString() + ' rows in ' + (m.elapsed / 1000).toFixed(1) + 's';
          $exportDownload.disabled = false;
          exportWorker.terminate();
          exportWorker = null;
        } else if (m.type === 'error') {
          await writable.abort();
          $exportInfo.textContent = 'Error: ' + m.message;
          $exportProgress.classList.remove('active');
          $exportDownload.disabled = false;
          exportWorker.terminate();
          exportWorker = null;
        }
      };
      exportWorker.postMessage(msg);
    }).catch((err) => {
      $exportProgress.classList.remove('active');
      $exportDownload.disabled = false;
    });
  } else {
    const chunks = [];
    exportWorker = new Worker(workerUrl);
    exportWorker.onerror = (e) => {
      $exportInfo.textContent = 'Worker error: ' + (e.message || 'unknown error');
      $exportProgress.classList.remove('active');
      $exportDownload.disabled = false;
      exportWorker.terminate();
      exportWorker = null;
    };
    exportWorker.onmessage = (e) => {
      const m = e.data;
      if (m.type === 'export-chunk') {
        chunks.push(m.csv);
      } else if (m.type === 'export-progress') {
        const pct = Math.min(99, m.percent);
        $exportProgressFill.style.width = pct.toFixed(1) + '%';
        $exportProgressLabel.textContent = 'Exporting... ' + pct.toFixed(0) + '% (' + m.rowCount.toLocaleString() + ' rows)';
      } else if (m.type === 'export-complete') {
        const blob = new Blob(chunks, { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = suggestedName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        $exportProgressFill.style.width = '100%';
        $exportProgressLabel.textContent = 'Done \u2014 ' + m.rowCount.toLocaleString() + ' rows in ' + (m.elapsed / 1000).toFixed(1) + 's';
        $exportDownload.disabled = false;
        exportWorker.terminate();
        exportWorker = null;
      } else if (m.type === 'error') {
        $exportInfo.textContent = 'Error: ' + m.message;
        $exportProgress.classList.remove('active');
        $exportDownload.disabled = false;
        exportWorker.terminate();
        exportWorker = null;
      }
    };
    exportWorker.postMessage(msg);
  }
}

$exportDownload.addEventListener('click', startExport);

function resetExportSettings() {
  exportDelimiter = ',';
  exportIncludeHeader = true;
  exportCommentHeader = false;
  exportCommentText = '';
  exportQuoteChar = '"';
  exportLineEnding = '\n';
  exportNullValue = '';
  exportPrecision = null;
  exportDecimalSep = '.';
  $exportIncludeHeader.checked = true;
  $exportCommentHeader.checked = false;
  $exportCommentText.value = '';
  $exportCommentSection.style.display = 'none';
  $exportColSearch.value = '';
  $exportRowPreview.textContent = '';
  $exportCustomDelim.value = '';
  $exportFormatSection.querySelectorAll('.export-delim').forEach(b => {
    b.classList.toggle('active', b.dataset.delim === ',');
  });
  $exportFormatSection.querySelectorAll('.export-quote').forEach(b => {
    b.classList.toggle('active', b.dataset.quote === '"');
  });
  $exportFormatSection.querySelectorAll('.export-ending').forEach(b => {
    b.classList.toggle('active', b.dataset.ending === 'lf');
  });
  $exportFormatSection.querySelectorAll('.export-decsep').forEach(b => {
    b.classList.toggle('active', b.dataset.sep === '.');
  });
  $exportNullSelect.value = '';
  $exportNullInput.style.display = 'none';
  $exportNullInput.value = '';
  $exportPrecisionSelect.value = 'auto';
  $exportPrecisionInput.style.display = 'none';
  $exportPrecisionInput.value = '';
  $exportPrecisionWarn.style.display = 'none';
  $exportPrecisionWarn.textContent = '';
  updateExportPreview();
}

function restoreExportSettings(es) {
  if (!es) return;
  if (es.delimiter !== undefined) {
    exportDelimiter = es.delimiter;
    const delimVal = exportDelimiter === '\t' ? 'tab' : exportDelimiter;
    // Check if it matches a preset
    let matchedPreset = false;
    $exportFormatSection.querySelectorAll('.export-delim').forEach(b => {
      const isMatch = b.dataset.delim === delimVal;
      b.classList.toggle('active', isMatch);
      if (isMatch) matchedPreset = true;
    });
    if (!matchedPreset) {
      $exportCustomDelim.value = exportDelimiter;
    }
  }
  if (es.includeHeader !== undefined) {
    exportIncludeHeader = es.includeHeader;
    $exportIncludeHeader.checked = exportIncludeHeader;
  }
  if (es.commentHeader !== undefined) {
    exportCommentHeader = es.commentHeader;
    $exportCommentHeader.checked = exportCommentHeader;
    $exportCommentSection.style.display = exportCommentHeader ? '' : 'none';
  }
  if (es.commentText !== undefined) {
    exportCommentText = es.commentText;
    $exportCommentText.value = exportCommentText;
  }
  if (es.quoteChar !== undefined) {
    exportQuoteChar = es.quoteChar;
    $exportFormatSection.querySelectorAll('.export-quote').forEach(b => {
      b.classList.toggle('active', b.dataset.quote === exportQuoteChar);
    });
  }
  if (es.lineEnding !== undefined) {
    exportLineEnding = es.lineEnding;
    const endVal = exportLineEnding === '\r\n' ? 'crlf' : 'lf';
    $exportFormatSection.querySelectorAll('.export-ending').forEach(b => {
      b.classList.toggle('active', b.dataset.ending === endVal);
    });
  }
  if (es.nullValue !== undefined) {
    exportNullValue = es.nullValue;
    // Check if matches a preset
    const presetVals = ['', 'NA', 'NaN', 'NULL', '-999'];
    if (presetVals.indexOf(exportNullValue) >= 0) {
      $exportNullSelect.value = exportNullValue;
      $exportNullInput.style.display = 'none';
    } else {
      $exportNullSelect.value = 'custom';
      $exportNullInput.style.display = '';
      $exportNullInput.value = exportNullValue;
    }
  }
  if (es.precision !== undefined) {
    exportPrecision = es.precision;
    if (exportPrecision === null) {
      $exportPrecisionSelect.value = 'auto';
      $exportPrecisionInput.style.display = 'none';
    } else {
      // Check if matches a preset
      const opt = $exportPrecisionSelect.querySelector('option[value="' + exportPrecision + '"]');
      if (opt && exportPrecision !== 'custom') {
        $exportPrecisionSelect.value = String(exportPrecision);
        $exportPrecisionInput.style.display = 'none';
      } else {
        $exportPrecisionSelect.value = 'custom';
        $exportPrecisionInput.style.display = '';
        $exportPrecisionInput.value = exportPrecision;
      }
    }
  }
  if (es.decimalSep !== undefined) {
    exportDecimalSep = es.decimalSep;
    $exportFormatSection.querySelectorAll('.export-decsep').forEach(b => {
      b.classList.toggle('active', b.dataset.sep === exportDecimalSep);
    });
  }
  updateExportWarnings();
  updateExportPreview();
}

// ─── Swath Tab ────────────────────────────────────────────────────────

let swathNumCols = [];

function renderSwathConfig(data) {
  const $sidebar = document.getElementById('swathSidebar');
  const $content = document.getElementById('swathContent');
  if (!$sidebar) return;
  const { header, colTypes, geometry } = data;
  const hasXYZ = currentXYZ.x >= 0 && currentXYZ.y >= 0 && currentXYZ.z >= 0;
  if (!hasXYZ || !geometry || !geometry.x) {
    $sidebar.innerHTML = '';
    $content.innerHTML = '<div class="swath-hint">Assign X/Y/Z columns in Preflight and run analysis to enable Swath plots.</div>';
    return;
  }
  swathNumCols = header.map((h, i) => ({ name: h, idx: i, type: colTypes[i] }))
    .filter(c => c.type === 'numeric' && c.idx !== currentXYZ.x && c.idx !== currentXYZ.y && c.idx !== currentXYZ.z
      && c.idx !== currentDXYZ.dx && c.idx !== currentDXYZ.dy && c.idx !== currentDXYZ.dz);
  if (swathNumCols.length === 0) {
    $sidebar.innerHTML = '';
    $content.innerHTML = '<div class="swath-hint">No numeric variable columns available for swath analysis.</div>';
    return;
  }
  const axes = [
    { key: 'x', label: 'X', bs: geometry.x.blockSize },
    { key: 'y', label: 'Y', bs: geometry.y.blockSize },
    { key: 'z', label: 'Z', bs: geometry.z.blockSize }
  ];
  const defaultBs = axes[0].bs;
  const varItems = swathNumCols.map(c =>
    '<label class="swath-var-item"><input type="checkbox" value="' + c.idx + '" checked><span>' + esc(c.name) + '</span></label>'
  ).join('');

  $sidebar.innerHTML = `
    <div class="swath-sidebar-section">
      <div class="swath-sidebar-title">Axis</div>
      <select class="swath-select" id="swathAxis">${axes.map(a => '<option value="' + a.key + '">' + a.label + '</option>').join('')}</select>
      <div style="margin-top:0.4rem">
        <div class="swath-sidebar-title">Bin Width</div>
        <input type="number" class="swath-input" id="swathBinWidth" value="${defaultBs}" min="0.001" step="any">
        <div class="swath-bin-label" id="swathBinLabel">${defaultBs}m blocks</div>
      </div>
    </div>
    <div class="swath-sidebar-section">
      <div class="swath-sidebar-title">Statistic</div>
      <select class="swath-select" id="swathStat">
        <option value="mean_std">Mean \u00b1 Std</option>
        <option value="p25_50_75">P25 / P50 / P75</option>
        <option value="p10_50_90">P10 / P50 / P90</option>
      </select>
    </div>
    <div class="swath-sidebar-section--grow">
      <div class="swath-sidebar-title">Variables</div>
      <div class="swath-var-btns">
        <button id="swathVarAll">All</button>
        <button id="swathVarNone">None</button>
      </div>
      <div class="swath-var-list" id="swathVarList">${varItems}</div>
    </div>
    <div class="swath-sidebar-section">
      <div class="swath-sidebar-title">Local Filter</div>
      <input type="text" class="swath-search" id="swathLocalFilter" placeholder="e.g. r.zone == 1" autocomplete="off" spellcheck="false">
    </div>
    <div class="swath-sidebar-section">
      <button class="swath-generate" id="swathGenerate">Generate</button>
      <div class="swath-progress" id="swathProgress">
        <div class="swath-progress-bar"><div class="swath-progress-fill" id="swathProgressFill"></div></div>
        <div class="swath-progress-label" id="swathProgressLabel"></div>
      </div>
    </div>`;

  $content.innerHTML = '<div class="swath-hint">Select variables and click Generate to create swath plots.</div>';

  // Update bin width + label when axis changes
  const $axis = document.getElementById('swathAxis');
  const $binWidth = document.getElementById('swathBinWidth');
  const $binLabel = document.getElementById('swathBinLabel');
  $axis.addEventListener('change', () => {
    const a = axes.find(ax => ax.key === $axis.value);
    if (a) {
      $binWidth.value = a.bs;
      $binLabel.textContent = a.bs + 'm blocks';
    }
  });
  $binWidth.addEventListener('input', () => {
    const a = axes.find(ax => ax.key === $axis.value);
    $binLabel.textContent = (a ? a.bs : '') + 'm blocks';
  });

  // All/None buttons
  document.getElementById('swathVarAll').addEventListener('click', () => {
    document.querySelectorAll('#swathVarList input[type="checkbox"]').forEach(cb => cb.checked = true);
  });
  document.getElementById('swathVarNone').addEventListener('click', () => {
    document.querySelectorAll('#swathVarList input[type="checkbox"]').forEach(cb => cb.checked = false);
  });

  // Generate button
  document.getElementById('swathGenerate').addEventListener('click', runSwath);

  // Stat change re-renders from cache
  document.getElementById('swathStat').addEventListener('change', () => {
    if (lastSwathData) renderSwathCharts(lastSwathData, document.getElementById('swathStat').value);
  });

  // Local filter autocomplete
  if (swathExprController) swathExprController.destroy();
  swathExprController = createExprInput(document.getElementById('swathLocalFilter'), { mode: 'filter' });
}

function runSwath() {
  if (swathExprController) { const r = swathExprController.validate(); if (!r.valid) return; }
  const axisVal = document.getElementById('swathAxis').value;
  const binWidth = parseFloat(document.getElementById('swathBinWidth').value);
  const stat = document.getElementById('swathStat').value;
  const localFilter = document.getElementById('swathLocalFilter').value.trim();
  if (!binWidth || binWidth <= 0) return;

  // Gather selected variable column indices
  const varCols = [];
  document.querySelectorAll('#swathVarList input[type="checkbox"]:checked').forEach(cb => {
    varCols.push(parseInt(cb.value));
  });
  if (varCols.length === 0) return;

  if (swathWorker) swathWorker.terminate();
  swathWorker = new Worker(workerUrl);

  const $progress = document.getElementById('swathProgress');
  const $fill = document.getElementById('swathProgressFill');
  const $label = document.getElementById('swathProgressLabel');
  const $content = document.getElementById('swathContent');
  $progress.classList.add('active');
  $fill.style.width = '0%';
  $label.textContent = '0%';
  $content.innerHTML = '';

  const $btn = document.getElementById('swathGenerate');
  if ($btn) $btn.disabled = true;

  const resolvedTypes = currentColTypes.slice(0, currentOrigColCount);
  const filterPayload = currentFilter ? { expression: currentFilter.expression } : null;
  const zipEntry = preflightData ? (preflightData.selectedZipEntry || null) : null;

  const axisIdx = axisVal === 'x' ? 0 : (axisVal === 'y' ? 1 : 2);
  const xyzCols = [currentXYZ.x, currentXYZ.y, currentXYZ.z];
  const dxyzCols = [currentDXYZ.dx, currentDXYZ.dy, currentDXYZ.dz];

  swathWorker.postMessage({
    mode: 'swath',
    file: currentFile,
    zipEntry,
    globalFilter: filterPayload,
    localFilter: localFilter || null,
    calcolCode: currentCalcolCode || null,
    calcolMeta: currentCalcolMeta.length > 0 ? currentCalcolMeta : null,
    resolvedTypes,
    xyzCols,
    dxyzCols,
    axis: axisIdx,
    varCols,
    binWidth
  });

  swathWorker.onerror = (e) => {
    $label.textContent = 'Worker error: ' + (e.message || 'unknown error');
    $label.style.color = 'var(--red)';
    setTimeout(() => { $progress.classList.remove('active'); $label.style.color = ''; }, 3000);
    if ($btn) $btn.disabled = false;
    swathWorker.terminate();
    swathWorker = null;
  };

  swathWorker.onmessage = (e) => {
    const m = e.data;
    if (m.type === 'swath-progress') {
      const pct = Math.min(99, m.percent);
      $fill.style.width = pct.toFixed(1) + '%';
      $label.textContent = pct.toFixed(0) + '%';
    } else if (m.type === 'swath-complete') {
      $fill.style.width = '100%';
      $label.textContent = 'Done';
      setTimeout(() => $progress.classList.remove('active'), 800);
      if ($btn) $btn.disabled = false;
      lastSwathData = { vars: m.vars, axis: axisVal, axisIdx: axisIdx, binWidth, varCols, elapsed: m.elapsed };
      renderSwathCharts(lastSwathData, stat);
      // Update tab badge
      const totalBins = Object.values(m.vars).reduce((s, arr) => Math.max(s, arr.length), 0);
      const swathTab = document.querySelector('.results-tab[data-tab="swath"]');
      if (swathTab) swathTab.innerHTML = 'Swath <span class="tab-badge">' + totalBins + ' bins</span>';
      swathWorker.terminate();
      swathWorker = null;
    } else if (m.type === 'error') {
      $label.textContent = 'Error: ' + m.message;
      setTimeout(() => $progress.classList.remove('active'), 2000);
      if ($btn) $btn.disabled = false;
      swathWorker.terminate();
      swathWorker = null;
    }
  };
}

function queryTDigestPercentile(centroids, p) {
  if (!centroids || centroids.length === 0) return null;
  let total = 0;
  for (const [, c] of centroids) total += c;
  if (total === 0) return null;
  const target = p * total;
  let cum = 0;
  for (let i = 0; i < centroids.length; i++) {
    const [mean, count] = centroids[i];
    cum += count;
    if (cum >= target) return mean;
  }
  return centroids[centroids.length - 1][0];
}

function renderSwathCharts(swathData, stat) {
  const $content = document.getElementById('swathContent');
  if (!$content || !swathData || !swathData.vars) {
    if ($content) $content.innerHTML = '<div class="swath-hint">No data.</div>';
    return;
  }
  const varCols = swathData.varCols || [];
  const hasData = varCols.some(vi => swathData.vars[vi] && swathData.vars[vi].length > 0);
  if (!hasData) {
    $content.innerHTML = '<div class="swath-hint">No data in selected bins.</div>';
    return;
  }
  let html = '';
  for (const vi of varCols) {
    const bins = (swathData.vars[vi] || []).filter(b => b.count > 0).sort((a, b) => a.center - b.center);
    if (bins.length === 0) continue;
    html += '<div class="swath-chart-card">' + renderSingleSwathSvg(bins, swathData, vi, stat) + '</div>';
  }
  $content.innerHTML = html || '<div class="swath-hint">No data in selected bins.</div>';
}

function renderSingleSwathSvg(bins, swathData, varColIdx, stat) {
  const varName = currentHeader[varColIdx] || 'Variable';
  const axisLabel = swathData.axis.toUpperCase();
  const bw = swathData.binWidth;

  let centerLine = [], upperLine = [], lowerLine = [];
  for (const bin of bins) {
    const x = bin.center;
    if (stat === 'mean_std') {
      centerLine.push({ x, y: bin.mean });
      upperLine.push({ x, y: bin.mean + bin.std });
      lowerLine.push({ x, y: bin.mean - bin.std });
    } else if (stat === 'p25_50_75') {
      centerLine.push({ x, y: queryTDigestPercentile(bin.centroids, 0.50) });
      upperLine.push({ x, y: queryTDigestPercentile(bin.centroids, 0.75) });
      lowerLine.push({ x, y: queryTDigestPercentile(bin.centroids, 0.25) });
    } else {
      centerLine.push({ x, y: queryTDigestPercentile(bin.centroids, 0.50) });
      upperLine.push({ x, y: queryTDigestPercentile(bin.centroids, 0.90) });
      lowerLine.push({ x, y: queryTDigestPercentile(bin.centroids, 0.10) });
    }
  }

  const W = 720, H = 340;
  const pad = { top: 30, right: 40, bottom: 70, left: 65 };
  const plotW = W - pad.left - pad.right;
  const plotH = H - pad.top - pad.bottom;

  const xMin = bins[0].center - bw / 2;
  const xMax = bins[bins.length - 1].center + bw / 2;
  const xRange = xMax - xMin || 1;

  let allY = [];
  for (const p of [...centerLine, ...upperLine, ...lowerLine]) { if (p.y != null) allY.push(p.y); }
  let yMin = Math.min(...allY), yMax = Math.max(...allY);
  const yPad = (yMax - yMin) * 0.1 || 1;
  yMin -= yPad; yMax += yPad;
  const yRange = yMax - yMin || 1;

  const sx = (v) => pad.left + ((v - xMin) / xRange) * plotW;
  const sy = (v) => pad.top + ((yMax - v) / yRange) * plotH;

  const ribbonColor = stat === 'mean_std' ? 'rgba(240,178,50,0.2)' : 'rgba(88,166,255,0.2)';
  const lineColor = stat === 'mean_std' ? '#f0b232' : '#58a6ff';

  let ribbonPath = '';
  for (let i = 0; i < bins.length; i++) {
    ribbonPath += (i === 0 ? 'M' : 'L') + sx(upperLine[i].x).toFixed(1) + ',' + sy(upperLine[i].y != null ? upperLine[i].y : 0).toFixed(1);
  }
  for (let i = bins.length - 1; i >= 0; i--) {
    ribbonPath += 'L' + sx(lowerLine[i].x).toFixed(1) + ',' + sy(lowerLine[i].y != null ? lowerLine[i].y : 0).toFixed(1);
  }
  ribbonPath += 'Z';

  let centerPath = '';
  for (let i = 0; i < bins.length; i++) {
    centerPath += (i === 0 ? 'M' : 'L') + sx(centerLine[i].x).toFixed(1) + ',' + sy(centerLine[i].y != null ? centerLine[i].y : 0).toFixed(1);
  }

  let gridSvg = '';
  const nxTicks = Math.min(10, bins.length);
  for (let i = 0; i <= nxTicks; i++) {
    const v = xMin + (xRange * i / nxTicks);
    const x = sx(v);
    gridSvg += '<line x1="' + x.toFixed(1) + '" y1="' + pad.top + '" x2="' + x.toFixed(1) + '" y2="' + (H - pad.bottom) + '" stroke="#1e2228" stroke-width="1"/>';
    gridSvg += '<text x="' + x.toFixed(1) + '" y="' + (H - pad.bottom + 14) + '" text-anchor="middle" fill="#6a737d" font-size="9">' + formatNum(v) + '</text>';
  }
  const nyTicks = 6;
  for (let i = 0; i <= nyTicks; i++) {
    const v = yMin + (yRange * i / nyTicks);
    const y = sy(v);
    gridSvg += '<line x1="' + pad.left + '" y1="' + y.toFixed(1) + '" x2="' + (W - pad.right) + '" y2="' + y.toFixed(1) + '" stroke="#1e2228" stroke-width="1"/>';
    gridSvg += '<text x="' + (pad.left - 6) + '" y="' + (y + 3) + '" text-anchor="end" fill="#6a737d" font-size="9">' + formatNum(v) + '</text>';
  }

  const maxCount = Math.max(...bins.map(b => b.count));
  const barH = 20;
  let countBars = '';
  for (const bin of bins) {
    const bx = sx(bin.center - bw / 2);
    const bwPx = sx(bin.center + bw / 2) - bx;
    const bh = maxCount > 0 ? (bin.count / maxCount) * barH : 0;
    countBars += '<rect x="' + bx.toFixed(1) + '" y="' + (H - pad.bottom + 26 + barH - bh).toFixed(1) + '" width="' + Math.max(1, bwPx - 1).toFixed(1) + '" height="' + bh.toFixed(1) + '" fill="rgba(240,178,50,0.3)"/>';
  }

  const axisKey = swathData.axis;
  let dirLeft = '', dirRight = '';
  if (axisKey === 'x') { dirLeft = 'W'; dirRight = 'E'; }
  else if (axisKey === 'y') { dirLeft = 'S'; dirRight = 'N'; }
  else { dirLeft = 'Bottom'; dirRight = 'Top'; }
  const dirSvg = '<text x="' + (pad.left + 4) + '" y="' + (pad.top - 8) + '" fill="#6a737d" font-size="10">' + dirLeft + ' (' + formatNum(xMin) + ')</text>' +
    '<text x="' + (W - pad.right - 4) + '" y="' + (pad.top - 8) + '" text-anchor="end" fill="#6a737d" font-size="10">' + dirRight + ' (' + formatNum(xMax) + ')</text>';

  const statLabels = { mean_std: 'Mean \u00b1 Std', p25_50_75: 'P25/P50/P75', p10_50_90: 'P10/P50/P90' };

  return '<svg viewBox="0 0 ' + W + ' ' + H + '" xmlns="http://www.w3.org/2000/svg" style="font-family:var(--mono);width:100%;height:100%">' +
    '<rect width="' + W + '" height="' + H + '" fill="var(--bg)" rx="4"/>' +
    gridSvg + dirSvg +
    '<path d="' + ribbonPath + '" fill="' + ribbonColor + '"/>' +
    '<path d="' + centerPath + '" fill="none" stroke="' + lineColor + '" stroke-width="1.5"/>' +
    countBars +
    '<text x="' + (W / 2) + '" y="' + (H - 6) + '" text-anchor="middle" fill="#6a737d" font-size="10">' + axisLabel + ' Coordinate &mdash; ' + esc(varName) + ' (' + (statLabels[stat] || stat) + ')</text>' +
    '<text x="12" y="' + (H / 2) + '" text-anchor="middle" fill="#6a737d" font-size="10" transform="rotate(-90, 12, ' + (H / 2) + ')">' + esc(varName) + '</text>' +
    '</svg>';
}

// ─── Grade-Tonnage (GT) Tab ──────────────────────────────────────────

const GT_TONNAGE_UNITS = [
  { label: 't',  symbol: 't',  divisor: 1 },
  { label: 'kt', symbol: 'kt', divisor: 1e3 },
  { label: 'Mt', symbol: 'Mt', divisor: 1e6 },
  { label: 'Custom\u2026', symbol: null, divisor: null }
];
const GT_GRADE_UNITS = [
  { label: '(raw)',  symbol: '',     factor: 1 },
  { label: '%',      symbol: '%',    factor: 0.01 },
  { label: 'ppm',    symbol: 'ppm',  factor: 1e-6 },
  { label: 'ppb',    symbol: 'ppb',  factor: 1e-9 },
  { label: 'g/t',    symbol: 'g/t',  factor: 1e-6 },
  { label: 'oz/t',   symbol: 'oz/t', factor: 3.11035e-5 },
  { label: 'Custom\u2026', symbol: null, factor: null }
];

let gtNumCols = [];
let gtCatCols = [];

function renderGtConfig(data) {
  var $sidebar = document.getElementById('gtSidebar');
  var $content = document.getElementById('gtContent');
  if (!$sidebar) return;
  var header = data.header, colTypes = data.colTypes, geometry = data.geometry;

  // Reset cached results
  lastGtData = null;

  // Gather numeric columns (excluding XYZ/DXYZ)
  var excludeSet = new Set();
  if (currentXYZ.x >= 0) excludeSet.add(currentXYZ.x);
  if (currentXYZ.y >= 0) excludeSet.add(currentXYZ.y);
  if (currentXYZ.z >= 0) excludeSet.add(currentXYZ.z);
  if (currentDXYZ.dx >= 0) excludeSet.add(currentDXYZ.dx);
  if (currentDXYZ.dy >= 0) excludeSet.add(currentDXYZ.dy);
  if (currentDXYZ.dz >= 0) excludeSet.add(currentDXYZ.dz);

  gtNumCols = header.map(function(h, i) { return { name: h, idx: i, type: colTypes[i] }; })
    .filter(function(c) { return c.type === 'numeric' && !excludeSet.has(c.idx); });

  gtCatCols = header.map(function(h, i) { return { name: h, idx: i, type: colTypes[i] }; })
    .filter(function(c) { return c.type === 'categorical'; });

  if (gtNumCols.length === 0) {
    $sidebar.innerHTML = '';
    $content.innerHTML = '<div class="gt-hint">No numeric variable columns available for grade-tonnage analysis.</div>';
    return;
  }

  // Auto-detect block volume
  var volDisplay = 'Count-based (1 per row)';
  var volValue = '';
  var hasDXYZ = currentDXYZ.dx >= 0 && currentDXYZ.dy >= 0 && currentDXYZ.dz >= 0;
  if (hasDXYZ) {
    volDisplay = 'Per-row DXYZ columns';
  } else if (geometry && geometry.x && geometry.y && geometry.z &&
             geometry.x.blockSize && geometry.y.blockSize && geometry.z.blockSize) {
    var bv = geometry.x.blockSize * geometry.y.blockSize * geometry.z.blockSize;
    volDisplay = 'Geometry: ' + geometry.x.blockSize + ' \u00d7 ' + geometry.y.blockSize + ' \u00d7 ' + geometry.z.blockSize + ' = ' + formatNum(bv) + ' m\u00b3';
    volValue = bv;
  }

  // Grade variable checkbox list with per-variable unit selects
  var gradeUnitOpts = GT_GRADE_UNITS.slice(0, -1).map(function(u, i) {
    return '<option value="' + i + '">' + esc(u.label) + '</option>';
  }).join('');
  var varItems = gtNumCols.map(function(c, i) {
    return '<label class="gt-var-item"><input type="checkbox" value="' + c.idx + '"' + (i === 0 ? ' checked' : '') + '><span>' + esc(c.name) + '</span>' +
      '<select class="gt-var-unit" data-col="' + c.idx + '">' + gradeUnitOpts + '</select></label>';
  }).join('');

  var densityOpts = '<option value="-1">\u2014 none</option>' + gtNumCols.map(function(c) {
    return '<option value="' + c.idx + '">' + esc(c.name) + '</option>';
  }).join('');
  var weightOpts = densityOpts;

  var tonnageUnitOpts = GT_TONNAGE_UNITS.map(function(u, i) {
    return '<option value="' + i + '">' + esc(u.label) + '</option>';
  }).join('');

  // Group-by dropdown
  var groupByOpts = '<option value="-1">\u2014 none</option>' + gtCatCols.map(function(c) {
    return '<option value="' + c.idx + '">' + esc(c.name) + '</option>';
  }).join('');

  // Default cutoff range from first grade column stats
  var defMin = 0, defMax = 1, defStep = 0.05;
  var firstGrade = gtNumCols[0];
  if (lastCompleteData && lastCompleteData.stats && lastCompleteData.stats[firstGrade.idx]) {
    var gs = lastCompleteData.stats[firstGrade.idx];
    defMin = gs.min != null ? Math.floor(gs.min * 100) / 100 : 0;
    defMax = gs.max != null ? Math.ceil(gs.max * 100) / 100 : 1;
    defStep = +((defMax - defMin) / 20).toPrecision(2) || 0.05;
  }

  $sidebar.innerHTML =
    '<div class="gt-sidebar-section--grow">' +
      '<div class="gt-sidebar-title">Grade Variables</div>' +
      '<input type="text" class="gt-input gt-var-search" id="gtVarSearch" placeholder="search\u2026" spellcheck="false">' +
      '<div class="gt-var-btns"><button id="gtVarAll">All</button><button id="gtVarNone">None</button></div>' +
      '<div class="gt-var-list" id="gtVarList">' + varItems + '</div>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Density (optional)</div>' +
      '<select class="gt-select" id="gtDensityCol">' + densityOpts + '</select>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Weight (optional)</div>' +
      '<select class="gt-select" id="gtWeightCol">' + weightOpts + '</select>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Group by (optional)</div>' +
      '<select class="gt-select" id="gtGroupBy">' + groupByOpts + '</select>' +
      '<div class="gt-group-values" id="gtGroupValues" style="display:none">' +
        '<div class="gt-var-btns"><button id="gtGrpAll">All</button><button id="gtGrpNone">None</button></div>' +
        '<div class="gt-var-list" id="gtGrpList"></div>' +
      '</div>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Block Volume</div>' +
      '<div class="gt-vol-display" id="gtVolDisplay">' + volDisplay + '</div>' +
      '<div style="display:flex;gap:0.3rem;align-items:center;margin-top:0.2rem">' +
        '<span style="font-size:0.55rem;color:var(--fg-dim);white-space:nowrap">Override (m\u00b3)</span>' +
        '<input type="number" class="gt-input" id="gtVolOverride" value="' + volValue + '" min="0" step="any" placeholder="auto">' +
      '</div>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Tonnage Unit</div>' +
      '<select class="gt-select" id="gtTonnageUnit">' + tonnageUnitOpts + '</select>' +
      '<div id="gtCustomTonnageWrap" style="display:none;margin-top:0.3rem">' +
        '<div style="display:flex;gap:0.3rem">' +
          '<input type="text" class="gt-input" id="gtCustomTonnageSym" placeholder="symbol" style="width:50px">' +
          '<input type="number" class="gt-input" id="gtCustomTonnageDiv" placeholder="divisor" step="any">' +
        '</div>' +
      '</div>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Cutoffs</div>' +
      '<div style="margin-bottom:0.3rem">' +
        '<label class="gt-radio-label"><input type="radio" name="gtCutoffMode" value="range" checked> Range</label>' +
        '<label class="gt-radio-label"><input type="radio" name="gtCutoffMode" value="custom"> Custom</label>' +
      '</div>' +
      '<div id="gtCutoffRange">' +
        '<div style="display:flex;gap:0.3rem">' +
          '<label style="flex:1;display:flex;flex-direction:column;gap:0.1rem"><span style="font-size:0.55rem;color:var(--fg-dim)">Min</span><input type="number" class="gt-input" id="gtCutoffMin" value="' + defMin + '" step="any"></label>' +
          '<label style="flex:1;display:flex;flex-direction:column;gap:0.1rem"><span style="font-size:0.55rem;color:var(--fg-dim)">Max</span><input type="number" class="gt-input" id="gtCutoffMax" value="' + defMax + '" step="any"></label>' +
          '<label style="flex:1;display:flex;flex-direction:column;gap:0.1rem"><span style="font-size:0.55rem;color:var(--fg-dim)">Step</span><input type="number" class="gt-input" id="gtCutoffStep" value="' + defStep + '" step="any" min="0"></label>' +
        '</div>' +
      '</div>' +
      '<div id="gtCutoffCustom" style="display:none">' +
        '<input type="text" class="gt-input" id="gtCutoffCustomText" placeholder="0.2, 0.5, 1.0, 2.0, 5.0" spellcheck="false">' +
      '</div>' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<div class="gt-sidebar-title">Local Filter</div>' +
      '<input type="text" class="gt-input" id="gtLocalFilter" placeholder="e.g. r.zone == 1" autocomplete="off" spellcheck="false">' +
    '</div>' +
    '<div class="gt-sidebar-section">' +
      '<button class="gt-generate" id="gtGenerate">Generate</button>' +
      '<div class="gt-progress" id="gtProgress">' +
        '<div class="gt-progress-bar"><div class="gt-progress-fill" id="gtProgressFill"></div></div>' +
        '<div class="gt-progress-label" id="gtProgressLabel"></div>' +
      '</div>' +
    '</div>';

  $content.innerHTML = '<div class="gt-hint">Select grade variables and click Generate.</div>';

  // Wire events — autosave on any sidebar change
  $sidebar.addEventListener('change', function() { autoSaveProject(); });
  $sidebar.addEventListener('input', function(e) {
    if (e.target.tagName === 'INPUT' && e.target.type !== 'checkbox' && e.target.type !== 'radio') autoSaveProject();
  });

  var $tonnageUnit = document.getElementById('gtTonnageUnit');

  // Variable search filter
  document.getElementById('gtVarSearch').addEventListener('input', function() {
    var q = this.value.toLowerCase();
    document.querySelectorAll('#gtVarList .gt-var-item').forEach(function(item) {
      var name = item.querySelector('span').textContent.toLowerCase();
      item.style.display = fuzzyMatch(q, name) ? '' : 'none';
    });
  });

  // All/None buttons for grade variables (only affect visible items)
  document.getElementById('gtVarAll').addEventListener('click', function() {
    document.querySelectorAll('#gtVarList .gt-var-item').forEach(function(item) {
      if (item.style.display !== 'none') item.querySelector('input[type="checkbox"]').checked = true;
    });
  });
  document.getElementById('gtVarNone').addEventListener('click', function() {
    document.querySelectorAll('#gtVarList .gt-var-item').forEach(function(item) {
      if (item.style.display !== 'none') item.querySelector('input[type="checkbox"]').checked = false;
    });
  });

  // Cutoff mode radio
  document.querySelectorAll('input[name="gtCutoffMode"]').forEach(function(r) {
    r.addEventListener('change', function() {
      document.getElementById('gtCutoffRange').style.display = r.value === 'range' ? '' : 'none';
      document.getElementById('gtCutoffCustom').style.display = r.value === 'custom' ? '' : 'none';
    });
  });

  // Unit custom toggles
  $tonnageUnit.addEventListener('change', function() {
    var idx = parseInt($tonnageUnit.value);
    document.getElementById('gtCustomTonnageWrap').style.display = GT_TONNAGE_UNITS[idx].divisor === null ? '' : 'none';
    if (lastGtData) renderGtOutput();
  });
  // Per-variable grade unit change — re-render if results exist
  document.getElementById('gtVarList').addEventListener('change', function(e) {
    if (e.target.classList.contains('gt-var-unit') && lastGtData) renderGtOutput();
  });

  // Group-by dropdown change — populate group value checkboxes
  document.getElementById('gtGroupBy').addEventListener('change', function() {
    updateGroupByValues();
  });

  // Group value All/None buttons
  document.getElementById('gtGrpAll').addEventListener('click', function() {
    document.querySelectorAll('#gtGrpList input[type="checkbox"]').forEach(function(cb) { cb.checked = true; });
    if (lastGtData) renderGtOutput();
  });
  document.getElementById('gtGrpNone').addEventListener('click', function() {
    document.querySelectorAll('#gtGrpList input[type="checkbox"]').forEach(function(cb) { cb.checked = false; });
    if (lastGtData) renderGtOutput();
  });

  // Group value checkbox change — re-render
  document.getElementById('gtGrpList').addEventListener('change', function() {
    if (lastGtData) renderGtOutput();
  });

  // Generate button
  document.getElementById('gtGenerate').addEventListener('click', runGt);

  // Local filter autocomplete
  if (gtExprController) gtExprController.destroy();
  gtExprController = createExprInput(document.getElementById('gtLocalFilter'), { mode: 'filter' });
}

function updateGroupByValues() {
  var $wrap = document.getElementById('gtGroupValues');
  var $list = document.getElementById('gtGrpList');
  var colIdx = parseInt(document.getElementById('gtGroupBy').value);
  if (colIdx < 0 || !lastCompleteData || !lastCompleteData.categories) {
    $wrap.style.display = 'none';
    $list.innerHTML = '';
    return;
  }
  var catEntry = lastCompleteData.categories[colIdx];
  if (!catEntry || !catEntry.counts) { $wrap.style.display = 'none'; return; }
  var cats = catEntry.counts;
  var colName = currentHeader[colIdx] || '';
  var values = Object.keys(cats);
  // Use custom order if available
  if (catCustomOrders[colName]) {
    var orderedSet = new Set(catCustomOrders[colName]);
    var ordered = catCustomOrders[colName].filter(function(v) { return cats[v] != null; });
    var rest = values.filter(function(v) { return !orderedSet.has(v); }).sort();
    values = ordered.concat(rest);
  } else {
    values.sort();
  }
  var html = '<label class="gt-var-item"><input type="checkbox" value="__total__" checked><span>Total (all)</span></label>';
  for (var i = 0; i < values.length; i++) {
    html += '<label class="gt-var-item"><input type="checkbox" value="' + esc(values[i]) + '" checked><span>' + esc(values[i]) + '</span></label>';
  }
  $list.innerHTML = html;
  $wrap.style.display = '';
}

function getGtTonnageUnit() {
  var tIdx = parseInt(document.getElementById('gtTonnageUnit').value);
  var tu = GT_TONNAGE_UNITS[tIdx] || GT_TONNAGE_UNITS[0];
  var tonnageDivisor = tu.divisor;
  var tonnageSymbol = tu.symbol;
  if (tonnageDivisor === null) {
    tonnageSymbol = document.getElementById('gtCustomTonnageSym').value || 'units';
    tonnageDivisor = parseFloat(document.getElementById('gtCustomTonnageDiv').value) || 1;
  }
  return { tonnageDivisor: tonnageDivisor, tonnageSymbol: tonnageSymbol, metalSymbol: tonnageSymbol };
}

function getGtGradeUnit(colIdx) {
  var sel = document.querySelector('.gt-var-unit[data-col="' + colIdx + '"]');
  var idx = sel ? parseInt(sel.value) : 0;
  var gu = GT_GRADE_UNITS[idx] || GT_GRADE_UNITS[0];
  return { gradeFactor: gu.factor, gradeSymbol: gu.symbol };
}

function getGtCutoffs() {
  var mode = document.querySelector('input[name="gtCutoffMode"]:checked').value;
  var cutoffs = [];
  if (mode === 'range') {
    var mn = parseFloat(document.getElementById('gtCutoffMin').value);
    var mx = parseFloat(document.getElementById('gtCutoffMax').value);
    var step = parseFloat(document.getElementById('gtCutoffStep').value);
    if (!isFinite(mn) || !isFinite(mx) || !isFinite(step) || step <= 0) return [];
    for (var v = mn; v <= mx + step * 0.001; v += step) {
      cutoffs.push(+v.toPrecision(10));
    }
  } else {
    var txt = document.getElementById('gtCutoffCustomText').value;
    txt.split(/[,;\s]+/).forEach(function(s) {
      var v = parseFloat(s.trim());
      if (isFinite(v)) cutoffs.push(v);
    });
    cutoffs.sort(function(a, b) { return a - b; });
  }
  return cutoffs;
}

function getGtCheckedGradeCols() {
  var checked = [];
  document.querySelectorAll('#gtVarList input[type="checkbox"]:checked').forEach(function(cb) {
    checked.push(parseInt(cb.value));
  });
  return checked;
}

function runGt() {
  if (gtExprController) { var r = gtExprController.validate(); if (!r.valid) return; }
  var gradeCols = getGtCheckedGradeCols();
  if (gradeCols.length === 0) return;

  var densityCol = parseInt(document.getElementById('gtDensityCol').value);
  var weightCol = parseInt(document.getElementById('gtWeightCol').value);
  var groupByCol = parseInt(document.getElementById('gtGroupBy').value);
  var localFilter = document.getElementById('gtLocalFilter').value.trim();
  var volOverride = parseFloat(document.getElementById('gtVolOverride').value);

  // Compute per-variable grade ranges from stats
  var gradeRanges = [];
  for (var i = 0; i < gradeCols.length; i++) {
    var gc = gradeCols[i];
    var gradeMin = 0, gradeMax = 1;
    if (lastCompleteData && lastCompleteData.stats && lastCompleteData.stats[gc]) {
      var gs = lastCompleteData.stats[gc];
      gradeMin = gs.min != null ? gs.min : 0;
      gradeMax = gs.max != null ? gs.max : 1;
    }
    var range = gradeMax - gradeMin;
    if (range <= 0) range = 1;
    gradeMin -= range * 0.001;
    gradeMax += range * 0.001;
    gradeRanges.push({ min: gradeMin, max: gradeMax });
  }

  // Determine block volume
  var blockVolume = 0;
  var dxyzCols = null;
  var hasDXYZ = currentDXYZ.dx >= 0 && currentDXYZ.dy >= 0 && currentDXYZ.dz >= 0;
  if (isFinite(volOverride) && volOverride > 0) {
    blockVolume = volOverride;
  } else if (hasDXYZ) {
    dxyzCols = [currentDXYZ.dx, currentDXYZ.dy, currentDXYZ.dz];
  } else if (lastCompleteData && lastCompleteData.geometry) {
    var geo = lastCompleteData.geometry;
    if (geo.x && geo.y && geo.z && geo.x.blockSize && geo.y.blockSize && geo.z.blockSize) {
      blockVolume = geo.x.blockSize * geo.y.blockSize * geo.z.blockSize;
    }
  }

  if (gtWorker) gtWorker.terminate();
  gtWorker = new Worker(workerUrl);

  var $progress = document.getElementById('gtProgress');
  var $fill = document.getElementById('gtProgressFill');
  var $label = document.getElementById('gtProgressLabel');
  var $content = document.getElementById('gtContent');
  $progress.classList.add('active');
  $fill.style.width = '0%';
  $label.textContent = '0%';
  $content.innerHTML = '';

  var $btn = document.getElementById('gtGenerate');
  if ($btn) $btn.disabled = true;

  var resolvedTypes = currentColTypes.slice(0, currentOrigColCount);
  var filterPayload = currentFilter ? { expression: currentFilter.expression } : null;
  var zipEntry = preflightData ? (preflightData.selectedZipEntry || null) : null;

  gtWorker.postMessage({
    mode: 'gt',
    file: currentFile,
    zipEntry: zipEntry,
    globalFilter: filterPayload,
    localFilter: localFilter || null,
    calcolCode: currentCalcolCode || null,
    calcolMeta: currentCalcolMeta.length > 0 ? currentCalcolMeta : null,
    resolvedTypes: resolvedTypes,
    gradeCols: gradeCols,
    gradeRanges: gradeRanges,
    densityCol: densityCol >= 0 ? densityCol : null,
    weightCol: weightCol >= 0 ? weightCol : null,
    dxyzCols: dxyzCols,
    blockVolume: blockVolume,
    groupByCol: groupByCol >= 0 ? groupByCol : null
  });

  gtWorker.onerror = function(e) {
    $label.textContent = 'Worker error: ' + (e.message || 'unknown error');
    $label.style.color = 'var(--red)';
    setTimeout(function() { $progress.classList.remove('active'); $label.style.color = ''; }, 3000);
    if ($btn) $btn.disabled = false;
    gtWorker.terminate();
    gtWorker = null;
  };

  gtWorker.onmessage = function(e) {
    var m = e.data;
    if (m.type === 'gt-progress') {
      var pct = Math.min(99, m.percent);
      $fill.style.width = pct.toFixed(1) + '%';
      $label.textContent = pct.toFixed(0) + '%';
    } else if (m.type === 'gt-complete') {
      $fill.style.width = '100%';
      $label.textContent = 'Done';
      setTimeout(function() { $progress.classList.remove('active'); }, 800);
      if ($btn) $btn.disabled = false;
      lastGtData = m;
      renderGtOutput();
      // Update tab badge with number of selected grade variables
      var gtTab = document.querySelector('.results-tab[data-tab="gt"]');
      if (gtTab && m.gradeResults) {
        gtTab.innerHTML = 'GT <span class="tab-badge">' + m.gradeResults.length + '</span>';
      }
      gtWorker.terminate();
      gtWorker = null;
    } else if (m.type === 'error') {
      $label.textContent = 'Error: ' + m.message;
      setTimeout(function() { $progress.classList.remove('active'); }, 2000);
      if ($btn) $btn.disabled = false;
      gtWorker.terminate();
      gtWorker = null;
    }
  };
}

function renderGtOutput() {
  if (!lastGtData || !lastGtData.gradeResults) return;
  var $content = document.getElementById('gtContent');
  if (!$content) return;
  var cutoffs = getGtCutoffs();
  var tonnageUnit = getGtTonnageUnit();
  if (cutoffs.length === 0) {
    $content.innerHTML = '<div class="gt-hint">No valid cutoffs defined.</div>';
    return;
  }

  // Determine which groups are selected (if grouped)
  var selectedGroups = new Set();
  var showTotal = false;
  var isGrouped = lastGtData.grouped;
  if (isGrouped) {
    document.querySelectorAll('#gtGrpList input:checked').forEach(function(cb) {
      if (cb.value === '__total__') showTotal = true;
      else selectedGroups.add(cb.value);
    });
  }

  var gradeResults = lastGtData.gradeResults;
  var html = '<div class="gt-toolbar"><span class="gt-elapsed">' + (lastGtData.elapsed / 1000).toFixed(1) + 's</span></div>';

  for (var gi = 0; gi < gradeResults.length; gi++) {
    var gr = gradeResults[gi];
    var gradeUnit = getGtGradeUnit(gr.colIdx);
    var units = {
      tonnageDivisor: tonnageUnit.tonnageDivisor,
      tonnageSymbol: tonnageUnit.tonnageSymbol,
      metalSymbol: tonnageUnit.metalSymbol,
      gradeFactor: gradeUnit.gradeFactor,
      gradeSymbol: gradeUnit.gradeSymbol
    };
    if (gradeResults.length > 1) {
      html += '<div class="gt-chart-title">' + esc(gr.colName) + (units.gradeSymbol ? ' (' + esc(units.gradeSymbol) + ')' : '') + '</div>';
    }
    html += '<div class="gt-chart-wrap">' + renderGtChart(gr, cutoffs, units, isGrouped, gi, selectedGroups, showTotal) + '</div>';
    // Collapsible table with per-table copy button
    var tableTitle = gradeResults.length > 1 ? esc(gr.colName) + (units.gradeSymbol ? ' (' + esc(units.gradeSymbol) + ')' : '') : 'Table';
    html += '<div class="gt-table-section">' +
      '<div class="gt-table-header" data-gt-collapse="' + gi + '">' +
        '<span class="gt-table-toggle">\u25BC</span> ' + tableTitle +
        '<button class="gt-copy-btn" data-gt-copy="' + gi + '">Copy</button>' +
      '</div>' +
      '<div class="gt-table-body" id="gtTableBody' + gi + '">' +
        '<div class="gt-table-wrap">' + renderGtTable(gr, cutoffs, units, isGrouped, gi, selectedGroups, showTotal) + '</div>' +
      '</div>' +
    '</div>';
  }

  $content.innerHTML = html;

  // Wire per-table copy buttons
  $content.querySelectorAll('[data-gt-copy]').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      var idx = btn.dataset.gtCopy;
      var table = document.querySelector('#gtTableBody' + idx + ' .gt-table');
      if (!table) return;
      var tsv = [];
      table.querySelectorAll('tr').forEach(function(row) {
        var cells = [];
        row.querySelectorAll('th, td').forEach(function(c) { cells.push(c.textContent); });
        tsv.push(cells.join('\t'));
      });
      navigator.clipboard.writeText(tsv.join('\n')).then(function() {
        btn.textContent = 'Copied!';
        setTimeout(function() { btn.textContent = 'Copy'; }, 1500);
      });
    });
  });

  // Wire collapsible table headers
  $content.querySelectorAll('[data-gt-collapse]').forEach(function(hdr) {
    hdr.addEventListener('click', function() {
      var idx = hdr.dataset.gtCollapse;
      var body = document.getElementById('gtTableBody' + idx);
      var toggle = hdr.querySelector('.gt-table-toggle');
      if (body.style.display === 'none') {
        body.style.display = '';
        toggle.textContent = '\u25BC';
      } else {
        body.style.display = 'none';
        toggle.textContent = '\u25B6';
      }
    });
  });

  // Wire crosshairs for each chart
  for (var ci = 0; ci < gradeResults.length; ci++) {
    var chGradeUnit = getGtGradeUnit(gradeResults[ci].colIdx);
    var chUnits = {
      tonnageDivisor: tonnageUnit.tonnageDivisor,
      tonnageSymbol: tonnageUnit.tonnageSymbol,
      metalSymbol: tonnageUnit.metalSymbol,
      gradeFactor: chGradeUnit.gradeFactor,
      gradeSymbol: chGradeUnit.gradeSymbol
    };
    wireGtCrosshair(gradeResults[ci], cutoffs, chUnits, ci);
  }
}

function interpolateGt(results, cutoff, binWidth, gradeMin) {
  var zero = { tonnage: 0, grade: 0, metal: 0 };
  if (!results || results.length === 0) return zero;
  if (!binWidth || !isFinite(binWidth)) return results[0] || zero;
  var idx = (cutoff - gradeMin) / binWidth;
  if (!isFinite(idx)) return results[0] || zero;
  var lo = Math.floor(idx);
  if (lo < 0) lo = 0;
  if (lo >= results.length) lo = results.length - 1;
  var hi = lo + 1;
  if (hi >= results.length) hi = results.length - 1;
  if (lo === hi) return results[lo] || zero;
  var a = results[lo], b = results[hi];
  if (!a || !b) return a || b || zero;
  var frac = idx - lo;
  return {
    tonnage: a.tonnage + (b.tonnage - a.tonnage) * frac,
    grade: a.grade + (b.grade - a.grade) * frac,
    metal: a.metal + (b.metal - a.metal) * frac
  };
}

function renderGtChart(grData, cutoffs, units, isGrouped, chartIdx, selectedGroups, showTotal) {
  var results = grData.results;
  if (!results || results.length === 0) return '<div class="gt-hint">No GT data available.</div>';
  var binWidth = grData.binWidth;
  var gradeMin = grData.gradeMin;
  var totalTonnage = grData.totalTonnage;
  var td = units.tonnageDivisor || 1;
  var gf = units.gradeFactor || 1;
  var clipId = 'gt-clip-' + chartIdx;

  // Determine if we render grouped overlay
  var groupResults = isGrouped && grData.groupResults ? grData.groupResults : null;
  var allGroupNames = groupResults ? Object.keys(groupResults).sort() : [];
  // Filter to selected groups
  var groupNames = allGroupNames;
  if (groupResults && selectedGroups && selectedGroups.size > 0) {
    groupNames = allGroupNames.filter(function(n) { return selectedGroups.has(n); });
  } else if (groupResults && selectedGroups && selectedGroups.size === 0 && !showTotal) {
    groupNames = [];
  }

  // Sample curve at cutoffs (overall)
  var points = cutoffs.map(function(c) {
    var p = interpolateGt(results, c, binWidth, gradeMin);
    return { cutoff: c, tonnage: p.tonnage / td, grade: p.grade, metal: p.metal * gf / td };
  });

  var W = 720, H = 380;
  var pad = { top: 30, right: 75, bottom: 50, left: 75 };
  var plotW = W - pad.left - pad.right;
  var plotH = H - pad.top - pad.bottom;

  // Tonnage range (left Y)
  var tMin = 0, tMax = Math.max.apply(null, points.map(function(p) { return p.tonnage; })) || 1;
  tMax += tMax * 0.05;

  // Grade range (right Y) — only from points with tonnage > 0
  var validGrades = points.filter(function(p) { return p.tonnage > 0; }).map(function(p) { return p.grade; });
  if (validGrades.length === 0) validGrades = [0, 1];
  var gMin = Math.min.apply(null, validGrades);
  var gMax = Math.max.apply(null, validGrades);
  if (gMin === gMax) { gMin -= 0.5; gMax += 0.5; }
  var gPadding = (gMax - gMin) * 0.05;
  gMin -= gPadding; gMax += gPadding;
  if (gMin < 0) gMin = 0;

  // X range
  var xMin = cutoffs[0], xMax = cutoffs[cutoffs.length - 1];
  var xRange = xMax - xMin || 1;

  var sx = function(v) { return pad.left + ((v - xMin) / xRange) * plotW; };
  var syT = function(v) { return pad.top + ((tMax - v) / (tMax - tMin)) * plotH; };
  var syG = function(v) { return pad.top + ((gMax - v) / (gMax - gMin)) * plotH; };

  // Grid
  var svg = '';
  var nxTicks = Math.min(10, cutoffs.length);
  for (var i = 0; i <= nxTicks; i++) {
    var v = xMin + (xRange * i / nxTicks);
    var x = sx(v);
    svg += '<line x1="' + x.toFixed(1) + '" y1="' + pad.top + '" x2="' + x.toFixed(1) + '" y2="' + (H - pad.bottom) + '" stroke="#1e2228" stroke-width="1"/>';
    svg += '<text x="' + x.toFixed(1) + '" y="' + (H - pad.bottom + 14) + '" text-anchor="middle" fill="#6a737d" font-size="9">' + formatNum(v) + '</text>';
  }
  var nyTicks = 6;
  for (var j = 0; j <= nyTicks; j++) {
    var tv = tMin + ((tMax - tMin) * j / nyTicks);
    var y = syT(tv);
    svg += '<line x1="' + pad.left + '" y1="' + y.toFixed(1) + '" x2="' + (W - pad.right) + '" y2="' + y.toFixed(1) + '" stroke="#1e2228" stroke-width="1"/>';
    svg += '<text x="' + (pad.left - 6) + '" y="' + (y + 3).toFixed(1) + '" text-anchor="end" fill="var(--amber)" font-size="9">' + formatNum(tv) + '</text>';
    var gv = gMin + ((gMax - gMin) * j / nyTicks);
    svg += '<text x="' + (W - pad.right + 6) + '" y="' + (y + 3).toFixed(1) + '" text-anchor="start" fill="var(--blue)" font-size="9">' + formatNum(gv) + '</text>';
  }

  // Clip path
  svg += '<defs><clipPath id="' + clipId + '"><rect x="' + pad.left + '" y="' + pad.top + '" width="' + plotW + '" height="' + plotH + '"/></clipPath></defs>';
  svg += '<g clip-path="url(#' + clipId + ')">';

  if (groupNames.length > 0 || (isGrouped && showTotal)) {
    // "Total" line from overall results
    if (showTotal) {
      var tTotalP = '';
      var gTotalP = '';
      for (var ti = 0; ti < points.length; ti++) {
        tTotalP += (ti === 0 ? 'M' : 'L') + sx(points[ti].cutoff).toFixed(1) + ',' + syT(points[ti].tonnage).toFixed(1);
        if (points[ti].tonnage > 0) {
          gTotalP += (gTotalP ? 'L' : 'M') + sx(points[ti].cutoff).toFixed(1) + ',' + syG(points[ti].grade).toFixed(1);
        }
      }
      svg += '<path d="' + tTotalP + '" fill="none" stroke="var(--amber)" stroke-width="2.5" opacity="0.7"/>';
      if (gTotalP) svg += '<path d="' + gTotalP + '" fill="none" stroke="var(--blue)" stroke-width="2" stroke-dasharray="4,3" opacity="0.7"/>';
    }
    // Grouped overlay: draw tonnage + grade per group with colors
    for (var gi = 0; gi < groupNames.length; gi++) {
      var gn = groupNames[gi];
      var grd = groupResults[gn];
      var colorIdx = allGroupNames.indexOf(gn);
      var color = getCategoryColor(lastGtData.groupByColName || '', gn, colorIdx >= 0 ? colorIdx : gi);
      var grpPts = cutoffs.map(function(c) {
        var p = interpolateGt(grd.results, c, binWidth, gradeMin);
        return { cutoff: c, tonnage: p.tonnage / td, grade: p.grade };
      });
      // Tonnage line (solid)
      var tP = '';
      for (var k = 0; k < grpPts.length; k++) {
        tP += (k === 0 ? 'M' : 'L') + sx(grpPts[k].cutoff).toFixed(1) + ',' + syT(grpPts[k].tonnage).toFixed(1);
      }
      svg += '<path d="' + tP + '" fill="none" stroke="' + color + '" stroke-width="1.5"/>';
      // Grade line (dashed) — clip where tonnage is 0
      var gP = '';
      for (var l = 0; l < grpPts.length; l++) {
        if (grpPts[l].tonnage > 0) {
          gP += (gP ? 'L' : 'M') + sx(grpPts[l].cutoff).toFixed(1) + ',' + syG(grpPts[l].grade).toFixed(1);
        }
      }
      if (gP) svg += '<path d="' + gP + '" fill="none" stroke="' + color + '" stroke-width="1" stroke-dasharray="4,3"/>';
    }
  } else {
    // Ungrouped: standard tonnage + grade + metal lines
    var tPath = '';
    for (var k = 0; k < points.length; k++) {
      tPath += (k === 0 ? 'M' : 'L') + sx(points[k].cutoff).toFixed(1) + ',' + syT(points[k].tonnage).toFixed(1);
    }
    svg += '<path d="' + tPath + '" fill="none" stroke="var(--amber)" stroke-width="2"/>';

    var gPath = '';
    for (var l = 0; l < points.length; l++) {
      if (points[l].tonnage > 0) {
        gPath += (gPath ? 'L' : 'M') + sx(points[l].cutoff).toFixed(1) + ',' + syG(points[l].grade).toFixed(1);
      }
    }
    if (gPath) svg += '<path d="' + gPath + '" fill="none" stroke="var(--blue)" stroke-width="2"/>';

    var mMax = Math.max.apply(null, points.map(function(p) { return p.metal; })) || 1;
    var syM = function(v) { return pad.top + ((mMax - v) / mMax) * plotH; };
    var mPath = '';
    for (var n = 0; n < points.length; n++) {
      mPath += (n === 0 ? 'M' : 'L') + sx(points[n].cutoff).toFixed(1) + ',' + syM(points[n].metal).toFixed(1);
    }
    svg += '<path d="' + mPath + '" fill="none" stroke="var(--green)" stroke-width="1.5" stroke-dasharray="4,3"/>';
  }

  svg += '</g>'; // close clip group

  // Axis labels
  svg += '<text x="' + (W / 2) + '" y="' + (H - 6) + '" text-anchor="middle" fill="#6a737d" font-size="10">Cutoff' + (units.gradeSymbol ? ' (' + esc(units.gradeSymbol) + ')' : '') + '</text>';
  svg += '<text x="12" y="' + (H / 2) + '" text-anchor="middle" fill="var(--amber)" font-size="10" transform="rotate(-90, 12, ' + (H / 2) + ')">Tonnage (' + esc(units.tonnageSymbol) + ')</text>';
  svg += '<text x="' + (W - 8) + '" y="' + (H / 2) + '" text-anchor="middle" fill="var(--blue)" font-size="10" transform="rotate(90, ' + (W - 8) + ', ' + (H / 2) + ')">Grade' + (units.gradeSymbol ? ' (' + esc(units.gradeSymbol) + ')' : '') + '</text>';

  // Legend
  if (groupNames.length > 0 || (isGrouped && showTotal)) {
    var legY = pad.top + 6;
    if (showTotal) {
      svg += '<rect x="' + (pad.left + 10) + '" y="' + legY + '" width="10" height="3" fill="var(--amber)" rx="1" opacity="0.7"/>';
      svg += '<text x="' + (pad.left + 24) + '" y="' + (legY + 4) + '" fill="var(--amber)" font-size="7">Total</text>';
      legY += 11;
    }
    for (var gi = 0; gi < Math.min(groupNames.length, 15); gi++) {
      var gn = groupNames[gi];
      var colorIdx = allGroupNames.indexOf(gn);
      var color = getCategoryColor(lastGtData.groupByColName || '', gn, colorIdx >= 0 ? colorIdx : gi);
      svg += '<rect x="' + (pad.left + 10) + '" y="' + legY + '" width="10" height="3" fill="' + color + '" rx="1"/>';
      svg += '<text x="' + (pad.left + 24) + '" y="' + (legY + 4) + '" fill="' + color + '" font-size="7">' + esc(gn) + '</text>';
      legY += 11;
    }
    if (groupNames.length > 15) {
      svg += '<text x="' + (pad.left + 24) + '" y="' + (legY + 4) + '" fill="var(--fg-dim)" font-size="7">+' + (groupNames.length - 15) + ' more</text>';
    }
  } else {
    svg += '<rect x="' + (pad.left + 10) + '" y="' + (pad.top + 6) + '" width="10" height="3" fill="var(--amber)" rx="1"/>';
    svg += '<text x="' + (pad.left + 24) + '" y="' + (pad.top + 10) + '" fill="var(--amber)" font-size="8">Tonnage</text>';
    svg += '<rect x="' + (pad.left + 10) + '" y="' + (pad.top + 18) + '" width="10" height="3" fill="var(--blue)" rx="1"/>';
    svg += '<text x="' + (pad.left + 24) + '" y="' + (pad.top + 22) + '" fill="var(--blue)" font-size="8">Grade</text>';
    svg += '<line x1="' + (pad.left + 10) + '" y1="' + (pad.top + 31.5) + '" x2="' + (pad.left + 20) + '" y2="' + (pad.top + 31.5) + '" stroke="var(--green)" stroke-width="1.5" stroke-dasharray="3,2"/>';
    svg += '<text x="' + (pad.left + 24) + '" y="' + (pad.top + 34) + '" fill="var(--green)" font-size="8">Metal</text>';
  }

  // Crosshair overlay area
  svg += '<rect class="gt-crosshair-area" x="' + pad.left + '" y="' + pad.top + '" width="' + plotW + '" height="' + plotH + '" fill="transparent"/>';
  svg += '<line class="gt-crosshair-line" x1="0" y1="' + pad.top + '" x2="0" y2="' + (H - pad.bottom) + '" stroke="var(--fg-dim)" stroke-width="1" opacity="0" stroke-dasharray="3,3"/>';
  svg += '<g class="gt-crosshair-tooltip" opacity="0"><rect class="gt-tt-bg" rx="3" ry="3"/><text class="gt-tt-text" font-size="9"></text></g>';

  return '<svg class="gt-svg" data-chart-idx="' + chartIdx + '" viewBox="0 0 ' + W + ' ' + H + '" xmlns="http://www.w3.org/2000/svg" style="font-family:var(--mono);width:100%;height:auto" ' +
    'data-pad-left="' + pad.left + '" data-pad-right="' + pad.right + '" data-pad-top="' + pad.top + '" data-pad-bottom="' + pad.bottom + '" ' +
    'data-w="' + W + '" data-h="' + H + '" data-xmin="' + xMin + '" data-xmax="' + xMax + '">' +
    '<rect width="' + W + '" height="' + H + '" fill="var(--bg)" rx="4"/>' +
    svg +
    '</svg>';
}

function wireGtCrosshair(grData, cutoffs, units, chartIdx) {
  var svgEl = document.querySelector('.gt-svg[data-chart-idx="' + chartIdx + '"]');
  if (!svgEl) return;
  var area = svgEl.querySelector('.gt-crosshair-area');
  var line = svgEl.querySelector('.gt-crosshair-line');
  var ttGroup = svgEl.querySelector('.gt-crosshair-tooltip');
  var ttBg = svgEl.querySelector('.gt-tt-bg');
  var ttText = svgEl.querySelector('.gt-tt-text');
  if (!area || !line || !ttGroup) return;

  var padLeft = parseFloat(svgEl.dataset.padLeft);
  var W = parseFloat(svgEl.dataset.w);
  var xMin = parseFloat(svgEl.dataset.xmin);
  var xMax = parseFloat(svgEl.dataset.xmax);
  var padRight = parseFloat(svgEl.dataset.padRight);
  var plotW = W - padLeft - padRight;

  function onMove(e) {
    var pt = svgEl.createSVGPoint();
    pt.x = e.clientX; pt.y = e.clientY;
    var svgX = pt.matrixTransform(svgEl.getScreenCTM().inverse()).x;
    var cutoff = xMin + ((svgX - padLeft) / plotW) * (xMax - xMin);
    if (cutoff < xMin) cutoff = xMin;
    if (cutoff > xMax) cutoff = xMax;

    var p = interpolateGt(grData.results, cutoff, grData.binWidth, grData.gradeMin);
    var td = units.tonnageDivisor;
    var gf = units.gradeFactor;
    var tonnage = p.tonnage / td;
    var grade = p.grade;
    var metal = p.metal * gf / td;
    var pctTotal = grData.totalTonnage > 0 ? (p.tonnage / grData.totalTonnage * 100) : 0;

    line.setAttribute('x1', svgX.toFixed(1));
    line.setAttribute('x2', svgX.toFixed(1));
    line.setAttribute('opacity', '1');

    var lines = [
      'Cutoff: ' + formatNum(cutoff),
      'Tonnage: ' + formatNum(tonnage) + ' ' + units.tonnageSymbol,
      'Grade: ' + formatNum(grade) + (units.gradeSymbol ? ' ' + units.gradeSymbol : ''),
      'Metal: ' + formatNum(metal) + ' ' + units.metalSymbol,
      '% Total: ' + pctTotal.toFixed(1) + '%'
    ];

    var lineH = 13;
    var ttW = 140;
    var ttH = lines.length * lineH + 8;
    var tx = svgX + 10;
    var ty = 40;
    if (tx + ttW > W - 10) tx = svgX - ttW - 10;

    ttBg.setAttribute('x', tx);
    ttBg.setAttribute('y', ty);
    ttBg.setAttribute('width', ttW);
    ttBg.setAttribute('height', ttH);
    ttBg.setAttribute('fill', 'var(--bg1)');
    ttBg.setAttribute('stroke', 'var(--border)');

    var textHtml = '';
    for (var i = 0; i < lines.length; i++) {
      textHtml += '<tspan x="' + (tx + 6) + '" dy="' + (i === 0 ? (ty + lineH) : lineH) + '" fill="var(--fg)">' + esc(lines[i]) + '</tspan>';
    }
    ttText.innerHTML = textHtml;
    ttGroup.setAttribute('opacity', '1');
  }

  function onLeave() {
    line.setAttribute('opacity', '0');
    ttGroup.setAttribute('opacity', '0');
  }

  area.addEventListener('mousemove', onMove);
  area.addEventListener('mouseleave', onLeave);
}

function renderGtTable(grData, cutoffs, units, isGrouped, tableIdx, selectedGroups, showTotal) {
  var results = grData.results;
  var binWidth = grData.binWidth;
  var gradeMin = grData.gradeMin;
  var totalTonnage = grData.totalTonnage;
  var td = units.tonnageDivisor;
  var gf = units.gradeFactor;
  var groupResults = isGrouped && grData.groupResults ? grData.groupResults : null;
  var allGroupNames = groupResults ? Object.keys(groupResults).sort() : [];
  var groupNames = allGroupNames;
  if (groupResults && selectedGroups && selectedGroups.size > 0) {
    groupNames = allGroupNames.filter(function(n) { return selectedGroups.has(n); });
  } else if (groupResults && selectedGroups && selectedGroups.size === 0 && !showTotal) {
    groupNames = [];
  }

  var hasGroupCol = groupNames.length > 0 || (isGrouped && showTotal);
  var gradeLabel = 'Grade' + (units.gradeSymbol ? ' (' + esc(units.gradeSymbol) + ')' : '');
  var html = '<table class="gt-table" id="gtResultTable' + tableIdx + '">';
  html += '<thead><tr>';
  if (hasGroupCol) html += '<th>Group</th>';
  html += '<th>Cutoff' + (units.gradeSymbol ? ' (' + esc(units.gradeSymbol) + ')' : '') + '</th>';
  html += '<th>Tonnage (' + esc(units.tonnageSymbol) + ')</th>';
  html += '<th>' + gradeLabel + '</th>';
  html += '<th>Metal (' + esc(units.metalSymbol) + ')</th>';
  html += '<th>% Total</th>';
  html += '</tr></thead><tbody>';

  if (hasGroupCol) {
    // "Total" block first if requested
    if (showTotal) {
      for (var ti = 0; ti < cutoffs.length; ti++) {
        var c = cutoffs[ti];
        var p = interpolateGt(results, c, binWidth, gradeMin);
        var tonnage = p.tonnage / td;
        var grade = p.grade;
        var metal = p.metal * gf / td;
        var pctTotal = totalTonnage > 0 ? (p.tonnage / totalTonnage * 100) : 0;
        html += '<tr>';
        if (ti === 0) html += '<td rowspan="' + cutoffs.length + '" style="color:var(--amber);font-weight:600">Total</td>';
        html += '<td>' + formatNum(c) + '</td>';
        html += '<td>' + formatNum(tonnage) + '</td>';
        html += '<td>' + formatNum(grade) + '</td>';
        html += '<td>' + formatNum(metal) + '</td>';
        html += '<td>' + pctTotal.toFixed(1) + '%</td>';
        html += '</tr>';
      }
    }
    // Grouped table: rows grouped by group value then cutoff
    for (var gi = 0; gi < groupNames.length; gi++) {
      var gn = groupNames[gi];
      var grd = groupResults[gn];
      for (var ci = 0; ci < cutoffs.length; ci++) {
        var c = cutoffs[ci];
        var p = interpolateGt(grd.results, c, binWidth, gradeMin);
        var tonnage = p.tonnage / td;
        var grade = p.grade;
        var metal = p.metal * gf / td;
        var pctTotal = grd.totalTonnage > 0 ? (p.tonnage / grd.totalTonnage * 100) : 0;
        html += '<tr>';
        if (ci === 0) html += '<td rowspan="' + cutoffs.length + '">' + esc(gn) + '</td>';
        html += '<td>' + formatNum(c) + '</td>';
        html += '<td>' + formatNum(tonnage) + '</td>';
        html += '<td>' + formatNum(grade) + '</td>';
        html += '<td>' + formatNum(metal) + '</td>';
        html += '<td>' + pctTotal.toFixed(1) + '%</td>';
        html += '</tr>';
      }
    }
  } else {
    // Ungrouped table
    for (var i = 0; i < cutoffs.length; i++) {
      var c = cutoffs[i];
      var p = interpolateGt(results, c, binWidth, gradeMin);
      var tonnage = p.tonnage / td;
      var grade = p.grade;
      var metal = p.metal * gf / td;
      var pctTotal = totalTonnage > 0 ? (p.tonnage / totalTonnage * 100) : 0;
      html += '<tr>';
      html += '<td>' + formatNum(c) + '</td>';
      html += '<td>' + formatNum(tonnage) + '</td>';
      html += '<td>' + formatNum(grade) + '</td>';
      html += '<td>' + formatNum(metal) + '</td>';
      html += '<td>' + pctTotal.toFixed(1) + '%</td>';
      html += '</tr>';
    }
  }
  html += '</tbody></table>';
  return html;
}

function resetGtState() {
  lastGtData = null;
  if (gtWorker) { gtWorker.terminate(); gtWorker = null; }
  if (gtExprController) { gtExprController.destroy(); gtExprController = null; }
}

// ─── Section Tab ──────────────────────────────────────────────────────

function colormap(t, scale) {
  t = Math.max(0, Math.min(1, t));
  const maps = {
    viridis: [[68,1,84],[72,35,116],[64,67,135],[52,94,141],[41,120,142],[32,144,140],[34,167,132],[68,190,112],[121,209,81],[189,222,38],[253,231,37]],
    plasma: [[13,8,135],[75,3,161],[126,3,167],[168,34,150],[199,70,117],[220,107,80],[235,146,47],[245,189,11],[244,229,37],[240,249,33]],
    inferno: [[0,0,4],[22,11,57],[66,10,104],[106,23,110],[143,41,102],[175,62,84],[204,92,55],[227,131,30],[243,177,27],[248,224,82],[252,255,164]],
    coolwarm: [[59,76,192],[98,130,234],[141,176,254],[184,208,249],[221,221,221],[245,196,173],[236,147,120],[214,96,77],[178,44,53],[140,0,31]]
  };
  const stops = maps[scale] || maps.viridis;
  const n = stops.length - 1;
  const idx = t * n;
  const i = Math.min(Math.floor(idx), n - 1);
  const f = idx - i;
  const a = stops[i], b = stops[i + 1];
  const r = Math.round(a[0] + (b[0] - a[0]) * f);
  const g = Math.round(a[1] + (b[1] - a[1]) * f);
  const bl = Math.round(a[2] + (b[2] - a[2]) * f);
  return 'rgb(' + r + ',' + g + ',' + bl + ')';
}

function renderSectionConfig(data) {
  const $bar = document.querySelector('#panelSection .section-config-bar');
  if (!$bar) return;
  const { header, colTypes, geometry } = data;
  const hasXYZ = currentXYZ.x >= 0 && currentXYZ.y >= 0 && currentXYZ.z >= 0;
  if (!hasXYZ || !geometry || !geometry.x) {
    $bar.innerHTML = '<div style="color:var(--fg-dim);font-size:0.78rem;padding:0.5rem;">Assign X/Y/Z columns in Preflight and run analysis to enable Section view.</div>';
    return;
  }
  const numCols = header.map((h, i) => ({ name: h, idx: i, type: colTypes[i] }))
    .filter(c => c.type === 'numeric' && c.idx !== currentXYZ.x && c.idx !== currentXYZ.y && c.idx !== currentXYZ.z
      && c.idx !== currentDXYZ.dx && c.idx !== currentDXYZ.dy && c.idx !== currentDXYZ.dz);
  if (numCols.length === 0) {
    $bar.innerHTML = '<div style="color:var(--fg-dim);font-size:0.78rem;padding:0.5rem;">No numeric variable columns for section coloring.</div>';
    return;
  }
  const gx = geometry.x, gy = geometry.y, gz = geometry.z;
  const axisInfo = { z: { bs: gz.blockSize, min: gz.origin, max: gz.origin + gz.extent, label: 'Z (plan)' },
                     x: { bs: gx.blockSize, min: gx.origin, max: gx.origin + gx.extent, label: 'X (east section)' },
                     y: { bs: gy.blockSize, min: gy.origin, max: gy.origin + gy.extent, label: 'Y (north section)' }};
  const defaultAxis = 'z';
  const ai = axisInfo[defaultAxis];
  const midVal = ((ai.min + ai.max) / 2).toFixed(2);
  const varOptions = numCols.map(c => '<option value="' + c.idx + '">' + esc(c.name) + '</option>').join('');

  $bar.innerHTML = `
    <label>Normal: <select id="sectionAxis">
      <option value="z">${axisInfo.z.label}</option>
      <option value="x">${axisInfo.x.label}</option>
      <option value="y">${axisInfo.y.label}</option>
    </select></label>
    <label>Slice: <input type="range" id="sectionSlider" min="${ai.min}" max="${ai.max}" step="${ai.bs}" value="${midVal}" style="width:120px">
    <span id="sectionSliceVal">${midVal}</span></label>
    <label>Tol: <input type="number" id="sectionTol" value="${ai.bs}" min="0.001" step="any" style="width:60px"></label>
    <label>Color: <select id="sectionVar">${varOptions}</select></label>
    <label>Scale: <select id="sectionScale">
      <option value="viridis">Viridis</option>
      <option value="plasma">Plasma</option>
      <option value="inferno">Inferno</option>
      <option value="coolwarm">Cool-Warm</option>
    </select></label>
    <label>Filter: <input type="text" id="sectionLocalFilter" placeholder="e.g. r.zone == 1" style="width:120px"></label>
    <label class="section-swath-toggle" id="sectionSwathToggleWrap" style="display:none"><input type="checkbox" id="sectionShowSwath"> Swath</label>
    <button class="swath-generate" id="sectionRender">Render</button>
    <button class="swath-generate" id="sectionReset" style="background:transparent;border:1px solid var(--border)">Reset View</button>`;

  // Update slider when axis changes
  const $axSel = document.getElementById('sectionAxis');
  const $slider = document.getElementById('sectionSlider');
  const $sliceVal = document.getElementById('sectionSliceVal');
  const $tol = document.getElementById('sectionTol');
  $axSel.addEventListener('change', () => {
    const a = axisInfo[$axSel.value];
    $slider.min = a.min; $slider.max = a.max; $slider.step = a.bs;
    const mid = ((a.min + a.max) / 2).toFixed(2);
    $slider.value = mid; $sliceVal.textContent = mid;
    $tol.value = a.bs;
  });
  $slider.addEventListener('input', () => { $sliceVal.textContent = parseFloat($slider.value).toFixed(2); });

  document.getElementById('sectionRender').addEventListener('click', runSection);
  document.getElementById('sectionReset').addEventListener('click', () => {
    sectionTransform = null;
    if (sectionBlocks) renderSection();
  });

  // Show swath toggle if swath data matches
  updateSectionSwathToggle();

  // Local filter autocomplete
  if (sectionExprController) sectionExprController.destroy();
  sectionExprController = createExprInput(document.getElementById('sectionLocalFilter'), { mode: 'filter' });
}

function updateSectionSwathToggle() {
  const wrap = document.getElementById('sectionSwathToggleWrap');
  if (!wrap) return;
  if (lastSwathData) {
    wrap.style.display = '';
  } else {
    wrap.style.display = 'none';
  }
}

function runSection() {
  if (sectionExprController) { const r = sectionExprController.validate(); if (!r.valid) return; }
  const axisVal = document.getElementById('sectionAxis').value;
  const slicePos = parseFloat(document.getElementById('sectionSlider').value);
  const tolerance = parseFloat(document.getElementById('sectionTol').value);
  const varCol = parseInt(document.getElementById('sectionVar').value);
  const localFilter = document.getElementById('sectionLocalFilter').value.trim();
  if (!tolerance || tolerance <= 0) return;

  if (sectionWorker) sectionWorker.terminate();
  sectionWorker = new Worker(workerUrl);

  const $progress = document.getElementById('sectionProgress');
  const $fill = document.getElementById('sectionProgressFill');
  const $label = document.getElementById('sectionProgressLabel');
  $progress.classList.add('active');
  $fill.style.width = '0%';
  $label.textContent = '0%';

  const resolvedTypes = currentColTypes.slice(0, currentOrigColCount);
  const filterPayload = currentFilter ? { expression: currentFilter.expression } : null;
  const zipEntry = preflightData ? (preflightData.selectedZipEntry || null) : null;

  const normalAxisIdx = axisVal === 'x' ? 0 : (axisVal === 'y' ? 1 : 2);
  const xyzCols = [currentXYZ.x, currentXYZ.y, currentXYZ.z];
  const dxyzCols = [currentDXYZ.dx, currentDXYZ.dy, currentDXYZ.dz];

  sectionWorker.postMessage({
    mode: 'section',
    file: currentFile,
    zipEntry,
    globalFilter: filterPayload,
    localFilter: localFilter || null,
    calcolCode: currentCalcolCode || null,
    calcolMeta: currentCalcolMeta.length > 0 ? currentCalcolMeta : null,
    resolvedTypes,
    xyzCols,
    dxyzCols,
    normalAxis: normalAxisIdx,
    slicePos,
    tolerance,
    varCol
  });

  sectionWorker.onerror = (e) => {
    $label.textContent = 'Worker error: ' + (e.message || 'unknown error');
    $label.style.color = 'var(--red)';
    setTimeout(() => { $progress.classList.remove('active'); $label.style.color = ''; }, 3000);
    sectionWorker.terminate();
    sectionWorker = null;
  };

  sectionWorker.onmessage = (e) => {
    const m = e.data;
    if (m.type === 'section-progress') {
      const pct = Math.min(99, m.percent);
      $fill.style.width = pct.toFixed(1) + '%';
      $label.textContent = pct.toFixed(0) + '%';
    } else if (m.type === 'section-complete') {
      $fill.style.width = '100%';
      $label.textContent = 'Done';
      setTimeout(() => $progress.classList.remove('active'), 800);
      sectionBlocks = m.blocks;
      sectionTransform = null;
      sectionDefaultBlockSize = null;
      if (lastGeoData) {
        const hKey = m.hAxis.toLowerCase();
        const vKey = m.vAxis.toLowerCase();
        sectionDefaultBlockSize = {
          h: lastGeoData[hKey] ? lastGeoData[hKey].blockSize : 1,
          v: lastGeoData[vKey] ? lastGeoData[vKey].blockSize : 1
        };
      }
      renderSection();
      const $info = document.getElementById('sectionInfo');
      if ($info) $info.textContent = m.blockCount.toLocaleString() + ' blocks \u00B7 ' + (m.elapsed / 1000).toFixed(1) + 's';
      // Update tab badge
      const sectionTab = document.querySelector('.results-tab[data-tab="section"]');
      if (sectionTab) sectionTab.innerHTML = 'Section <span class="tab-badge">' + m.blockCount + '</span>';
      updateSectionSwathToggle();
      sectionWorker.terminate();
      sectionWorker = null;
    } else if (m.type === 'error') {
      $label.textContent = 'Error: ' + m.message;
      $progress.classList.remove('active');
      sectionWorker.terminate();
      sectionWorker = null;
    }
  };
}

function renderSection() {
  const canvas = document.getElementById('sectionCanvas');
  if (!canvas || !sectionBlocks || sectionBlocks.length === 0) return;
  const wrap = canvas.parentElement;
  const rect = wrap.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const blocks = sectionBlocks;
  const defH = sectionDefaultBlockSize ? sectionDefaultBlockSize.h : 1;
  const defV = sectionDefaultBlockSize ? sectionDefaultBlockSize.v : 1;

  // Compute data bounds
  let dhMin = Infinity, dvMin = Infinity, hMin = Infinity, hMax = -Infinity, vMin = Infinity, vMax = -Infinity;
  let valMin = Infinity, valMax = -Infinity;
  for (const b of blocks) {
    const dh = b.dh || defH, dv = b.dv || defV;
    if (dh < dhMin) dhMin = dh;
    if (dv < dvMin) dvMin = dv;
    const bLeft = b.h - dh / 2, bRight = b.h + dh / 2;
    const bBot = b.v - dv / 2, bTop = b.v + dv / 2;
    if (bLeft < hMin) hMin = bLeft;
    if (bRight > hMax) hMax = bRight;
    if (bBot < vMin) vMin = bBot;
    if (bTop > vMax) vMax = bTop;
    if (b.val != null) {
      if (b.val < valMin) valMin = b.val;
      if (b.val > valMax) valMax = b.val;
    }
  }
  const dataW = hMax - hMin || 1;
  const dataH = vMax - vMin || 1;
  const valRange = valMax - valMin || 1;

  const colorScale = document.getElementById('sectionScale') ? document.getElementById('sectionScale').value : 'viridis';

  // Transform: fit to view or use saved transform
  let scale, offsetX, offsetY;
  if (sectionTransform) {
    scale = sectionTransform.scale;
    offsetX = sectionTransform.offsetX;
    offsetY = sectionTransform.offsetY;
  } else {
    const marginPx = 40;
    const availW = rect.width - marginPx * 2;
    const availH = rect.height - marginPx * 2;
    scale = Math.min(availW / dataW, availH / dataH);
    offsetX = (rect.width - dataW * scale) / 2 - hMin * scale;
    offsetY = (rect.height - dataH * scale) / 2 + vMax * scale; // flip Y
    sectionTransform = { scale, offsetX, offsetY };
  }

  const toScreenX = (v) => v * scale + offsetX;
  const toScreenY = (v) => -v * scale + offsetY; // flip Y

  // Clear
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0d1117';
  ctx.fillRect(0, 0, rect.width, rect.height);

  // Draw blocks
  const drawBorder = (dhMin * scale) > 4;
  for (const b of blocks) {
    const dh = b.dh || defH, dv = b.dv || defV;
    const sx = toScreenX(b.h - dh / 2);
    const sy = toScreenY(b.v + dv / 2);
    const sw = dh * scale;
    const sh = dv * scale;
    if (b.val != null) {
      const t = (b.val - valMin) / valRange;
      ctx.fillStyle = colormap(t, colorScale);
    } else {
      ctx.fillStyle = '#333';
    }
    ctx.fillRect(sx, sy, sw, sh);
    if (drawBorder) {
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(sx, sy, sw, sh);
    }
  }

  // Swath overlay
  const showSwathCb = document.getElementById('sectionShowSwath');
  if (showSwathCb && showSwathCb.checked && lastSwathData) {
    const swathAxisKey = lastSwathData.axis;
    const sectionAxisEl = document.getElementById('sectionAxis');
    const normalAxis = sectionAxisEl ? sectionAxisEl.value : 'z';
    // Determine which display axis the swath axis maps to
    let swathOnH = false, swathOnV = false;
    if (normalAxis === 'z') { // plan view: h=X, v=Y
      if (swathAxisKey === 'x') swathOnH = true;
      else if (swathAxisKey === 'y') swathOnV = true;
    } else if (normalAxis === 'x') { // h=Y, v=Z
      if (swathAxisKey === 'y') swathOnH = true;
      else if (swathAxisKey === 'z') swathOnV = true;
    } else { // normalAxis === 'y': h=X, v=Z
      if (swathAxisKey === 'x') swathOnH = true;
      else if (swathAxisKey === 'z') swathOnV = true;
    }
    if (swathOnH || swathOnV) {
      const bw = lastSwathData.binWidth;
      // Get bins from first available variable
      const firstVarKey = lastSwathData.varCols && lastSwathData.varCols.length > 0 ? lastSwathData.varCols[0] : null;
      const swathBins = firstVarKey != null && lastSwathData.vars && lastSwathData.vars[firstVarKey] ? lastSwathData.vars[firstVarKey] : [];
      const binMin = swathBins.length > 0 ? swathBins[0].center - bw / 2 : 0;
      const binMax = swathBins.length > 0 ? swathBins[swathBins.length - 1].center + bw / 2 : 0;
      ctx.save();
      ctx.globalAlpha = 0.08;
      let toggle = false;
      if (swathOnH) {
        for (let bc = binMin; bc < binMax; bc += bw) {
          if (toggle) {
            const x1 = toScreenX(bc);
            const x2 = toScreenX(bc + bw);
            ctx.fillStyle = '#fff';
            ctx.fillRect(x1, 0, x2 - x1, rect.height);
          }
          toggle = !toggle;
        }
      } else {
        for (let bc = binMin; bc < binMax; bc += bw) {
          if (toggle) {
            const y1 = toScreenY(bc + bw);
            const y2 = toScreenY(bc);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, y1, rect.width, y2 - y1);
          }
          toggle = !toggle;
        }
      }
      ctx.restore();
      // Dashed bin boundary lines
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      if (swathOnH) {
        for (let bc = binMin; bc <= binMax; bc += bw) {
          const x = toScreenX(bc);
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, rect.height); ctx.stroke();
        }
      } else {
        for (let bc = binMin; bc <= binMax; bc += bw) {
          const y = toScreenY(bc);
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(rect.width, y); ctx.stroke();
        }
      }
      ctx.restore();
    }
  }

  // Axis labels
  ctx.fillStyle = '#6a737d';
  ctx.font = '11px ' + (getComputedStyle(document.documentElement).getPropertyValue('--mono').trim() || 'monospace');
  ctx.textAlign = 'center';
  // H-axis ticks
  const hSteps = Math.min(10, Math.ceil(dataW / (defH * 5)));
  const hStep = dataW / hSteps;
  for (let i = 0; i <= hSteps; i++) {
    const v = hMin + hStep * i;
    const x = toScreenX(v);
    ctx.fillText(formatNum(v), x, rect.height - 4);
  }
  // V-axis ticks
  ctx.textAlign = 'right';
  const vSteps = Math.min(10, Math.ceil(dataH / (defV * 5)));
  const vStep = dataH / vSteps;
  for (let i = 0; i <= vSteps; i++) {
    const v = vMin + vStep * i;
    const y = toScreenY(v);
    ctx.fillText(formatNum(v), pad ? 36 : 36, y + 3);
  }

  // Render colorbar
  renderColorbar(valMin, valMax, colorScale);
}

function renderColorbar(valMin, valMax, scale) {
  const $cbWrap = document.getElementById('sectionColorbar');
  if (!$cbWrap) return;
  const cb = document.getElementById('sectionColorbarCanvas');
  if (!cb) return;
  const h = $cbWrap.getBoundingClientRect().height - 40;
  cb.width = 20;
  cb.height = Math.max(h, 100);
  cb.style.width = '20px';
  cb.style.height = cb.height + 'px';
  const ctx = cb.getContext('2d');
  for (let i = 0; i < cb.height; i++) {
    const t = 1 - i / cb.height;
    ctx.fillStyle = colormap(t, scale);
    ctx.fillRect(0, i, 20, 1);
  }
  // Labels
  let labels = $cbWrap.querySelectorAll('.cb-label');
  labels.forEach(l => l.remove());
  const mkLabel = (text, top) => {
    const span = document.createElement('span');
    span.className = 'cb-label';
    span.style.cssText = 'position:absolute;right:24px;font-size:9px;color:#6a737d;' + (top ? 'top:0' : 'bottom:0');
    span.textContent = text;
    $cbWrap.appendChild(span);
  };
  mkLabel(formatNum(valMax), true);
  mkLabel(formatNum(valMin), false);
}

function wireSectionInteraction() {
  const canvas = document.getElementById('sectionCanvas');
  if (!canvas) return;

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (!sectionTransform || !sectionBlocks) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
    const newScale = sectionTransform.scale * factor;
    sectionTransform.offsetX = mx - (mx - sectionTransform.offsetX) * factor;
    sectionTransform.offsetY = my - (my - sectionTransform.offsetY) * factor;
    sectionTransform.scale = newScale;
    renderSection();
  }, { passive: false });

  let dragging = false, dragStartX = 0, dragStartY = 0, dragOX = 0, dragOY = 0;
  canvas.addEventListener('mousedown', (e) => {
    if (!sectionTransform) return;
    dragging = true;
    dragStartX = e.clientX; dragStartY = e.clientY;
    dragOX = sectionTransform.offsetX; dragOY = sectionTransform.offsetY;
    canvas.style.cursor = 'grabbing';
  });
  window.addEventListener('mousemove', (e) => {
    if (dragging && sectionTransform) {
      sectionTransform.offsetX = dragOX + (e.clientX - dragStartX);
      sectionTransform.offsetY = dragOY + (e.clientY - dragStartY);
      renderSection();
    } else if (!dragging && sectionBlocks && sectionTransform) {
      // Hover tooltip
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      if (mx < 0 || my < 0 || mx > rect.width || my > rect.height) {
        const tip = document.getElementById('sectionTooltip');
        if (tip) tip.style.display = 'none';
        return;
      }
      // Reverse transform
      const dataX = (mx - sectionTransform.offsetX) / sectionTransform.scale;
      const dataY = -(my - sectionTransform.offsetY) / sectionTransform.scale;
      const defH = sectionDefaultBlockSize ? sectionDefaultBlockSize.h : 1;
      const defV = sectionDefaultBlockSize ? sectionDefaultBlockSize.v : 1;
      let found = null;
      for (const b of sectionBlocks) {
        const dh = b.dh || defH, dv = b.dv || defV;
        if (dataX >= b.h - dh / 2 && dataX <= b.h + dh / 2 &&
            dataY >= b.v - dv / 2 && dataY <= b.v + dv / 2) {
          found = b;
          break;
        }
      }
      const tip = document.getElementById('sectionTooltip');
      if (tip) {
        if (found) {
          tip.style.display = 'block';
          tip.style.left = (mx + 12) + 'px';
          tip.style.top = (my - 8) + 'px';
          tip.textContent = 'H=' + formatNum(found.h) + ' V=' + formatNum(found.v) + (found.val != null ? ' Val=' + formatNum(found.val) : '');
        } else {
          tip.style.display = 'none';
        }
      }
    }
  });
  window.addEventListener('mouseup', () => {
    dragging = false;
    canvas.style.cursor = 'crosshair';
  });

  // ResizeObserver for canvas
  const wrap = canvas.parentElement;
  if (wrap && typeof ResizeObserver !== 'undefined') {
    new ResizeObserver(() => {
      if (sectionBlocks) renderSection();
    }).observe(wrap);
  }
}
wireSectionInteraction();

function renderCDFModal(s, name) {
  $cdfTitle.textContent = 'CDF \u2014 ' + name;
  $cdfModal.classList.add('active');

  const centroids = s.centroids;
  const totalCount = s.count;
  const points = [];
  let cumCount = 0;
  for (const [mean, count] of centroids) {
    cumCount += count;
    points.push({ x: mean, y: cumCount / totalCount });
  }

  const W = 660, H = 360;
  const pad = { top: 20, right: 30, bottom: 50, left: 60 };
  const plotW = W - pad.left - pad.right;
  const plotH = H - pad.top - pad.bottom;

  const xMin = s.min, xMax = s.max;
  const xRange = xMax - xMin || 1;

  function sx(v) { return pad.left + ((v - xMin) / xRange) * plotW; }
  function sy(v) { return pad.top + (1 - v) * plotH; }

  const pathParts = points.map((p, i) => (i === 0 ? 'M' : 'L') + sx(p.x).toFixed(1) + ',' + sy(p.y).toFixed(1));
  const pathD = pathParts.join(' ');

  const yTicks = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0];
  let gridSvg = '';
  for (const yt of yTicks) {
    const y = sy(yt);
    gridSvg += '<line x1="' + pad.left + '" y1="' + y + '" x2="' + (W - pad.right) + '" y2="' + y + '" stroke="#1e2228" stroke-width="1"/>';
    gridSvg += '<text x="' + (pad.left - 8) + '" y="' + (y + 3.5) + '" text-anchor="end" fill="#6a737d" font-size="10">' + (yt * 100).toFixed(0) + '%</text>';
  }

  const nxTicks = 6;
  for (let i = 0; i <= nxTicks; i++) {
    const v = xMin + (xRange * i / nxTicks);
    const x = sx(v);
    gridSvg += '<line x1="' + x + '" y1="' + pad.top + '" x2="' + x + '" y2="' + (H - pad.bottom) + '" stroke="#1e2228" stroke-width="1"/>';
    const label = Math.abs(v) >= 1e5 || (Math.abs(v) < 0.01 && v !== 0) ? v.toExponential(1) : v.toFixed(Math.abs(v) < 10 ? 2 : 0);
    gridSvg += '<text x="' + x + '" y="' + (H - pad.bottom + 16) + '" text-anchor="middle" fill="#6a737d" font-size="10">' + label + '</text>';
  }

  const q = s.quantiles;
  let markerSvg = '';
  if (q) {
    const pctiles = [
      { v: q.p10, label: 'P10' }, { v: q.p25, label: 'P25' },
      { v: q.p50, label: 'P50' }, { v: q.p75, label: 'P75' },
      { v: q.p90, label: 'P90' }
    ];
    for (const p of pctiles) {
      if (p.v === null || p.v === undefined) continue;
      const x = sx(p.v);
      const pVal = parseFloat(p.label.slice(1)) / 100;
      const y = sy(pVal);
      markerSvg += '<circle cx="' + x + '" cy="' + y + '" r="3" fill="#f0b232"/>';
    }
  }
  if (s.mean !== null) {
    const mx = sx(s.mean);
    markerSvg += '<line x1="' + mx + '" y1="' + pad.top + '" x2="' + mx + '" y2="' + (H - pad.bottom) + '" stroke="#58a6ff" stroke-width="1" stroke-dasharray="4,3"/>';
    markerSvg += '<text x="' + mx + '" y="' + (H - pad.bottom + 30) + '" text-anchor="middle" fill="#58a6ff" font-size="9">mean</text>';
  }

  const svg = '<svg viewBox="0 0 ' + W + ' ' + H + '" xmlns="http://www.w3.org/2000/svg" style="font-family:var(--mono)">' +
    '<rect width="' + W + '" height="' + H + '" fill="var(--bg)" rx="4"/>' +
    gridSvg +
    '<path d="' + pathD + '" fill="none" stroke="var(--amber)" stroke-width="1.5"/>' +
    markerSvg +
    '<text x="' + (W / 2) + '" y="' + (H - 4) + '" text-anchor="middle" fill="#6a737d" font-size="10">' + esc(name) + '</text>' +
    '<text x="12" y="' + (H / 2) + '" text-anchor="middle" fill="#6a737d" font-size="10" transform="rotate(-90, 12, ' + (H / 2) + ')">Cumulative %</text>' +
    '</svg>';

  const cv = (s.mean && s.std && s.mean !== 0) ? Math.abs(s.std / s.mean * 100) : null;
  const zeroPct = s.count > 0 ? (s.zeros / s.count * 100) : 0;
  let statsHtml = '<div class="cdf-stats">';
  statsHtml += '<span>n=<strong>' + s.count.toLocaleString() + '</strong></span>';
  if (s.nulls > 0) statsHtml += '<span>nulls=<strong>' + s.nulls.toLocaleString() + '</strong></span>';
  if (s.zeros > 0) statsHtml += '<span>zeros=<strong>' + s.zeros.toLocaleString() + '</strong> (' + zeroPct.toFixed(1) + '%)</span>';
  statsHtml += '<span>min=<strong>' + formatNum(s.min) + '</strong></span>';
  if (q) statsHtml += '<span>P50=<strong>' + formatNum(q.p50) + '</strong></span>';
  statsHtml += '<span>mean=<strong>' + formatNum(s.mean) + '</strong></span>';
  statsHtml += '<span>max=<strong>' + formatNum(s.max) + '</strong></span>';
  if (cv !== null) statsHtml += '<span>CV=<strong>' + cv.toFixed(1) + '%</strong></span>';
  if (s.skewness !== null) statsHtml += '<span>skew=<strong>' + s.skewness.toFixed(2) + '</strong></span>';
  statsHtml += '</div>';

  $cdfBody.innerHTML = svg + statsHtml;
}

function renderXYZConfig(header, colTypes, xyzGuess) {
  const label = (axis) => {
    const idx = currentXYZ[axis];
    const name = idx >= 0 ? esc(header[idx]) : '—';
    return `<label><span class="axis-label">${axis.toUpperCase()}:</span> <span class="axis-value">${name}</span></label>`;
  };
  $xyzConfig.innerHTML = label('x') + label('y') + label('z');
}

// ─── Calcol UI — Code Editor with Variable Browser ───────────────────

const MATH_PREAMBLE_MAIN = 'const {abs,sqrt,pow,log,log2,log10,exp,min,max,round,floor,ceil,sign,trunc,hypot,sin,cos,tan,asin,acos,atan,atan2,PI,E}=Math;const fn={cap:(v,lo,hi)=>v==null?null:hi===undefined?Math.min(v,lo):Math.min(Math.max(v,lo),hi),ifnull:(v,d)=>(v==null||v!==v)?d:v,between:(v,lo,hi)=>v!=null&&v>=lo&&v<=hi,remap:(v,m,d)=>m.hasOwnProperty(v)?m[v]:(d!==undefined?d:null),round:(v,n)=>{const f=Math.pow(10,n||0);return Math.round(v*f)/f;},clamp:(v,lo,hi)=>Math.min(Math.max(v,lo),hi),isnum:(v)=>Number.isFinite(v),ifnum:(v,d)=>Number.isFinite(v)?v:(d!==undefined?d:NaN)};const clamp=fn.clamp;const cap=fn.cap;const ifnull=fn.ifnull;const between=fn.between;const remap=fn.remap;const isnum=fn.isnum;const ifnum=fn.ifnum;';

// Math functions available in expressions (for autocomplete and sidebar)
const MATH_COMPLETIONS = [
  { label: 'abs(x)', insert: 'abs(', desc: 'absolute value' },
  { label: 'sqrt(x)', insert: 'sqrt(', desc: 'square root' },
  { label: 'pow(x, n)', insert: 'pow(', desc: 'x to the power n' },
  { label: 'log(x)', insert: 'log(', desc: 'natural log' },
  { label: 'log2(x)', insert: 'log2(', desc: 'log base 2' },
  { label: 'log10(x)', insert: 'log10(', desc: 'log base 10' },
  { label: 'exp(x)', insert: 'exp(', desc: 'e^x' },
  { label: 'min(a, b)', insert: 'min(', desc: 'minimum' },
  { label: 'max(a, b)', insert: 'max(', desc: 'maximum' },
  { label: 'round(x)', insert: 'round(', desc: 'round to integer' },
  { label: 'floor(x)', insert: 'floor(', desc: 'round down' },
  { label: 'ceil(x)', insert: 'ceil(', desc: 'round up' },
  { label: 'sign(x)', insert: 'sign(', desc: '-1, 0, or 1' },
  { label: 'trunc(x)', insert: 'trunc(', desc: 'integer part' },
  { label: 'clamp(v, lo, hi)', insert: 'clamp(', desc: 'constrain to range' },
  { label: 'cap(v, hi)', insert: 'cap(', desc: 'cap at maximum' },
  { label: 'ifnull(v, default)', insert: 'ifnull(', desc: 'default for null/NaN' },
  { label: 'ifnum(v, default)', insert: 'ifnum(', desc: 'default for non-finite' },
  { label: 'isnum(v)', insert: 'isnum(', desc: 'true if finite number' },
  { label: 'between(v, lo, hi)', insert: 'between(', desc: 'boolean range test' },
  { label: 'remap(v, map)', insert: 'remap(', desc: 'lookup table' },
  { label: 'fn.round(v, n)', insert: 'fn.round(', desc: 'round to n decimals' },
  { label: 'PI', insert: 'PI', desc: '3.14159...' },
  { label: 'E', insert: 'E', desc: '2.71828...' },
];

// ── Syntax Highlighter ────────────────────────────────────────────────
const HL_KEYWORDS = new Set(['if','else','for','while','do','switch','case','break','continue','return','const','let','var','of','in','new','typeof','instanceof','null','undefined','true','false','NaN','Infinity']);
const HL_BUILTINS = new Set(['abs','sqrt','pow','log','log2','log10','exp','min','max','round','floor','ceil','sign','trunc','hypot','clamp','cap','ifnull','ifnum','isnum','between','remap','PI','E','fn','String','Number','Boolean','parseInt','parseFloat','isNaN','isFinite','Math']);

function highlightCode(code) {
  if (!code) return '\n'; // ensure pre has content for sizing
  const rv = currentRowVar || 'r';
  let html = '';
  let i = 0;
  const len = code.length;
  while (i < len) {
    const ch = code[i];
    // Comments
    if (ch === '/' && i + 1 < len && code[i + 1] === '/') {
      let end = code.indexOf('\n', i);
      if (end < 0) end = len;
      html += '<span class="hl-comment">' + esc(code.substring(i, end)) + '</span>';
      i = end;
      continue;
    }
    if (ch === '/' && i + 1 < len && code[i + 1] === '*') {
      let end = code.indexOf('*/', i + 2);
      if (end < 0) end = len; else end += 2;
      html += '<span class="hl-comment">' + esc(code.substring(i, end)) + '</span>';
      i = end;
      continue;
    }
    // Strings
    if (ch === "'" || ch === '"' || ch === '`') {
      let j = i + 1;
      while (j < len && code[j] !== ch) {
        if (code[j] === '\\') j++;
        j++;
      }
      if (j < len) j++;
      html += '<span class="hl-string">' + esc(code.substring(i, j)) + '</span>';
      i = j;
      continue;
    }
    // Numbers
    if ((ch >= '0' && ch <= '9') || (ch === '.' && i + 1 < len && code[i + 1] >= '0' && code[i + 1] <= '9')) {
      let j = i;
      if (ch === '0' && j + 1 < len && (code[j + 1] === 'x' || code[j + 1] === 'X')) {
        j += 2;
        while (j < len && /[0-9a-fA-F]/.test(code[j])) j++;
      } else {
        while (j < len && ((code[j] >= '0' && code[j] <= '9') || code[j] === '.')) j++;
        if (j < len && (code[j] === 'e' || code[j] === 'E')) {
          j++;
          if (j < len && (code[j] === '+' || code[j] === '-')) j++;
          while (j < len && code[j] >= '0' && code[j] <= '9') j++;
        }
      }
      html += '<span class="hl-number">' + esc(code.substring(i, j)) + '</span>';
      i = j;
      continue;
    }
    // Identifiers / keywords / r. access
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_' || ch === '$') {
      let j = i + 1;
      while (j < len && ((code[j] >= 'a' && code[j] <= 'z') || (code[j] >= 'A' && code[j] <= 'Z') || (code[j] >= '0' && code[j] <= '9') || code[j] === '_' || code[j] === '$')) j++;
      const word = code.substring(i, j);
      if (word === rv && j < len && (code[j] === '.' || code[j] === '[')) {
        // r.xxx or r[...] — highlight as row access
        let end = j;
        if (code[j] === '.') {
          end++;
          while (end < len && ((code[end] >= 'a' && code[end] <= 'z') || (code[end] >= 'A' && code[end] <= 'Z') || (code[end] >= '0' && code[end] <= '9') || code[end] === '_')) end++;
        } else if (code[j] === '[') {
          end++;
          let depth = 1;
          while (end < len && depth > 0) {
            if (code[end] === '[') depth++;
            else if (code[end] === ']') depth--;
            if (depth > 0) end++;
          }
          if (end < len) end++;
        }
        html += '<span class="hl-rowaccess">' + esc(code.substring(i, end)) + '</span>';
        i = end;
      } else if (HL_KEYWORDS.has(word)) {
        html += '<span class="hl-keyword">' + esc(word) + '</span>';
        i = j;
      } else if (HL_BUILTINS.has(word)) {
        html += '<span class="hl-function">' + esc(word) + '</span>';
        i = j;
      } else {
        html += '<span class="hl-text">' + esc(word) + '</span>';
        i = j;
      }
      continue;
    }
    // Operators
    if ('=<>!&|+-*/%?:'.indexOf(ch) >= 0) {
      html += '<span class="hl-operator">' + esc(ch) + '</span>';
      i++;
      continue;
    }
    // Punctuation (semicolons, brackets, commas, dots)
    if (';{}()[],'.indexOf(ch) >= 0) {
      html += '<span class="hl-punct">' + esc(ch) + '</span>';
      i++;
      continue;
    }
    // Standalone dot (method calls, etc.)
    if (ch === '.') {
      html += '<span class="hl-punct">.</span>';
      i++;
      continue;
    }
    // Whitespace and other chars
    html += esc(ch);
    i++;
  }
  return html + '\n'; // trailing newline keeps pre sized correctly
}

// ── Code Editor Controller ────────────────────────────────────────────
let calcolSimTimer = null;

function syncCodeHighlight() {
  $calcolCodePre.innerHTML = highlightCode($calcolCodeArea.value);
}

function syncCodeScroll() {
  $calcolCodePre.scrollTop = $calcolCodeArea.scrollTop;
  $calcolCodePre.scrollLeft = $calcolCodeArea.scrollLeft;
}

// ── Calcol Autocomplete ──────────────────────────────────────────────
var calcolAcItems = [];
var calcolAcSelected = -1;
var calcolAcMirror = null;

function getEditorTokenAtCursor() {
  var pos = $calcolCodeArea.selectionStart;
  var text = $calcolCodeArea.value.substring(0, pos);
  // Only scan current line
  var lineStart = text.lastIndexOf('\n') + 1;
  var lineText = text.substring(lineStart);
  var rv = currentRowVar || 'r';
  var pat = new RegExp('(?:' + rv.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\.)?([a-zA-Z_][a-zA-Z0-9_]*)$');
  var match = lineText.match(pat);
  if (!match) return { token: '', start: pos, hasPrefix: false, fullLen: 0 };
  var full = match[0];
  var hasPrefix = full.indexOf(rv + '.') === 0;
  var token = match[1];
  var start = pos - full.length;
  return { token: token, start: start, hasPrefix: hasPrefix, fullLen: full.length };
}

function calcolAcPosition() {
  // Create mirror div to measure cursor position
  if (!calcolAcMirror) {
    calcolAcMirror = document.createElement('div');
    calcolAcMirror.style.cssText = 'position:absolute;top:0;left:0;visibility:hidden;white-space:pre-wrap;word-wrap:break-word;overflow:hidden;pointer-events:none;';
    document.body.appendChild(calcolAcMirror);
  }
  var cs = getComputedStyle($calcolCodeArea);
  calcolAcMirror.style.fontFamily = cs.fontFamily;
  calcolAcMirror.style.fontSize = cs.fontSize;
  calcolAcMirror.style.lineHeight = cs.lineHeight;
  calcolAcMirror.style.padding = cs.padding;
  calcolAcMirror.style.tabSize = cs.tabSize;
  calcolAcMirror.style.width = $calcolCodeArea.clientWidth + 'px';

  var pos = $calcolCodeArea.selectionStart;
  var textBefore = $calcolCodeArea.value.substring(0, pos);
  calcolAcMirror.textContent = '';
  // Split into pre-text and marker
  var textNode = document.createTextNode(textBefore);
  var marker = document.createElement('span');
  marker.textContent = '|';
  calcolAcMirror.appendChild(textNode);
  calcolAcMirror.appendChild(marker);

  var wrap = $calcolCodeArea.parentElement; // .calcol-code-wrap
  var markerTop = marker.offsetTop;
  var markerLeft = marker.offsetLeft;

  // Adjust for textarea scroll
  var top = markerTop - $calcolCodeArea.scrollTop;
  var left = markerLeft - $calcolCodeArea.scrollLeft;

  // Position popup below cursor line
  var lineHeight = parseFloat(cs.lineHeight) || parseFloat(cs.fontSize) * 1.6;
  $calcolAc.style.top = (top + lineHeight) + 'px';
  $calcolAc.style.left = Math.min(left, wrap.clientWidth - 220) + 'px';
}

function calcolAcShow() {
  var tok = getEditorTokenAtCursor();
  if (!tok.token || tok.token.length < 1) { calcolAcHide(); return; }
  var lc = tok.token.toLowerCase();
  calcolAcItems = buildExprAcItems().filter(function(it) {
    var target = it.kind === 'col' || it.kind === 'calc' ? it.label : it.insert;
    return target.toLowerCase().indexOf(lc) === 0 || it.label.toLowerCase().indexOf(lc) === 0;
  }).slice(0, 10);
  if (calcolAcItems.length === 0) { calcolAcHide(); return; }
  calcolAcSelected = 0;
  calcolAcRender();
  calcolAcPosition();
  $calcolAc.classList.add('open');
}

function calcolAcHide() {
  $calcolAc.classList.remove('open');
  calcolAcItems = [];
  calcolAcSelected = -1;
}

function calcolAcRender() {
  $calcolAc.innerHTML = calcolAcItems.map(function(it, i) {
    var cls = it.kind === 'col' ? 'ac-col' : it.kind === 'calc' ? 'ac-calc' : 'ac-fn';
    return '<div class="ac-item ' + cls + (i === calcolAcSelected ? ' selected' : '') + '" data-idx="' + i + '">' +
      '<span class="ac-label">' + esc(it.label) + '</span>' +
      (it.desc ? '<span class="ac-desc">' + esc(it.desc) + '</span>' : '') +
      '</div>';
  }).join('');
  $calcolAc.querySelectorAll('.ac-item').forEach(function(el) {
    el.addEventListener('mousedown', function(e) {
      e.preventDefault();
      calcolAcAccept(parseInt(el.dataset.idx));
    });
  });
}

function calcolAcAccept(idx) {
  var item = calcolAcItems[idx];
  if (!item) return;
  var tok = getEditorTokenAtCursor();
  $calcolCodeArea.focus();
  $calcolCodeArea.selectionStart = tok.start;
  $calcolCodeArea.selectionEnd = tok.start + tok.fullLen;
  document.execCommand('insertText', false, item.insert);
  calcolAcHide();
  currentCalcolCode = $calcolCodeArea.value;
  syncCodeHighlight();
  clearTimeout(calcolSimTimer);
  calcolSimTimer = setTimeout(simulateCalcol, 600);
  markAnalysisStale();
}

function calcolAcIsOpen() {
  return $calcolAc.classList.contains('open') && calcolAcItems.length > 0;
}

function initCalcolEditor() {
  // Sync highlight on input
  $calcolCodeArea.addEventListener('input', function() {
    syncCodeHighlight();
    currentCalcolCode = $calcolCodeArea.value;
    $calcolError.textContent = '';
    clearTimeout(calcolSimTimer);
    calcolSimTimer = setTimeout(simulateCalcol, 600);
    markAnalysisStale();
    autoSaveProject();
    calcolAcShow();
  });

  // Sync scroll — also reposition autocomplete
  $calcolCodeArea.addEventListener('scroll', function() {
    syncCodeScroll();
    if (calcolAcIsOpen()) calcolAcPosition();
  });

  // Keyboard handling
  $calcolCodeArea.addEventListener('keydown', function(e) {
    // Autocomplete navigation
    if (calcolAcIsOpen()) {
      if (e.key === 'ArrowDown') { e.preventDefault(); calcolAcSelected = (calcolAcSelected + 1) % calcolAcItems.length; calcolAcRender(); return; }
      if (e.key === 'ArrowUp') { e.preventDefault(); calcolAcSelected = (calcolAcSelected - 1 + calcolAcItems.length) % calcolAcItems.length; calcolAcRender(); return; }
      if (e.key === 'Enter' || (e.key === 'Tab' && calcolAcSelected >= 0)) { e.preventDefault(); calcolAcAccept(calcolAcSelected); return; }
      if (e.key === 'Escape') { e.preventDefault(); calcolAcHide(); return; }
    }
    // Tab key inserts 2 spaces (when autocomplete not open)
    if (e.key === 'Tab') {
      e.preventDefault();
      document.execCommand('insertText', false, '  ');
      syncCodeHighlight();
      currentCalcolCode = this.value;
    }
    // Ctrl+Space triggers autocomplete
    if (e.key === ' ' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      calcolAcShow();
    }
  });

  // Dismiss autocomplete on blur
  $calcolCodeArea.addEventListener('blur', function() {
    setTimeout(calcolAcHide, 150);
  });

  // Simulate button
  $calcolSimBtn.addEventListener('click', simulateCalcol);

  // Render function list in sidebar
  renderFunctionList();

  // Initial highlight
  syncCodeHighlight();
}

// ── Variable Browser ──────────────────────────────────────────────────
function renderVariableBrowser() {
  var hdr = preflightData ? preflightData.header : currentHeader;
  var types = preflightData ? (preflightData.autoTypes || []) : currentColTypes;
  var typeOv = preflightData ? (preflightData.typeOverrides || {}) : {};
  if (!hdr || hdr.length === 0) {
    $calcolVarList.innerHTML = '<div class="calcol-empty-hint">No file loaded.</div>';
    return;
  }
  var search = $calcolVarSearch.value.toLowerCase();
  var stats = lastCompleteData ? lastCompleteData.stats : null;
  var cats = lastCompleteData ? lastCompleteData.categories : null;
  var rv = currentRowVar || 'r';
  var html = '';
  for (var i = 0; i < hdr.length; i++) {
    var name = hdr[i];
    if (search && !fuzzyMatch(search, name.toLowerCase())) continue;
    var type = typeOv[i] || types[i] || 'numeric';
    var isNum = type === 'numeric';
    var typeTag = isNum ? '<span class="cv-type num">NUM</span>' : '<span class="cv-type cat">CAT</span>';
    html += '<div class="calcol-var-item" data-idx="' + i + '" data-name="' + esc(name) + '">';
    html += '<span class="cv-toggle" data-idx="' + i + '">\u25B8</span>';
    html += '<span class="cv-name">' + esc(name) + '</span>';
    html += typeTag;
    html += '</div>';
    // Detail panel (hidden by default)
    html += '<div class="calcol-var-detail" id="cvDetail' + i + '">';
    if (stats && stats[i] && isNum) {
      var s = stats[i];
      html += '<div class="cv-stat"><span class="cv-stat-label">min:</span><span class="cv-stat-value">' + formatNum(s.min) + '</span></div>';
      html += '<div class="cv-stat"><span class="cv-stat-label">max:</span><span class="cv-stat-value">' + formatNum(s.max) + '</span></div>';
      html += '<div class="cv-stat"><span class="cv-stat-label">mean:</span><span class="cv-stat-value">' + formatNum(s.mean) + '</span></div>';
      html += '<div class="cv-stat"><span class="cv-stat-label">nulls:</span><span class="cv-stat-value">' + s.nulls + '</span></div>';
    } else if (cats && cats[i] && !isNum) {
      var entries = Object.entries(cats[i].counts).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 8);
      for (var ei = 0; ei < entries.length; ei++) {
        html += '<div class="cv-cat-val" data-val="' + esc(entries[ei][0]) + '">' + esc(entries[ei][0]) + ' <span style="color:var(--fg-dim)">(' + entries[ei][1] + ')</span></div>';
      }
    } else {
      html += '<div style="color:var(--fg-dim)">Run analysis for stats</div>';
    }
    html += '</div>';
  }
  $calcolVarList.innerHTML = html;

  // Wire click events
  $calcolVarList.querySelectorAll('.calcol-var-item').forEach(function(el) {
    // Click on name inserts r.colName at cursor
    el.querySelector('.cv-name').addEventListener('click', function() {
      var name = el.dataset.name;
      var insert = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name) ? rv + '.' + name : rv + '["' + name + '"]';
      insertAtCursor(insert);
    });
    // Click on toggle expands detail
    el.querySelector('.cv-toggle').addEventListener('click', function(e) {
      e.stopPropagation();
      var idx = el.dataset.idx;
      var detail = document.getElementById('cvDetail' + idx);
      var isOpen = detail.classList.contains('open');
      // Close all first
      $calcolVarList.querySelectorAll('.calcol-var-detail.open').forEach(function(d) { d.classList.remove('open'); });
      $calcolVarList.querySelectorAll('.cv-toggle').forEach(function(t) { t.textContent = '\u25B8'; });
      if (!isOpen) {
        detail.classList.add('open');
        this.textContent = '\u25BE';
      }
    });
  });

  // Wire category value clicks to insert literals
  $calcolVarList.querySelectorAll('.cv-cat-val').forEach(function(el) {
    el.addEventListener('click', function() {
      insertAtCursor("'" + el.dataset.val.replace(/'/g, "\\'") + "'");
    });
  });
}

function renderFunctionList() {
  var html = '';
  for (var i = 0; i < MATH_COMPLETIONS.length; i++) {
    var m = MATH_COMPLETIONS[i];
    html += '<div class="calcol-fn-item" data-insert="' + esc(m.insert) + '">';
    html += '<span class="cfn-name">' + esc(m.label) + '</span>';
    html += '<span class="cfn-desc">' + esc(m.desc) + '</span>';
    html += '</div>';
  }
  $calcolFnList.innerHTML = html;
  $calcolFnList.querySelectorAll('.calcol-fn-item').forEach(function(el) {
    el.addEventListener('click', function() {
      insertAtCursor(el.dataset.insert);
    });
  });
}

function insertAtCursor(text) {
  $calcolCodeArea.focus();
  document.execCommand('insertText', false, text);
  currentCalcolCode = $calcolCodeArea.value;
  syncCodeHighlight();
  clearTimeout(calcolSimTimer);
  calcolSimTimer = setTimeout(simulateCalcol, 600);
  markAnalysisStale();
}

// Variable search
if ($calcolVarSearch) {
  $calcolVarSearch.addEventListener('input', renderVariableBrowser);
}

// ── Simulate / Preview ────────────────────────────────────────────────
function getSampleRows() {
  var src = $calcolDataSrc ? $calcolDataSrc.value : 'preflight';
  if (src === 'simulated' && lastCompleteData) {
    return generateSyntheticRows();
  }
  // Preflight sample rows
  if (!preflightData || !preflightData.sampleRows) return [];
  var hdr = preflightData.header;
  var autoTypes = preflightData.autoTypes || [];
  var typeOv = preflightData.typeOverrides || {};
  var rv = currentRowVar || 'r';
  return preflightData.sampleRows.slice(0, 10).map(function(fields) {
    var obj = {};
    for (var i = 0; i < hdr.length; i++) {
      var raw = (fields[i] || '').trim().replace(/^["']|["']$/g, '');
      var type = typeOv[i] || autoTypes[i];
      obj[hdr[i]] = type === 'numeric' ? (raw === '' ? null : (isNaN(Number(raw)) ? raw : Number(raw))) : raw;
    }
    return obj;
  });
}

function generateSyntheticRows() {
  if (!lastCompleteData) return [];
  var data = lastCompleteData;
  var hdr = data.header;
  var colTypes = data.colTypes;
  var stats = data.stats;
  var cats = data.categories;
  var origCount = data.origColCount || hdr.length;
  var rows = [];
  for (var ri = 0; ri < 20; ri++) {
    var obj = {};
    for (var ci = 0; ci < origCount; ci++) {
      var name = hdr[ci];
      if (colTypes[ci] === 'numeric' && stats[ci]) {
        var s = stats[ci];
        if (s.centroids && s.centroids.length > 0) {
          // Weighted random from t-digest centroids
          var total = s.centroids.reduce(function(a, c) { return a + c[1]; }, 0);
          var r = Math.random() * total;
          var cum = 0;
          for (var k = 0; k < s.centroids.length; k++) {
            cum += s.centroids[k][1];
            if (r <= cum) { obj[name] = s.centroids[k][0]; break; }
          }
          if (obj[name] === undefined) obj[name] = s.mean;
        } else {
          obj[name] = s.mean;
        }
      } else if (colTypes[ci] === 'categorical' && cats[ci]) {
        var entries = Object.entries(cats[ci].counts);
        if (entries.length > 0) {
          var total2 = entries.reduce(function(a, e) { return a + e[1]; }, 0);
          var r2 = Math.random() * total2;
          var cum2 = 0;
          for (var k2 = 0; k2 < entries.length; k2++) {
            cum2 += entries[k2][1];
            if (r2 <= cum2) { obj[name] = entries[k2][0]; break; }
          }
          if (obj[name] === undefined) obj[name] = entries[0][0];
        } else {
          obj[name] = '';
        }
      } else {
        obj[name] = null;
      }
    }
    rows.push(obj);
  }
  return rows;
}

function simulateCalcol() {
  var code = currentCalcolCode.trim();
  if (!code) {
    currentCalcolMeta = [];
    $calcolDetected.innerHTML = '<div class="calcol-empty-hint">Write code and click Simulate to detect new columns.</div>';
    $calcolPreviewTable.innerHTML = '<div class="calcol-empty-hint">No preview yet.</div>';
    $calcolError.textContent = '';
    updateCalcolBadge();
    return;
  }

  var rv = currentRowVar || 'r';
  var hdr = preflightData ? preflightData.header : currentHeader;
  if (!hdr || hdr.length === 0) {
    $calcolError.textContent = 'No file loaded — load a CSV first.';
    return;
  }
  var origKeys = new Set(hdr);

  // Compile
  var calcolFn;
  try {
    calcolFn = new Function(rv, MATH_PREAMBLE_MAIN + code);
  } catch(e) {
    $calcolError.textContent = 'Syntax: ' + e.message;
    return;
  }

  // Run against sample rows
  var rows = getSampleRows();
  if (rows.length === 0) {
    $calcolError.textContent = 'No sample rows available.';
    return;
  }

  var detectedKeys = new Set();
  var previewRows = [];
  var errors = [];
  var metaCat = new Set();
  var metaNum = new Set();
  for (var ri = 0; ri < rows.length; ri++) {
    var obj = Object.assign({}, rows[ri]);
    obj.META = { cat: [], num: [] };
    try {
      calcolFn(obj);
    } catch(e) {
      if (errors.length < 3) errors.push('Row ' + (ri + 1) + ': ' + e.message);
      delete obj.META;
      previewRows.push(obj);
      continue;
    }
    // Collect META type overrides
    if (obj.META) {
      for (var mi2 = 0; mi2 < obj.META.cat.length; mi2++) metaCat.add(obj.META.cat[mi2]);
      for (var mi3 = 0; mi3 < obj.META.num.length; mi3++) metaNum.add(obj.META.num[mi3]);
    }
    delete obj.META;
    // Detect new keys
    var keys = Object.keys(obj);
    for (var ki = 0; ki < keys.length; ki++) {
      if (!origKeys.has(keys[ki])) detectedKeys.add(keys[ki]);
    }
    previewRows.push(obj);
  }

  if (errors.length > 0) {
    $calcolError.textContent = errors[0];
  } else {
    $calcolError.textContent = '';
  }

  // Auto-detect types
  var detectedArr = Array.from(detectedKeys);
  var meta = [];
  for (var di = 0; di < detectedArr.length; di++) {
    var name = detectedArr[di];
    var allNum = true;
    var hasValue = false;
    for (var ri2 = 0; ri2 < previewRows.length; ri2++) {
      var v = previewRows[ri2][name];
      if (v === null || v === undefined) continue;
      hasValue = true;
      if (typeof v === 'boolean') continue; // booleans count as numeric
      if (typeof v !== 'number' || isNaN(v)) { allNum = false; break; }
    }
    var autoType = (hasValue && allNum) ? 'numeric' : 'categorical';
    if (metaCat.has(name)) autoType = 'categorical';
    if (metaNum.has(name)) autoType = 'numeric';
    meta.push({ name: name, type: autoType });
  }

  currentCalcolMeta = meta;
  updateCalcolBadge();

  // Render detected columns
  if (meta.length === 0) {
    $calcolDetected.innerHTML = '<div class="calcol-empty-hint">No new columns detected. Assign properties to <code>' + rv + '</code>.</div>';
  } else {
    var dHtml = '';
    for (var mi = 0; mi < meta.length; mi++) {
      var m = meta[mi];
      var tc = m.type === 'numeric' ? 'num' : 'cat';
      var tl = m.type === 'numeric' ? 'NUM' : 'CAT';
      dHtml += '<div class="calcol-det-item"><span class="cd-name">' + esc(m.name) + '</span><span class="cd-type ' + tc + '">' + tl + '</span></div>';
    }
    $calcolDetected.innerHTML = dHtml;
  }

  // Render preview table
  if (meta.length === 0) {
    $calcolPreviewTable.innerHTML = '<div class="calcol-empty-hint">No new columns to preview.</div>';
  } else {
    var tHtml = '<table><thead><tr><th>#</th>';
    for (var hi = 0; hi < meta.length; hi++) {
      tHtml += '<th>' + esc(meta[hi].name) + '</th>';
    }
    tHtml += '</tr></thead><tbody>';
    var maxRows = Math.min(previewRows.length, 10);
    for (var pri = 0; pri < maxRows; pri++) {
      tHtml += '<tr><td style="color:var(--fg-dim)">' + (pri + 1) + '</td>';
      for (var ci = 0; ci < meta.length; ci++) {
        var val = previewRows[pri][meta[ci].name];
        var isErr = false;
        var display;
        if (val === null || val === undefined) {
          display = '<i style="color:var(--fg-dim)">null</i>';
        } else {
          display = esc(String(val));
        }
        tHtml += '<td>' + display + '</td>';
      }
      tHtml += '</tr>';
    }
    tHtml += '</tbody></table>';
    $calcolPreviewTable.innerHTML = tHtml;
  }
}

// ── Data Source Toggle ────────────────────────────────────────────────
if ($calcolDataSrc) {
  $calcolDataSrc.addEventListener('change', function() {
    simulateCalcol();
  });
}

function enableSimulatedDataSource() {
  if (!$calcolDataSrc) return;
  var opt = $calcolDataSrc.querySelector('option[value="simulated"]');
  if (opt) opt.disabled = false;
}

// ── Badge / Integration ───────────────────────────────────────────────
function updateCalcolBadge() {
  if (!$calcolBadge) return;
  $calcolBadge.textContent = currentCalcolMeta.length;
  var calcolTab = $resultsTabs.querySelector('[data-tab="calcols"]');
  if (calcolTab) calcolTab.innerHTML = 'Calc <span class="tab-badge">' + currentCalcolMeta.length + '</span>';
}

function setCalcolCode(code) {
  currentCalcolCode = code;
  if ($calcolCodeArea) {
    $calcolCodeArea.value = code;
    syncCodeHighlight();
  }
}

// ── Expression Input System (used by filter) ──────────────────────────

function getTokenAtCursor(el) {
  var pos = el.selectionStart;
  var text = el.value.substring(0, pos);
  var match = text.match(/(?:r\.)?([a-zA-Z_][a-zA-Z0-9_]*)$/);
  if (!match) return { token: '', start: pos, hasPrefix: false };
  var full = match[0];
  var hasPrefix = full.startsWith('r.');
  var token = match[1];
  var start = pos - full.length;
  return { token: token, start: start, hasPrefix: hasPrefix, fullLen: full.length };
}

function buildExprAcItems(opts) {
  if (!opts) opts = {};
  var items = [];
  var hdr = preflightData ? preflightData.header : currentHeader;
  if (hdr) {
    for (var i = 0; i < hdr.length; i++) {
      items.push({ label: hdr[i], insert: 'r.' + hdr[i], kind: 'col' });
    }
  }
  for (var ci = 0; ci < currentCalcolMeta.length; ci++) {
    var cc = currentCalcolMeta[ci];
    items.push({ label: cc.name, insert: 'r.' + cc.name, kind: 'calc' });
  }
  for (var mi = 0; mi < MATH_COMPLETIONS.length; mi++) {
    var m = MATH_COMPLETIONS[mi];
    items.push({ label: m.label, insert: m.insert, kind: 'fn', desc: m.desc });
  }
  return items;
}

function validateExpression(expr, mode) {
  var rv = currentRowVar || 'r';
  var wrapped = mode === 'filter' ? '!!(' + expr + ')' : '(' + expr + ')';
  try {
    new Function(rv, MATH_PREAMBLE_MAIN + 'return ' + wrapped);
  } catch(e) {
    return { valid: false, error: 'Syntax error: ' + e.message, warnings: [] };
  }
  var warnings = [];
  var knownNames = new Set();
  var hdr = preflightData ? preflightData.header : currentHeader;
  if (hdr) hdr.forEach(function(n) { knownNames.add(n); });
  currentCalcolMeta.forEach(function(c) { knownNames.add(c.name); });
  var checked = new Set();
  var patterns = [/\br\.([a-zA-Z_]\w*)/g, /\br\["([^"]+)"\]/g, /\br\['([^']+)'\]/g];
  for (var pi = 0; pi < patterns.length; pi++) {
    for (var m of expr.matchAll(patterns[pi])) {
      if (!checked.has(m[1])) {
        checked.add(m[1]);
        if (!knownNames.has(m[1])) warnings.push('Unknown column: "' + m[1] + '"');
      }
    }
  }
  return { valid: true, error: null, warnings: warnings };
}

function createExprInput(element, options) {
  var opts = Object.assign({
    dropdownElement: null, errorElement: null,
    onInput: null, onAccept: null, onEnter: null,
    mode: 'filter', validateOnBlur: true
  }, options);

  var items = [], selected = -1, lastResult = null, debounceTimer = null;
  var createdWrapper = null, createdDropdown = null, createdError = null;
  var parentMadeRelative = false;

  var dropdown = opts.dropdownElement;
  if (!dropdown) {
    dropdown = document.createElement('div');
    dropdown.className = 'expr-ac';
    createdDropdown = dropdown;
    var parent = element.parentElement;
    var parentPos = getComputedStyle(parent).position;
    if (!parentPos || parentPos === 'static') {
      var parentDisplay = getComputedStyle(parent).display;
      var parentFlexDir = getComputedStyle(parent).flexDirection;
      if ((parentDisplay === 'flex' || parentDisplay === 'inline-flex') && parentFlexDir === 'row') {
        var wrap = document.createElement('span');
        wrap.className = 'expr-ac-wrap';
        wrap.style.flex = '1';
        wrap.style.minWidth = '0';
        parent.insertBefore(wrap, element);
        wrap.appendChild(element);
        wrap.appendChild(dropdown);
        createdWrapper = wrap;
      } else {
        parent.style.position = 'relative';
        parentMadeRelative = true;
        parent.insertBefore(dropdown, element.nextSibling);
      }
    } else {
      parent.insertBefore(dropdown, element.nextSibling);
    }
  }

  var errEl = opts.errorElement;
  if (!errEl) {
    errEl = document.createElement('div');
    errEl.className = 'expr-error';
    var after = createdWrapper || element;
    after.parentElement.insertBefore(errEl, after.nextSibling);
    createdError = errEl;
  }

  function showAc() {
    var tok = getTokenAtCursor(element);
    if (!tok.token || tok.token.length < 1) { hideAc(); return; }
    var lc = tok.token.toLowerCase();
    items = buildExprAcItems().filter(function(it) {
      var target = it.kind === 'col' || it.kind === 'calc' ? it.label : it.insert;
      return fuzzyMatch(lc, target.toLowerCase()) || fuzzyMatch(lc, it.label.toLowerCase());
    }).slice(0, 10);
    if (items.length === 0) { hideAc(); return; }
    selected = 0;
    renderAc();
    dropdown.classList.add('open');
  }

  function hideAc() {
    dropdown.classList.remove('open');
    items = [];
    selected = -1;
  }

  function renderAc() {
    dropdown.innerHTML = items.map(function(it, i) {
      var cls = it.kind === 'col' ? 'ac-col' : it.kind === 'calc' ? 'ac-calc' : 'ac-fn';
      return '<div class="ac-item ' + cls + (i === selected ? ' selected' : '') + '" data-idx="' + i + '">' +
        '<span class="ac-label">' + esc(it.label) + '</span>' +
        (it.desc ? '<span class="ac-desc">' + esc(it.desc) + '</span>' : '') +
        '</div>';
    }).join('');
    dropdown.querySelectorAll('.ac-item').forEach(function(el) {
      el.addEventListener('mousedown', function(e) {
        e.preventDefault();
        acceptAc(parseInt(el.dataset.idx));
      });
    });
  }

  function acceptAc(idx) {
    var item = items[idx];
    if (!item) return;
    var tok = getTokenAtCursor(element);
    var before = element.value.substring(0, tok.start);
    var after = element.value.substring(tok.start + tok.fullLen);
    element.value = before + item.insert + after;
    var newPos = before.length + item.insert.length;
    element.setSelectionRange(newPos, newPos);
    hideAc();
    if (opts.onAccept) opts.onAccept(element.value);
    element.focus();
  }

  function showValidation(result) {
    if (!errEl) return;
    if (!result.valid) {
      errEl.textContent = result.error;
      errEl.classList.add('active');
      errEl.style.color = '';
    } else if (result.warnings.length) {
      errEl.textContent = result.warnings.join('; ');
      errEl.classList.add('active');
      errEl.style.color = 'var(--amber-dim)';
    } else {
      errEl.textContent = '';
      errEl.classList.remove('active');
      errEl.style.color = '';
    }
  }

  function validate() {
    var expr = element.value.trim();
    if (!expr) {
      lastResult = { valid: true, error: null, warnings: [] };
      showValidation(lastResult);
      return lastResult;
    }
    lastResult = validateExpression(expr, opts.mode);
    showValidation(lastResult);
    return lastResult;
  }

  function onInputHandler() {
    if (opts.onInput) opts.onInput(element.value);
    showAc();
    if (opts.validateOnBlur) {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(validate, 400);
    }
  }

  function onBlurHandler() {
    setTimeout(hideAc, 150);
    if (opts.validateOnBlur) validate();
  }

  function onKeydownHandler(e) {
    if (dropdown.classList.contains('open') && items.length > 0) {
      if (e.key === 'ArrowDown') { e.preventDefault(); selected = (selected + 1) % items.length; renderAc(); return; }
      if (e.key === 'ArrowUp') { e.preventDefault(); selected = (selected - 1 + items.length) % items.length; renderAc(); return; }
      if (e.key === 'Tab' || (e.key === 'Enter' && selected >= 0)) { e.preventDefault(); acceptAc(selected); return; }
      if (e.key === 'Escape') { hideAc(); return; }
    }
    if (e.key === 'Enter' && !e.shiftKey && opts.onEnter) {
      e.preventDefault();
      opts.onEnter();
    }
  }

  element.addEventListener('input', onInputHandler);
  element.addEventListener('blur', onBlurHandler);
  element.addEventListener('keydown', onKeydownHandler);

  return {
    validate: validate,
    getErrors: function() { return lastResult; },
    destroy: function() {
      element.removeEventListener('input', onInputHandler);
      element.removeEventListener('blur', onBlurHandler);
      element.removeEventListener('keydown', onKeydownHandler);
      clearTimeout(debounceTimer);
      hideAc();
      if (createdWrapper && createdWrapper.parentElement) {
        createdWrapper.parentElement.insertBefore(element, createdWrapper);
        createdWrapper.remove();
      }
      if (parentMadeRelative && element.parentElement) {
        element.parentElement.style.position = '';
      }
      if (createdDropdown && createdDropdown.parentElement) createdDropdown.remove();
      if (createdError && createdError.parentElement) createdError.remove();
    }
  };
}

// ── Utility functions ─────────────────────────────────────────────────
function fi(label, value) {
  return '<div class="fi-item"><span class="fi-label">' + label + ':</span><span class="fi-value">' + value + '</span></div>';
}

function geoRowT(label, vx, vy, vz) {
  var fmt = function(v) { return (v != null && v !== undefined) ? String(v) : '\u2014'; };
  var cell = function(v) {
    var s = fmt(v);
    return s === '\u2014'
      ? '<div class="gc">' + s + '</div>'
      : '<div class="gc" data-value="' + s + '">' + s + '<span class="copy-toast">copied</span></div>';
  };
  return '<div class="gl">' + label + '</div>' + cell(vx) + cell(vy) + cell(vz);
}

function esc(s) {
  var d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ── Initialize on load ────────────────────────────────────────────────
initCalcolEditor();

// ─── Event Handlers ──────────────────────────────────────────────────
$dropzone.addEventListener('dragover', (e) => { e.preventDefault(); $dropzone.classList.add('drag-over'); });
$dropzone.addEventListener('dragleave', () => $dropzone.classList.remove('drag-over'));
$dropzone.addEventListener('drop', async (e) => {
  e.preventDefault();
  $dropzone.classList.remove('drag-over');
  if (!e.dataTransfer.items || !e.dataTransfer.items.length) {
    if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0], null);
    return;
  }
  var handle = null;
  if (HAS_FSAA && e.dataTransfer.items[0].getAsFileSystemHandle) {
    try { handle = await e.dataTransfer.items[0].getAsFileSystemHandle(); } catch (ex) {}
  }
  var file = handle ? await handle.getFile() : (e.dataTransfer.files[0] || null);
  if (file) handleFile(file, handle);
});

// Click to browse — use FSAA showOpenFilePicker when available
if (HAS_FSAA) {
  $dropzone.addEventListener('click', async (e) => {
    if (e.target === $fileInput) return;
    e.preventDefault();
    try {
      var handles = await window.showOpenFilePicker({
        types: [
          { description: 'CSV files', accept: { 'text/*': ['.csv', '.txt', '.dat'] } },
          { description: 'ZIP files', accept: { 'application/zip': ['.zip'] } }
        ],
        multiple: false
      });
      var handle = handles[0];
      var file = await handle.getFile();
      handleFile(file, handle);
    } catch (ex) { /* user cancelled picker */ }
  });
  $fileInput.style.display = 'none';
}

$fileInput.addEventListener('change', (e) => { if (e.target.files.length) handleFile(e.target.files[0], null); });

// ─── Filter Expression System ────────────────────────────────────────
function rebuildFilterExpression() {
  // Gather checked values grouped by column
  const groups = {};
  $catValueTable.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
    const col = cb.dataset.col;
    if (!groups[col]) groups[col] = [];
    groups[col].push(cb.dataset.val);
  });

  // Helper: proper JS accessor for column name
  const colRef = (name) => {
    const v = currentRowVar;
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name) ? `${v}.${name}` : `${v}["${name}"]`;
  };

  // Build expression: OR within column, AND across columns
  const parts = [];
  for (const [colIdx, vals] of Object.entries(groups)) {
    const col = colRef(currentHeader[parseInt(colIdx)]);
    const conditions = vals.map(v => `${col} == "${v}"`);
    parts.push(conditions.length === 1 ? conditions[0] : `(${conditions.join(' || ')})`);
  }

  // Get any existing manual/numeric parts the user typed
  const currentExpr = $filterExpr.value.trim();
  const autoExpr = parts.join(' && ');

  // If user hasn't manually edited, just replace entirely
  if (!currentExpr || currentExpr === lastAutoExpr) {
    $filterExpr.value = autoExpr;
  } else {
    // User has custom content — try to replace the auto-generated portion
    if (lastAutoExpr && currentExpr.includes(lastAutoExpr)) {
      $filterExpr.value = autoExpr
        ? currentExpr.replace(lastAutoExpr, autoExpr)
        : currentExpr.replace(lastAutoExpr, '').replace(/^\s*&&\s*|\s*&&\s*$/, '').trim();
    } else if (autoExpr) {
      // Can't find old auto part — append
      $filterExpr.value = currentExpr ? `${currentExpr} && ${autoExpr}` : autoExpr;
    }
  }
  lastAutoExpr = autoExpr;
}
let lastAutoExpr = '';

// Apply filter
$filterApply.addEventListener('click', () => {
  const expr = $filterExpr.value.trim();
  $filterError.classList.remove('active');
  $filterError.style.color = '';
  if (!expr) {
    currentFilter = null;
    startAnalysis(currentXYZ, null, undefined, undefined, undefined, undefined);
    return;
  }
  if (filterExprController) {
    const result = filterExprController.validate();
    if (!result.valid) return;
  }
  currentFilter = { expression: expr };
  startAnalysis(currentXYZ, currentFilter, undefined, undefined, undefined, undefined);
});

// Filter expression autocomplete + Enter-to-apply
const filterExprController = createExprInput($filterExpr, {
  errorElement: $filterError,
  mode: 'filter',
  validateOnBlur: true,
  onEnter: function() { $filterApply.click(); }
});

// Clear filter
$filterClear.addEventListener('click', () => {
  $filterExpr.value = '';
  lastAutoExpr = '';
  currentFilter = null;
  $filterError.classList.remove('active');
  // Uncheck all checkboxes
  $catValueTable.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
    cb.checked = false;
    cb.closest('tr').classList.remove('active');
  });
  startAnalysis(currentXYZ, null, undefined, undefined, undefined, undefined);
});

// Click-to-copy on geometry cells (event delegation)
$geoContent.addEventListener('click', (e) => {
  const cell = e.target.closest('.gc[data-value]');
  if (!cell) return;
  const val = cell.dataset.value;
  navigator.clipboard.writeText(val).then(() => {
    cell.classList.add('copied');
    setTimeout(() => cell.classList.remove('copied'), 800);
  });
});

// Copy full geometry table
let lastGeoData = null;
document.getElementById('copyGeoBtn').addEventListener('click', (e) => {
  if (!lastGeoData) return;
  const btn = e.currentTarget;
  const g = lastGeoData;
  const fmt = (v) => (v != null && v !== undefined) ? String(v) : '';
  const anySubBlocked = g.x.isSubBlocked || g.y.isSubBlocked || g.z.isSubBlocked;
  const rows = [
    ['', 'X', 'Y', 'Z'],
    ['Origin', fmt(g.x.origin), fmt(g.y.origin), fmt(g.z.origin)],
    ['Block Size', fmt(g.x.blockSize), fmt(g.y.blockSize), fmt(g.z.blockSize)],
  ];
  if (anySubBlocked) {
    rows.push(['Min Block', fmt(g.x.minBlockSize), fmt(g.y.minBlockSize), fmt(g.z.minBlockSize)]);
  }
  rows.push(
    ['Unique', fmt(g.x.uniqueCount), fmt(g.y.uniqueCount), fmt(g.z.uniqueCount)],
    ['Grid Count', fmt(g.x.gridCount), fmt(g.y.gridCount), fmt(g.z.gridCount)],
    ['Extent', fmt(g.x.extent), fmt(g.y.extent), fmt(g.z.extent)],
  );
  const tsv = rows.map(r => r.join('\t')).join('\n');
  navigator.clipboard.writeText(tsv).then(() => {
    btn.classList.add('copied');
    btn.textContent = 'Copied!';
    setTimeout(() => {
      btn.classList.remove('copied');
      btn.textContent = 'Copy table';
    }, 1200);
  });
});

// Copy column overview table
document.getElementById('copyColOverviewBtn').addEventListener('click', (e) => {
  const table = document.querySelector('.col-overview');
  if (!table) return;
  const btn = e.currentTarget;
  const rows = [];
  table.querySelectorAll('tr').forEach(tr => {
    const cells = [];
    tr.querySelectorAll('th, td').forEach(td => cells.push(td.textContent.trim()));
    rows.push(cells.join('\t'));
  });
  const tsv = rows.join('\n');
  navigator.clipboard.writeText(tsv).then(() => {
    btn.classList.add('copied');
    btn.textContent = 'Copied!';
    setTimeout(() => {
      btn.classList.remove('copied');
      btn.textContent = 'Copy table';
    }, 1200);
  });
});

// Export bounding box as OBJ
document.getElementById('exportObjBtn').addEventListener('click', () => {
  if (!lastGeoData) return;
  const g = lastGeoData;
  const gx = g.x, gy = g.y, gz = g.z;
  const xMin = gx.origin - gx.blockSize / 2;
  const xMax = gx.origin + gx.gridCount * gx.blockSize - gx.blockSize / 2;
  const yMin = gy.origin - gy.blockSize / 2;
  const yMax = gy.origin + gy.gridCount * gy.blockSize - gy.blockSize / 2;
  const zMin = gz.origin - gz.blockSize / 2;
  const zMax = gz.origin + gz.gridCount * gz.blockSize - gz.blockSize / 2;
  const fname = currentFile ? currentFile.name : 'model';
  const obj = `# BMA Bounding Box \u2014 ${fname}
v ${xMin} ${yMin} ${zMin}
v ${xMax} ${yMin} ${zMin}
v ${xMax} ${yMax} ${zMin}
v ${xMin} ${yMax} ${zMin}
v ${xMin} ${yMin} ${zMax}
v ${xMax} ${yMin} ${zMax}
v ${xMax} ${yMax} ${zMax}
v ${xMin} ${yMax} ${zMax}
f 1 2 3 4
f 5 8 7 6
f 1 5 6 2
f 2 6 7 3
f 3 7 8 4
f 4 8 5 1
`;
  const blob = new Blob([obj], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = fname.replace(/\.[^.]+$/, '') + '_bbox.obj';
  a.click();
  URL.revokeObjectURL(a.href);
});

// ─── Settings Modal — Themes, Cache, Defaults ─────────────────────────

var bmaSettings = null;

var SETTINGS_DEFAULTS = {
  theme: 'default',
  customThemes: [null, null, null],
  defaultPercentilePreset: 'quartiles',
  customPercentiles: null,
  sigFigs: null,
  thousandsSep: 'space',
  sciNotation: 'auto',
  defaultCatSort: 'count-desc'
};

var THEME_META_COLORS = {
  'default': '#08090a',
  'teal': '#070b0c',
  'blue': '#080a0f',
  'mocha': '#1e1e2e',
  'light': '#f5f5f0',
  'cream': '#ece8e0',
  'bm77': '#262335'
};

var THEME_NAMES = {
  'default': 'Default',
  'teal': 'Teal',
  'blue': 'Blue',
  'mocha': 'Mocha',
  'light': 'Light',
  'cream': 'Cream',
  'bm77': 'BM77'
};

var THEME_SWATCHES = {
  'default': ['#08090a', '#161a1e', '#e8a317', '#b07a0e'],
  'teal':    ['#070b0c', '#13191d', '#2dd4bf', '#14b8a6'],
  'blue':    ['#080a0f', '#131825', '#4a9eff', '#2d7ad4'],
  'mocha':   ['#1e1e2e', '#252540', '#f9e2af', '#e2c88c'],
  'light':   ['#f5f5f0', '#ddddd8', '#c07800', '#996000'],
  'cream':   ['#ece8e0', '#d8d4cc', '#9a7320', '#7a5b18'],
  'bm77':    ['#262335', '#34294f', '#ff7edb', '#36f9f6']
};

var CUSTOM_THEME_KEYS = ['name','bg','bg1','bg2','bg3','fg','fgDim','fgBright','accent','accentDim','border'];

function loadSettings() {
  try {
    var raw = localStorage.getItem('bma:settings');
    if (raw) {
      var parsed = JSON.parse(raw);
      bmaSettings = {};
      for (var k in SETTINGS_DEFAULTS) {
        bmaSettings[k] = parsed[k] !== undefined ? parsed[k] : SETTINGS_DEFAULTS[k];
      }
      return;
    }
  } catch (e) {}
  bmaSettings = JSON.parse(JSON.stringify(SETTINGS_DEFAULTS));
}

function saveSettings() {
  try {
    localStorage.setItem('bma:settings', JSON.stringify(bmaSettings));
  } catch (e) {}
}

function applyTheme(name) {
  bmaSettings.theme = name;
  saveSettings();

  // Remove custom theme style if present
  var customStyle = document.getElementById('customThemeStyle');

  if (name && name.startsWith('custom-')) {
    var idx = parseInt(name.split('-')[1], 10);
    var ct = bmaSettings.customThemes[idx];
    if (ct) {
      document.documentElement.removeAttribute('data-theme');
      var css = ':root {\n';
      css += '  --bg: ' + ct.bg + ';\n';
      css += '  --bg1: ' + ct.bg1 + ';\n';
      css += '  --bg2: ' + ct.bg2 + ';\n';
      css += '  --bg3: ' + ct.bg3 + ';\n';
      css += '  --fg: ' + ct.fg + ';\n';
      css += '  --fg-dim: ' + ct.fgDim + ';\n';
      css += '  --fg-bright: ' + ct.fgBright + ';\n';
      css += '  --amber: ' + ct.accent + ';\n';
      css += '  --amber-dim: ' + ct.accentDim + ';\n';
      css += '  --amber-glow: ' + ct.accent + '30;\n';
      css += '  --border: ' + ct.border + ';\n';
      css += '}\n';
      if (!customStyle) {
        customStyle = document.createElement('style');
        customStyle.id = 'customThemeStyle';
        document.head.appendChild(customStyle);
      }
      customStyle.textContent = css;
      updateThemeColor(ct.bg);
    }
    return;
  }

  // Built-in theme
  if (customStyle) customStyle.textContent = '';
  if (name && name !== 'default') {
    document.documentElement.setAttribute('data-theme', name);
  } else {
    document.documentElement.removeAttribute('data-theme');
  }
  updateThemeColor(THEME_META_COLORS[name] || THEME_META_COLORS['default']);
}

function updateThemeColor(color) {
  var meta = document.querySelector('meta[name="theme-color"]');
  if (meta) meta.setAttribute('content', color);
}

// ─── Cache Enumeration ───────────────────────────────────────────────

function cacheList() {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('results', 'readonly');
      var store = tx.objectStore('results');
      var req = store.openCursor();
      var items = [];
      req.onsuccess = function() {
        var cursor = req.result;
        if (cursor) {
          var key = cursor.key;
          var val = cursor.value;
          var size = 0;
          try { size = estimateResultBytes(val.data || val); } catch (e) {}
          items.push({ key: key, size: size });
          cursor.continue();
        } else {
          resolve(items);
        }
      };
      req.onerror = function() { reject(req.error); };
    });
  });
}

function cacheDeleteAll() {
  return openCacheDB().then(function(db) {
    return new Promise(function(resolve, reject) {
      var tx = db.transaction('results', 'readwrite');
      tx.objectStore('results').clear();
      tx.oncomplete = function() { resolve(); };
      tx.onerror = function() { reject(tx.error); };
    });
  });
}

// ─── Settings Modal Rendering ────────────────────────────────────────

function openSettings() {
  renderSettingsBody();
  $settingsModal.classList.add('active');
}

function closeSettings() {
  $settingsModal.classList.remove('active');
}

function renderSettingsBody() {
  var body = document.getElementById('settingsBody');
  if (!body) return;
  var html = '';

  // ── Theme section ──
  html += '<div class="settings-section"><div class="settings-section-title">Theme</div>';
  html += '<div class="settings-theme-grid">';
  var builtInThemes = ['default', 'teal', 'blue', 'mocha', 'light', 'cream', 'bm77'];
  for (var i = 0; i < builtInThemes.length; i++) {
    var tid = builtInThemes[i];
    var sw = THEME_SWATCHES[tid];
    var sel = bmaSettings.theme === tid ? ' selected' : '';
    html += '<button class="settings-swatch' + sel + '" data-theme="' + tid + '">';
    html += '<div class="settings-swatch-colors">';
    for (var s = 0; s < sw.length; s++) {
      html += '<div style="background:' + sw[s] + '"></div>';
    }
    html += '</div>';
    html += '<div class="settings-swatch-name">' + THEME_NAMES[tid] + '</div>';
    html += '</button>';
  }
  // Custom theme swatches
  for (var ci = 0; ci < 3; ci++) {
    var ct = bmaSettings.customThemes[ci];
    var ctId = 'custom-' + ci;
    var csel = bmaSettings.theme === ctId ? ' selected' : '';
    if (ct) {
      html += '<button class="settings-swatch' + csel + '" data-theme="' + ctId + '">';
      html += '<div class="settings-swatch-colors">';
      html += '<div style="background:' + esc(ct.bg) + '"></div>';
      html += '<div style="background:' + esc(ct.bg2) + '"></div>';
      html += '<div style="background:' + esc(ct.accent) + '"></div>';
      html += '<div style="background:' + esc(ct.accentDim) + '"></div>';
      html += '</div>';
      html += '<div class="settings-swatch-name">' + esc(ct.name || 'Custom ' + (ci + 1)) + '</div>';
      html += '</button>';
    }
  }
  html += '</div>';

  // Custom theme inputs
  html += '<details class="settings-custom-details"><summary>Custom themes</summary>';
  html += '<div class="settings-custom-themes">';
  for (var ci = 0; ci < 3; ci++) {
    var ct = bmaSettings.customThemes[ci];
    var placeholder = '{"name":"My Theme","bg":"#0a0a0a","bg1":"#111","bg2":"#1a1a1a","bg3":"#222","fg":"#ccc","fgDim":"#666","fgBright":"#eee","accent":"#ff6600","accentDim":"#cc5200","border":"#333"}';
    html += '<div class="settings-custom-slot">';
    html += '<label>Slot ' + (ci + 1) + '</label>';
    html += '<textarea class="settings-custom-input" data-slot="' + ci + '" rows="2" placeholder=\'' + placeholder + '\' spellcheck="false">' + (ct ? esc(JSON.stringify(ct)) : '') + '</textarea>';
    html += '<div class="settings-custom-actions">';
    html += '<button class="settings-custom-apply" data-slot="' + ci + '">Apply</button>';
    if (ct) html += '<button class="settings-custom-del" data-slot="' + ci + '">Delete</button>';
    html += '</div></div>';
  }
  html += '</div></details>';
  html += '</div>';

  // ── Saved Projects section ──
  html += '<div class="settings-section"><div class="settings-section-title">Saved Projects</div>';
  html += renderSettingsProjectList();
  html += '</div>';

  // ── Cache section ──
  html += '<div class="settings-section"><div class="settings-section-title">Cache</div>';
  html += '<div id="settingsCacheContent"><div class="settings-cache-loading">Loading...</div></div>';
  html += '</div>';

  // ── Default Percentile Preset ──
  html += '<div class="settings-section"><div class="settings-section-title">Default Percentile Preset</div>';
  html += '<div class="settings-preset-btns">';
  var presets = ['quartiles', 'deciles', 'ventiles', 'custom'];
  var presetLabels = ['Quartiles', 'Deciles', 'Ventiles', 'Custom'];
  for (var pi = 0; pi < presets.length; pi++) {
    var pa = bmaSettings.defaultPercentilePreset === presets[pi] ? ' active' : '';
    html += '<button class="settings-preset-btn' + pa + '" data-preset="' + presets[pi] + '">' + presetLabels[pi] + '</button>';
  }
  html += '</div>';
  var cpVis = bmaSettings.defaultPercentilePreset === 'custom' ? '' : ' style="display:none"';
  var cpVal = bmaSettings.customPercentiles ? bmaSettings.customPercentiles.join(', ') : '';
  html += '<input type="text" class="settings-custom-pct" id="settingsCustomPct" placeholder="e.g. 5,10,25,50,75,90,95" value="' + cpVal + '"' + cpVis + ' autocomplete="off" spellcheck="false">';
  html += '</div>';

  // ── Number Formatting ──
  html += '<div class="settings-section"><div class="settings-section-title">Number Formatting</div>';
  html += '<div class="settings-sigfigs-row"><label>Significant figures</label><select id="settingsSigFigs">';
  var sigOpts = [['', 'Auto'], ['2', '2'], ['3', '3'], ['4', '4'], ['5', '5'], ['6', '6'], ['8', '8']];
  for (var si = 0; si < sigOpts.length; si++) {
    var sv = sigOpts[si][0];
    var sl = sigOpts[si][1];
    var curSig = bmaSettings.sigFigs === null ? '' : String(bmaSettings.sigFigs);
    var ssel = sv === curSig ? ' selected' : '';
    html += '<option value="' + sv + '"' + ssel + '>' + sl + '</option>';
  }
  html += '</select></div>';
  // Thousands separator
  var tSepOpts = [['space', 'Space (1\u2009234)'], ['comma', 'Comma (1,234)'], ['none', 'None (1234)']];
  var curTSep = bmaSettings.thousandsSep || 'space';
  html += '<div class="settings-sigfigs-row" style="margin-top:0.4rem"><label>Thousands separator</label><select id="settingsThousandsSep">';
  for (var ti = 0; ti < tSepOpts.length; ti++) {
    var tsel = tSepOpts[ti][0] === curTSep ? ' selected' : '';
    html += '<option value="' + tSepOpts[ti][0] + '"' + tsel + '>' + tSepOpts[ti][1] + '</option>';
  }
  html += '</select></div>';
  // Scientific notation
  var sciOpts = [['auto', 'Auto'], ['never', 'Never'], ['1e6', '\u2265 1M'], ['1e9', '\u2265 1B']];
  var curSci = bmaSettings.sciNotation || 'auto';
  html += '<div class="settings-sigfigs-row" style="margin-top:0.4rem"><label>Scientific notation</label><select id="settingsSciNotation">';
  for (var sci = 0; sci < sciOpts.length; sci++) {
    var scsel = sciOpts[sci][0] === curSci ? ' selected' : '';
    html += '<option value="' + sciOpts[sci][0] + '"' + scsel + '>' + sciOpts[sci][1] + '</option>';
  }
  html += '</select></div>';
  html += '</div>';

  // ── Default Category Sort ──
  html += '<div class="settings-section"><div class="settings-section-title">Default Category Sort</div>';
  html += '<div class="settings-preset-btns">';
  var catSorts = ['count-desc', 'count-asc', 'alpha'];
  var catSortLabels = ['Count \u2193', 'Count \u2191', 'A-Z'];
  for (var csi = 0; csi < catSorts.length; csi++) {
    var csa = bmaSettings.defaultCatSort === catSorts[csi] ? ' active' : '';
    html += '<button class="settings-preset-btn settings-cat-sort-btn' + csa + '" data-catsort="' + catSorts[csi] + '">' + catSortLabels[csi] + '</button>';
  }
  html += '</div></div>';

  body.innerHTML = html;

  // Wire events
  wireSettingsEvents();

  // Load cache info async
  loadCacheInfo();
}

function renderSettingsProjectList() {
  var projects = [];
  try {
    for (var i = 0; i < localStorage.length; i++) {
      var key = localStorage.key(i);
      if (key && key.startsWith('bma:') && key !== 'bma:settings') {
        var parts = key.substring(4); // strip 'bma:'
        var lastColon = parts.lastIndexOf(':');
        var fname = lastColon > 0 ? parts.substring(0, lastColon) : parts;
        var fsize = lastColon > 0 ? parts.substring(lastColon + 1) : '';
        var raw = localStorage.getItem(key);
        var bytes = raw ? raw.length * 2 : 0; // rough UTF-16 estimate
        var ts = null;
        try {
          var parsed = JSON.parse(raw);
          ts = parsed._ts || null;
        } catch (e) {}
        projects.push({ key: key, name: fname, size: fsize, bytes: bytes, ts: ts });
      }
    }
  } catch (e) {}

  if (projects.length === 0) {
    return '<div class="settings-cache-empty">No saved projects.</div>';
  }

  // Sort by timestamp descending (most recent first)
  projects.sort(function(a, b) { return (b.ts || 0) - (a.ts || 0); });

  var totalBytes = 0;
  for (var i = 0; i < projects.length; i++) totalBytes += projects[i].bytes;

  var html = '<div class="settings-cache-summary">' + projects.length + ' project' + (projects.length !== 1 ? 's' : '') + ' (' + formatBytes(totalBytes) + ')</div>';
  html += '<div class="settings-cache-list">';
  for (var i = 0; i < projects.length; i++) {
    var p = projects[i];
    var displayName = p.name.length > 40 ? p.name.substring(0, 37) + '...' : p.name;
    var dateStr = '';
    if (p.ts) {
      var d = new Date(p.ts);
      dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    html += '<div class="settings-cache-item">';
    html += '<span class="settings-cache-name" title="' + esc(p.name) + ' (' + (p.size ? formatBytes(Number(p.size)) : '?') + ')">' + esc(displayName) + '</span>';
    if (dateStr) html += '<span class="settings-cache-size" style="margin-right:0.4rem">' + dateStr + '</span>';
    html += '<span class="settings-cache-size">' + formatBytes(p.bytes) + '</span>';
    html += '<button class="settings-cache-del settings-proj-del" data-projkey="' + esc(p.key) + '" title="Delete saved project">\u2715</button>';
    html += '</div>';
  }
  html += '</div>';
  html += '<button class="settings-cache-clear-all" id="settingsProjClearAll">Clear all saved projects</button>';
  return html;
}

function wireSettingsEvents() {
  var body = document.getElementById('settingsBody');
  if (!body) return;

  // Theme swatches
  body.addEventListener('click', function(e) {
    var swatch = e.target.closest('.settings-swatch');
    if (swatch) {
      var tid = swatch.dataset.theme;
      applyTheme(tid);
      renderSettingsBody();
      return;
    }

    // Custom theme apply
    var applyBtn = e.target.closest('.settings-custom-apply');
    if (applyBtn) {
      var slot = parseInt(applyBtn.dataset.slot, 10);
      var textarea = body.querySelector('.settings-custom-input[data-slot="' + slot + '"]');
      if (textarea) {
        try {
          var obj = JSON.parse(textarea.value);
          // Validate keys
          var valid = true;
          for (var ki = 0; ki < CUSTOM_THEME_KEYS.length; ki++) {
            if (!obj[CUSTOM_THEME_KEYS[ki]]) { valid = false; break; }
          }
          if (!valid) {
            textarea.style.borderColor = 'var(--red)';
            return;
          }
          bmaSettings.customThemes[slot] = obj;
          applyTheme('custom-' + slot);
          renderSettingsBody();
        } catch (err) {
          textarea.style.borderColor = 'var(--red)';
        }
      }
      return;
    }

    // Custom theme delete
    var delBtn = e.target.closest('.settings-custom-del');
    if (delBtn) {
      var slot = parseInt(delBtn.dataset.slot, 10);
      bmaSettings.customThemes[slot] = null;
      if (bmaSettings.theme === 'custom-' + slot) {
        applyTheme('default');
      }
      saveSettings();
      renderSettingsBody();
      return;
    }

    // Preset buttons
    var presetBtn = e.target.closest('.settings-preset-btn');
    if (presetBtn) {
      var preset = presetBtn.dataset.preset;
      bmaSettings.defaultPercentilePreset = preset;
      if (preset === 'custom') {
        var cpInput = document.getElementById('settingsCustomPct');
        if (cpInput) cpInput.style.display = '';
      }
      saveSettings();
      body.querySelectorAll('.settings-preset-btn').forEach(function(b) { b.classList.remove('active'); });
      presetBtn.classList.add('active');
      // Show/hide custom input
      var cpInput = document.getElementById('settingsCustomPct');
      if (cpInput) cpInput.style.display = preset === 'custom' ? '' : 'none';
      return;
    }

    // Category sort buttons
    var catSortBtn = e.target.closest('.settings-cat-sort-btn');
    if (catSortBtn) {
      bmaSettings.defaultCatSort = catSortBtn.dataset.catsort;
      saveSettings();
      body.querySelectorAll('.settings-cat-sort-btn').forEach(function(b) { b.classList.remove('active'); });
      catSortBtn.classList.add('active');
      return;
    }

    // Project delete individual
    var projDel = e.target.closest('.settings-proj-del');
    if (projDel) {
      var projKey = projDel.dataset.projkey;
      if (projKey) {
        try { localStorage.removeItem(projKey); } catch (ex) {}
        // Also delete matching cache entry
        cacheDelete(projKey).catch(function() {});
        renderSettingsBody();
      }
      return;
    }

    // Project clear all
    if (e.target.closest('#settingsProjClearAll')) {
      try {
        var keysToRemove = [];
        for (var ki = 0; ki < localStorage.length; ki++) {
          var lk = localStorage.key(ki);
          if (lk && lk.startsWith('bma:') && lk !== 'bma:settings') keysToRemove.push(lk);
        }
        for (var ki = 0; ki < keysToRemove.length; ki++) localStorage.removeItem(keysToRemove[ki]);
      } catch (ex) {}
      renderSettingsBody();
      return;
    }

    // Cache delete individual
    var cacheDel = e.target.closest('.settings-cache-del');
    if (cacheDel && !cacheDel.classList.contains('settings-proj-del')) {
      var key = cacheDel.dataset.key;
      cacheDelete(key).then(function() { loadCacheInfo(); });
      return;
    }

    // Cache clear all
    if (e.target.closest('#settingsCacheClearAll')) {
      cacheDeleteAll().then(function() { loadCacheInfo(); });
      return;
    }
  });

  // Custom percentile input
  var cpInput = document.getElementById('settingsCustomPct');
  if (cpInput) {
    cpInput.addEventListener('change', function() {
      var vals = cpInput.value.split(',').map(function(s) { return parseFloat(s.trim()); }).filter(function(n) { return !isNaN(n) && n > 0 && n < 100; });
      if (vals.length > 0) {
        vals.sort(function(a, b) { return a - b; });
        bmaSettings.customPercentiles = vals;
        saveSettings();
      }
    });
  }

  // Sig figs
  var sigSelect = document.getElementById('settingsSigFigs');
  if (sigSelect) {
    sigSelect.addEventListener('change', function() {
      var v = sigSelect.value;
      bmaSettings.sigFigs = v === '' ? null : parseInt(v, 10);
      saveSettings();
      refreshFormattedViews();
    });
  }

  // Thousands separator
  var tSepSelect = document.getElementById('settingsThousandsSep');
  if (tSepSelect) {
    tSepSelect.addEventListener('change', function() {
      bmaSettings.thousandsSep = tSepSelect.value;
      saveSettings();
      refreshFormattedViews();
    });
  }

  // Scientific notation
  var sciSelect = document.getElementById('settingsSciNotation');
  if (sciSelect) {
    sciSelect.addEventListener('change', function() {
      bmaSettings.sciNotation = sciSelect.value;
      saveSettings();
      refreshFormattedViews();
    });
  }
}

function loadCacheInfo() {
  var container = document.getElementById('settingsCacheContent');
  if (!container) return;

  cacheList().then(function(items) {
    if (items.length === 0) {
      container.innerHTML = '<div class="settings-cache-empty">No cached results.</div>';
      return;
    }
    var totalSize = 0;
    for (var i = 0; i < items.length; i++) totalSize += items[i].size;
    var html = '<div class="settings-cache-summary">' + items.length + ' cached result' + (items.length !== 1 ? 's' : '') + ' (' + formatBytes(totalSize) + ')</div>';
    html += '<div class="settings-cache-list">';
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var displayKey = item.key.length > 60 ? item.key.substring(0, 57) + '...' : item.key;
      html += '<div class="settings-cache-item">';
      html += '<span class="settings-cache-name" title="' + esc(item.key) + '">' + esc(displayKey) + '</span>';
      html += '<span class="settings-cache-size">' + formatBytes(item.size) + '</span>';
      html += '<button class="settings-cache-del" data-key="' + esc(item.key) + '" title="Delete">✕</button>';
      html += '</div>';
    }
    html += '</div>';
    html += '<button class="settings-cache-clear-all" id="settingsCacheClearAll">Clear all cache</button>';
    container.innerHTML = html;
  }).catch(function() {
    container.innerHTML = '<div class="settings-cache-empty">Could not read cache.</div>';
  });
}

function refreshFormattedViews() {
  if (typeof renderStatsTable === 'function' && lastDisplayedStats) {
    renderStatsTable();
  }
  if (lastGtData) renderGtOutput();
}

// ─── Initialization ──────────────────────────────────────────────────

function initSettings() {
  loadSettings();
  applyTheme(bmaSettings.theme);

  // Modal close handlers
  $settingsClose.addEventListener('click', closeSettings);
  $settingsModal.addEventListener('click', function(e) {
    if (e.target === $settingsModal) closeSettings();
  });
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && $settingsModal.classList.contains('active')) {
      closeSettings();
    }
  });

  // Gear button
  $settingsBtn.addEventListener('click', openSettings);
}

initSettings();

// ─── Categories Tab ────────────────────────────────────────────────────
let _catData = null;       // cached { categories, header, origColCount, rowCount }
let _catColSearch = '';

function renderCategoriesTab(categories, header, origColCount, rowCount) {
  _catData = { categories, header, origColCount, rowCount };
  const catCols = Object.keys(categories).map(Number).sort(function(a,b){return a-b;});

  $catBadge.textContent = catCols.length + ' columns';

  if (catCols.length === 0) {
    $catColList.innerHTML = '';
    $catToolbar.innerHTML = '';
    $catChart.innerHTML = '';
    $catValueTable.querySelector('tbody').innerHTML = '';
    $catValueSearch.style.display = 'none';
    $catMainContent.innerHTML = '<div class="cat-empty">No categorical columns detected.</div>';
    return;
  }

  // Restore main content structure if replaced by empty message
  if (!$catMainContent.querySelector('.cat-chart')) {
    $catMainContent.innerHTML = '';
    $catMainContent.appendChild($catChart);
    $catMainContent.appendChild($catValueTableWrap);
  }
  $catValueSearch.style.display = '';

  // Auto-focus first column if none focused
  if (catFocusedCol === null || !categories[catFocusedCol]) {
    catFocusedCol = catCols[0];
  }

  renderCatSidebar();
  renderCatMain();
  wireCatEventsOnce();
}

function renderCatSidebar() {
  if (!_catData) return;
  var categories = _catData.categories;
  var header = _catData.header;
  var origColCount = _catData.origColCount;
  var catCols = Object.keys(categories).map(Number).sort(function(a,b){return a-b;});
  var search = _catColSearch.toLowerCase();
  var html = '';
  for (var ci = 0; ci < catCols.length; ci++) {
    var i = catCols[ci];
    var name = header[i];
    if (search && !fuzzyMatch(search, name.toLowerCase())) continue;
    var cat = categories[i];
    var uniqueCount = Object.keys(cat.counts).length + (cat.overflow ? '+' : '');
    var isCalcol = i >= origColCount;
    var active = i === catFocusedCol ? ' active' : '';
    html += '<div class="cat-col-item' + active + '" data-col="' + i + '">';
    html += '<span class="col-name">' + esc(name) + '</span>';
    if (isCalcol) html += '<span class="calcol-tag">CALC</span>';
    html += '<span class="col-count">' + uniqueCount + '</span>';
    html += '</div>';
  }
  $catColList.innerHTML = html;
}

function renderCatMain() {
  if (!_catData || catFocusedCol === null) return;
  renderCatToolbar();
  renderCatBarChart();
  renderCatValueTable();
}

function getCatSortedEntries(colIdx) {
  if (!_catData) return [];
  var cat = _catData.categories[colIdx];
  if (!cat) return [];
  var entries = Object.entries(cat.counts);
  var colName = _catData.header[colIdx];
  var defaultSort = (typeof bmaSettings !== 'undefined' && bmaSettings && bmaSettings.defaultCatSort) ? bmaSettings.defaultCatSort : 'count-desc';
  var mode = catSortModes[colName] || defaultSort;

  if (mode === 'count-desc') {
    entries.sort(function(a,b){ return b[1] - a[1]; });
  } else if (mode === 'count-asc') {
    entries.sort(function(a,b){ return a[1] - b[1]; });
  } else if (mode === 'alpha') {
    entries.sort(function(a,b){ return a[0].localeCompare(b[0]); });
  } else if (mode === 'custom') {
    var order = catCustomOrders[colName];
    if (order) {
      var posMap = {};
      for (var oi = 0; oi < order.length; oi++) posMap[order[oi]] = oi;
      entries.sort(function(a,b){
        var pa = posMap[a[0]] !== undefined ? posMap[a[0]] : 999999;
        var pb = posMap[b[0]] !== undefined ? posMap[b[0]] : 999999;
        return pa - pb;
      });
    }
  }
  return entries;
}

function renderCatToolbar() {
  if (!_catData || catFocusedCol === null) return;
  var header = _catData.header;
  var origColCount = _catData.origColCount;
  var colName = header[catFocusedCol];
  var isCalcol = catFocusedCol >= origColCount;
  var defaultSort = (typeof bmaSettings !== 'undefined' && bmaSettings && bmaSettings.defaultCatSort) ? bmaSettings.defaultCatSort : 'count-desc';
  var mode = catSortModes[colName] || defaultSort;

  // Meta info
  var cat = _catData.categories[catFocusedCol];
  var entries = Object.entries(cat.counts);
  var uniqueCount = entries.length + (cat.overflow ? '+' : '');
  var total = entries.reduce(function(s,e){ return s + e[1]; }, 0);
  var nullCount = _catData.rowCount - total;
  var entropy = 0;
  if (total > 0) {
    for (var ei = 0; ei < entries.length; ei++) {
      var c = entries[ei][1];
      if (c <= 0) continue;
      var p = c / total;
      entropy -= p * Math.log2(p);
    }
  }
  var maxEntropy = entries.length > 1 ? Math.log2(entries.length) : 0;
  var normPct = maxEntropy > 0 ? Math.round((entropy / maxEntropy) * 100) : 0;

  var html = '<div class="cat-toolbar-title">' + esc(colName);
  if (isCalcol) html += ' <span class="calcol-tag">CALC</span>';
  html += '</div>';

  // Meta badges
  html += '<span style="font-size:0.62rem;color:var(--fg-dim)">' + uniqueCount + ' unique';
  if (nullCount > 0) html += ' \u00B7 ' + nullCount.toLocaleString() + ' null';
  if (maxEntropy > 0) html += ' \u00B7 H=' + entropy.toFixed(2) + ' (' + normPct + '%)';
  html += '</span>';

  // Sort buttons
  html += '<div class="cat-sort-group">';
  html += '<button class="cat-sort-btn' + (mode === 'count-desc' ? ' active' : '') + '" data-sort="count-desc" title="Sort by count descending">Count\u2193</button>';
  html += '<button class="cat-sort-btn' + (mode === 'count-asc' ? ' active' : '') + '" data-sort="count-asc" title="Sort by count ascending">Count\u2191</button>';
  html += '<button class="cat-sort-btn' + (mode === 'alpha' ? ' active' : '') + '" data-sort="alpha" title="Sort alphabetically">A-Z</button>';
  html += '<button class="cat-sort-btn' + (mode === 'custom' ? ' active' : '') + '" data-sort="custom" title="Custom drag order">Custom</button>';
  html += '</div>';

  // Copy button
  html += '<button class="cat-copy-btn" id="catCopyBtn" title="Copy as table">Copy</button>';

  $catToolbar.innerHTML = html;
}

function renderCatBarChart() {
  if (!_catData || catFocusedCol === null) return;
  var colName = _catData.header[catFocusedCol];
  var entries = getCatSortedEntries(catFocusedCol);
  if (entries.length === 0) { $catChart.innerHTML = ''; return; }

  var total = entries.reduce(function(s,e){ return s + e[1]; }, 0);
  var maxCount = 0;
  for (var i = 0; i < entries.length; i++) { if (entries[i][1] > maxCount) maxCount = entries[i][1]; }

  // Determine how many bars to show
  var showAll = catChartShowAll || entries.length <= 30;
  var showEntries = showAll ? entries : entries.slice(0, 20);

  var barH = 18, gap = 2, labelW = 120, rightPad = 60;
  var chartH = showEntries.length * (barH + gap) + 30; // +30 for Pareto line clearance
  var chartW = 600;
  var barAreaW = chartW - labelW - rightPad;

  var svg = '<svg viewBox="0 0 ' + chartW + ' ' + chartH + '" xmlns="http://www.w3.org/2000/svg" style="font-family:var(--mono)">';

  // Bars + Pareto
  var cumPct = 0;
  var paretoPoints = [];
  for (var bi = 0; bi < showEntries.length; bi++) {
    var val = showEntries[bi][0];
    var count = showEntries[bi][1];
    var barW = maxCount > 0 ? (count / maxCount) * barAreaW : 0;
    var y = bi * (barH + gap);
    var color = getCategoryColor(colName, val, bi);

    // Bar
    svg += '<rect x="' + labelW + '" y="' + y + '" width="' + barW.toFixed(1) + '" height="' + barH + '" fill="' + color + '" opacity="0.75" rx="2"/>';

    // Label (truncated)
    var dispVal = val.length > 18 ? val.substring(0, 17) + '\u2026' : val;
    svg += '<text x="' + (labelW - 6) + '" y="' + (y + barH / 2 + 3.5) + '" text-anchor="end" fill="var(--fg)" font-size="9.5">' + esc(dispVal) + '</text>';

    // Count + %
    var pct = total > 0 ? (count / total * 100).toFixed(1) : '0.0';
    svg += '<text x="' + (labelW + barW + 4) + '" y="' + (y + barH / 2 + 3.5) + '" fill="var(--fg-dim)" font-size="8.5">' + count.toLocaleString() + ' (' + pct + '%)</text>';

    // Pareto accumulation
    cumPct += total > 0 ? count / total * 100 : 0;
    paretoPoints.push({ x: labelW + barW, y: y + barH / 2, pct: cumPct });
  }

  // Pareto line
  if (paretoPoints.length > 1 && total > 0) {
    var pPath = '';
    for (var pi = 0; pi < paretoPoints.length; pi++) {
      var px = labelW + (paretoPoints[pi].pct / 100) * barAreaW;
      var py = paretoPoints[pi].y;
      pPath += (pi === 0 ? 'M' : 'L') + px.toFixed(1) + ',' + py.toFixed(1);
    }
    svg += '<path d="' + pPath + '" fill="none" stroke="var(--amber)" stroke-width="1.5" opacity="0.6" stroke-dasharray="4,3"/>';
    // Mark 80% line if it fits
    var line80y1 = 0, line80y2 = paretoPoints[paretoPoints.length - 1].y;
    var line80x = labelW + 0.8 * barAreaW;
    svg += '<line x1="' + line80x.toFixed(1) + '" y1="' + line80y1 + '" x2="' + line80x.toFixed(1) + '" y2="' + line80y2.toFixed(1) + '" stroke="var(--amber)" stroke-width="0.5" opacity="0.3" stroke-dasharray="2,4"/>';
    svg += '<text x="' + line80x.toFixed(1) + '" y="' + (line80y2 + 14) + '" text-anchor="middle" fill="var(--amber)" font-size="8" opacity="0.5">80%</text>';
  }

  svg += '</svg>';

  var toggleHtml = '';
  if (!showAll && entries.length > 30) {
    toggleHtml = '<div class="cat-chart-toggle" id="catChartToggle">Show all ' + entries.length + ' values \u25BE</div>';
  } else if (catChartShowAll && entries.length > 30) {
    toggleHtml = '<div class="cat-chart-toggle" id="catChartToggle">Show top 20 \u25B4</div>';
  }

  $catChart.innerHTML = svg + toggleHtml;
}

function renderCatValueTable() {
  if (!_catData || catFocusedCol === null) return;
  var colName = _catData.header[catFocusedCol];
  var entries = getCatSortedEntries(catFocusedCol);
  var total = entries.reduce(function(s,e){ return s + e[1]; }, 0);
  var maxCount = 0;
  for (var i = 0; i < entries.length; i++) { if (entries[i][1] > maxCount) maxCount = entries[i][1]; }
  var defaultSort = (typeof bmaSettings !== 'undefined' && bmaSettings && bmaSettings.defaultCatSort) ? bmaSettings.defaultCatSort : 'count-desc';
  var mode = catSortModes[colName] || defaultSort;
  var isCustom = mode === 'custom';
  var search = ($catValueSearch.value || '').toLowerCase();

  // Limit to 500 values
  var show = entries.slice(0, 500);

  var html = '<thead><tr>';
  if (isCustom) html += '<th></th>'; // drag handle column
  html += '<th></th><th></th><th>Value</th><th>Count</th><th>%</th></tr></thead><tbody>';

  for (var ri = 0; ri < show.length; ri++) {
    var val = show[ri][0];
    var count = show[ri][1];
    if (search && !fuzzyMatch(search, val.toLowerCase())) continue;
    var pct = total > 0 ? (count / total * 100).toFixed(1) : '0.0';
    var barPct = maxCount > 0 ? (count / maxCount * 100).toFixed(1) : '0';
    var color = getCategoryColor(colName, val, ri);

    html += '<tr style="--bar:' + barPct + '%" data-val="' + esc(val) + '">';
    if (isCustom) html += '<td class="cat-drag-cell" draggable="true">\u2261</td>';
    html += '<td class="cat-swatch-cell"><span class="cat-swatch" style="background:' + color + '" data-col="' + catFocusedCol + '" data-val="' + esc(val) + '"></span></td>';
    html += '<td class="cat-cb-cell"><input type="checkbox" data-col="' + catFocusedCol + '" data-val="' + esc(val) + '"></td>';
    html += '<td class="cat-val-cell">' + esc(val) + '</td>';
    html += '<td class="cat-count-cell">' + count.toLocaleString() + '</td>';
    html += '<td class="cat-pct-cell">' + pct + '%</td>';
    html += '</tr>';
  }

  if (entries.length > 500) {
    var colSpan = isCustom ? 7 : 6;
    html += '<tr><td colspan="' + colSpan + '" style="color:var(--fg-dim);text-align:center;font-size:0.65rem;padding:0.4rem;">Showing 500 of ' + entries.length + ' values</td></tr>';
  }

  html += '</tbody>';
  $catValueTable.innerHTML = html;
}

function showCatColorPicker(colName, value, anchorEl) {
  var currentColor = getCategoryColor(colName, value, 0);

  var html = '<div class="cat-color-grid">';
  for (var i = 0; i < STATSCAT_PALETTE.length; i++) {
    var c = STATSCAT_PALETTE[i];
    var sel = c.toLowerCase() === currentColor.toLowerCase() ? ' selected' : '';
    html += '<div class="cat-color-swatch' + sel + '" style="background:' + c + '" data-color="' + c + '"></div>';
  }
  html += '</div>';
  html += '<input type="text" class="cat-hex-input" placeholder="#hex" value="' + esc(currentColor) + '">';

  $catColorPicker.innerHTML = html;
  $catColorPicker.dataset.colName = colName;
  $catColorPicker.dataset.value = value;

  // Position near the anchor
  var rect = anchorEl.getBoundingClientRect();
  var mainRect = $catMain.getBoundingClientRect();
  $catColorPicker.style.top = (rect.bottom - mainRect.top + 4) + 'px';
  $catColorPicker.style.left = Math.max(0, rect.left - mainRect.left - 60) + 'px';
  $catColorPicker.classList.add('open');
}

function hideCatColorPicker() {
  $catColorPicker.classList.remove('open');
}

function applyCatColor(colName, value, color) {
  if (!catColorOverrides[colName]) catColorOverrides[colName] = {};
  catColorOverrides[colName][value] = color;
  renderCatBarChart();
  renderCatValueTable();
  autoSaveProject();
}

function initCustomOrder(colName) {
  if (!catCustomOrders[colName]) {
    var entries = getCatSortedEntries(catFocusedCol);
    catCustomOrders[colName] = entries.map(function(e){ return e[0]; });
  }
}

function wireCatEventsOnce() {
  if (_catEventsWired) return;
  _catEventsWired = true;

  // Sidebar column click
  $catColList.addEventListener('click', function(e) {
    var item = e.target.closest('.cat-col-item');
    if (!item) return;
    var colIdx = parseInt(item.dataset.col);
    if (colIdx === catFocusedCol) return;
    catFocusedCol = colIdx;
    catChartShowAll = false;
    $catValueSearch.value = '';
    renderCatSidebar();
    renderCatMain();
    autoSaveProject();
  });

  // Sidebar search
  $catColSearch.addEventListener('input', function() {
    _catColSearch = $catColSearch.value;
    renderCatSidebar();
  });

  // Sort buttons (delegated on toolbar)
  $catToolbar.addEventListener('click', function(e) {
    var sortBtn = e.target.closest('.cat-sort-btn');
    if (sortBtn) {
      var colName = _catData.header[catFocusedCol];
      var newMode = sortBtn.dataset.sort;
      catSortModes[colName] = newMode;
      if (newMode === 'custom') initCustomOrder(colName);
      renderCatToolbar();
      renderCatBarChart();
      renderCatValueTable();
      autoSaveProject();
      return;
    }

    // Copy button
    var copyBtn = e.target.closest('#catCopyBtn');
    if (copyBtn) {
      var entries = getCatSortedEntries(catFocusedCol);
      var total = entries.reduce(function(s,e){ return s + e[1]; }, 0);
      var lines = ['Value\tCount\t%'];
      for (var i = 0; i < entries.length; i++) {
        var pct = total > 0 ? (entries[i][1] / total * 100).toFixed(1) : '0.0';
        lines.push(entries[i][0] + '\t' + entries[i][1] + '\t' + pct + '%');
      }
      navigator.clipboard.writeText(lines.join('\n'));
      copyBtn.textContent = 'Copied!';
      setTimeout(function(){ copyBtn.textContent = 'Copy'; }, 1500);
    }
  });

  // Chart toggle (delegated on chart area)
  $catChart.addEventListener('click', function(e) {
    if (e.target.closest('.cat-chart-toggle')) {
      catChartShowAll = !catChartShowAll;
      renderCatBarChart();
    }
  });

  // Value search
  $catValueSearch.addEventListener('input', function() {
    renderCatValueTable();
  });

  // Table event delegation
  $catValueTable.addEventListener('click', function(e) {
    // Swatch click → color picker
    var swatch = e.target.closest('.cat-swatch');
    if (swatch) {
      var colName = _catData.header[parseInt(swatch.dataset.col)];
      showCatColorPicker(colName, swatch.dataset.val, swatch);
      return;
    }

    // Checkbox change
    var cb = e.target.closest('input[type="checkbox"]');
    if (cb) {
      var tr = cb.closest('tr');
      if (tr) tr.classList.toggle('active', cb.checked);
      rebuildFilterExpression();
      return;
    }
  });

  // Color picker delegation
  $catColorPicker.addEventListener('click', function(e) {
    var swatch = e.target.closest('.cat-color-swatch');
    if (swatch) {
      var cn = $catColorPicker.dataset.colName;
      var v = $catColorPicker.dataset.value;
      applyCatColor(cn, v, swatch.dataset.color);
      hideCatColorPicker();
      return;
    }
  });

  // Hex input
  $catColorPicker.addEventListener('change', function(e) {
    if (e.target.classList.contains('cat-hex-input')) {
      var hex = e.target.value.trim();
      if (/^#?[0-9a-fA-F]{3,8}$/.test(hex)) {
        if (hex[0] !== '#') hex = '#' + hex;
        var cn = $catColorPicker.dataset.colName;
        var v = $catColorPicker.dataset.value;
        applyCatColor(cn, v, hex);
        hideCatColorPicker();
      }
    }
  });

  // Close color picker on click outside
  document.addEventListener('click', function(e) {
    if (!$catColorPicker.classList.contains('open')) return;
    if ($catColorPicker.contains(e.target)) return;
    if (e.target.classList.contains('cat-swatch')) return;
    hideCatColorPicker();
  });

  // Close color picker on Escape
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && $catColorPicker.classList.contains('open')) {
      hideCatColorPicker();
    }
  });

  // Drag and drop for custom ordering
  var dragSrcRow = null;
  $catValueTable.addEventListener('dragstart', function(e) {
    var tr = e.target.closest('tr');
    if (!tr || !e.target.classList.contains('cat-drag-cell')) return;
    dragSrcRow = tr;
    tr.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', tr.dataset.val);
  });

  $catValueTable.addEventListener('dragover', function(e) {
    e.preventDefault();
    var tr = e.target.closest('tr');
    if (!tr || tr === dragSrcRow) return;
    e.dataTransfer.dropEffect = 'move';
    // Clear previous drag-over
    $catValueTable.querySelectorAll('.drag-over').forEach(function(el){ el.classList.remove('drag-over'); });
    tr.classList.add('drag-over');
  });

  $catValueTable.addEventListener('dragleave', function(e) {
    var tr = e.target.closest('tr');
    if (tr) tr.classList.remove('drag-over');
  });

  $catValueTable.addEventListener('drop', function(e) {
    e.preventDefault();
    var tr = e.target.closest('tr');
    if (!tr || !dragSrcRow || tr === dragSrcRow) return;
    $catValueTable.querySelectorAll('.drag-over').forEach(function(el){ el.classList.remove('drag-over'); });
    dragSrcRow.classList.remove('dragging');

    var colName = _catData.header[catFocusedCol];
    initCustomOrder(colName);
    var order = catCustomOrders[colName];
    var fromVal = dragSrcRow.dataset.val;
    var toVal = tr.dataset.val;
    var fromIdx = order.indexOf(fromVal);
    var toIdx = order.indexOf(toVal);
    if (fromIdx >= 0 && toIdx >= 0) {
      order.splice(fromIdx, 1);
      var newToIdx = order.indexOf(toVal);
      order.splice(newToIdx, 0, fromVal);
      renderCatBarChart();
      renderCatValueTable();
      autoSaveProject();
    }
    dragSrcRow = null;
  });

  $catValueTable.addEventListener('dragend', function() {
    if (dragSrcRow) dragSrcRow.classList.remove('dragging');
    $catValueTable.querySelectorAll('.drag-over').forEach(function(el){ el.classList.remove('drag-over'); });
    dragSrcRow = null;
  });
}

// ─── CDF Plot ─────────────────────────────────────────────────────────
$cdfClose.addEventListener('click', () => $cdfModal.classList.remove('active'));
$cdfModal.addEventListener('click', (e) => { if (e.target === $cdfModal) $cdfModal.classList.remove('active'); });
document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && $cdfModal.classList.contains('active')) $cdfModal.classList.remove('active'); });

function showCDF(colIdx) {
  const s = lastDisplayedStats[colIdx];
  const name = lastDisplayedHeader[colIdx];
  if (!s || !s.centroids || s.centroids.length === 0) return;
  renderCDFModal(s, name);
}

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js');
}

// Load recent files on page load
renderRecentFiles();
</script>
</body>
</html>
